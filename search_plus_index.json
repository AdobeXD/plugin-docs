{"./":{"url":"./","title":"Overview","keywords":"","body":"Plugin APIs Bring new features and capabilities to XD Shape the future of design by creating plugins for yourself, your team, or the world. To share a plugin for all XD users, submit it to Adobe. After review, you’ll be published in the XD Plugin Manager. Quick start: create your first plugin We’ll keep things simple in this Quick Start tutorial. Once you’re done, you’ll have a solid grasp of how to start creating your own XD plugin. We’ll also give you some next steps for learning more. Start coding Design using the XD plugin UI kit XD plugins are used by designers around the world who expect great experiences. Download the XD plugin UI kit to start crafting your own XD plugin experience. Download Manage your plugin project Whether you’re getting your unique plugin ID, submitting your finished plugin for review, or updating your XD Plugin Manager listing, the Adobe Developer Console is the place to manage your plugin project. Visit the Adobe Developer Console Plugin API roadmap We’ve got a lot of stuff planned for the future of Plugin APIs on the Adobe XD platform, and we’ve built out a roadmap. View Trello board "},"develop.html":{"url":"develop.html","title":"Develop","keywords":"","body":"Develop XD plugins extend the capabilities of Adobe XD by adding new features to the app, automating workflows, connecting the app to external services, and more. On this page, we'll give you a quick overview of what you can build and how to get started. From there, you can choose your own adventure: build a \"Hello, World\" plugin in our Quick Start tutorial, follow our tutorials, try code-complete sample plugins, or browse the API references. Oh, and be sure to join the developer community while you're here! We want you to say hi (we'll say hi back). Now, let’s supercharge the future of design together with XD plugins! What can you build? Plugins can be tools that help users create or automate their workflow, they can streamline collaboration by allowing users to import and export, and they can also provide users with external information. The XD plugin APIs enable you to build plugins for a number of use cases, to help you get started here are three points to think about. The plugin workflow - Identify the user stories for your plugin Key plugin action - What are the key interactions for you plugin that would be valuable to your users Entry point and UI for your plugin in XD - consider the users intention in XD when interacting with your plugin Users workflow in XD Getting Started There are lots of ways to journey through the documentation on your way to building the next great XD plugin. If you're just getting started, we recommend following the left-hand navigation on this site from top to bottom (or until you're ready to plot your own course!). Here are some highlights you won't want to miss: Get Started: To begin, try our Quick Start tutorial, then follow along with the API feature tutorials. Go deep: Learn more about how to build an XD plugin by reading the plugin development 101 and then dig into the API reference. See code: If you prefer to learn from working code, we have a samples repo on GitHub for you to take a look at. "},"tutorials/quick-start/":{"url":"tutorials/quick-start/","title":"Quick start","keywords":"","body":"Quick Start: Make your first XD plugin Let’s walk through creating your first Adobe XD plugin together. We'll keep things simple in this Quick Start tutorial. Once you're done, you'll have a solid grasp of the steps to take when starting to create your own XD plugin. At the end of the tutorial, we'll suggest some next steps for going deeper with the XD plugin APIs. Prerequisites Basic knowledge of HTML, CSS, and JavaScript A text editor to write your code in (like VSCode, Sublime Text, Brackets, Atom, etc) Development Steps Complete code for this plugin can be found on GitHub. 0. Get a plugin ID from the Adobe Developer Console Before you start, you'll want to create a plugin project on the Adobe Developer Console. Go to the Adobe Developer Console and sign in or sign up Click \"Create Empty Project\" Create a plugin project by clicking \"Add XD Plugin\" Give it a project name. Note that this project name is not public; it is only visible to you and can be changed directly on the Console later. On the following page, get the 8-character unique plugin ID in the \"Plugin Details\" section. Optionally on the same page, download the starter project, which contains a functioning Hello, World sample plugin. We'll use your plugin ID in one of the next steps. 1. Identify where your plugins are located Adobe XD loads plugins that are in development from a develop folder in a specific location on your machine. To get to that folder, simply go to this menu item: Plugins > Development > Show Develop Folder. This will open the develop folder, which we'll use in the next step. 2. Create your plugin scaffold Next, you'll need to make a new folder within the develop folder to store the plugin files that you'll create below. Name your new plugin folder anything you like. Now, let's create your plugin files. Open your favorite text editor and create two files inside of your new plugin folder with these exact names: manifest.json This file includes information about the plugin, such as its name, the menu item(s) it adds to XD, and so on. Learn about the manifest here. main.js This file contains your JavaScript code that implements your plugin's functionality. Learn more about main.js here. These two files go into your plugin's parent directory. When you have the right structure, it will look like this: my-plugin-folder ├── main.js └── manifest.json It's possible to have more files if you want, but these files are the bare minimum requirement for your plugin to work, and are all we'll need for this Quick Start tutorial. 3. Create your plugin’s manifest In the previous step, you created a file named manifest.json. Open that file and paste in this JSON object: { \"id\": \"YOUR_ID_HERE\", \"name\": \"Hello World sample plugin\", \"version\": \"0.0.1\", \"description\": \"Description of your plugin.\", \"summary\": \"Summary of your plugin\", \"languages\": [\"en\"], \"author\": \"Your Name\", \"helpUrl\": \"https://mywebsite.com/help\", \"host\": { \"app\": \"XD\", \"minVersion\": \"13.0\" }, \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"Create Rectangle\", \"commandId\": \"createRectangle\" } ] } Be sure to replace the id value with the unique plugin ID you got from the Adobe Developer Console in the first step: \"id\": \"1234ABCD\", If you're curious about what each entry means, see the manifest documentation, where you can also learn about all manifest requirements for a plugin to be published in the XD Plugin Manager. The value of the commandId property may be any string; in this case, it's createRectangle. In the next section, we will see how this string is associated with the code for our plugin. 4. Create your plugin’s code Next, we need to create the JavaScript code for our plugin. The code lives in a file named main.js, which we created in step #2. Paste this code into main.js: // [1] const { Rectangle, Color } = require(\"scenegraph\"); // [2] function rectangleHandlerFunction(selection) { // [3] const newElement = new Rectangle(); newElement.width = 100; newElement.height = 50; newElement.fill = new Color(\"Purple\"); // [4] selection.insertionParent.addChild(newElement); // [5] newElement.moveInParentCoordinates(100, 100); } // [6] module.exports = { commands: { createRectangle: rectangleHandlerFunction } }; This code does the following: Gets references to the Rectangle and Color classes from XD’s scenegraph module. There are several different API modules you can load using require(). Defines our handler function. The handler function will run when the user selects the Plugins > Create Rectangle menu item. Creates a new Rectangle object with width, height, and color properties. Adds the Rectangle object to the scenegraph at the top-left (coordinates 0, 0). Puts the Rectangle object at coordinates 100, 100 within the parent element. Exports an object, with a commands property. The value of commands is an object which associates the JavaScript handler function (rectangleHandlerFunction) with your manifest's commandId property. The command ID property name (here, createRectangle) must match the commandId value declared in your manifest exactly. 5. Run your plugin So you’ve written a plugin! How do we run it? If you haven’t already done so, launch XD and open a new document. Then navigate to the Plugins > Create Rectangle menu item. Alternatively, if XD was already open, select Plugins > Development > Reload Plugins. Congratulations! You’ve built your first plugin for Adobe XD! Next Steps Learn about debugging plugins Follow our tutorials See working code in our sample repos on GitHub Browse the API references "},"tutorials/quick-start-react/":{"url":"tutorials/quick-start-react/","title":"Quick start - React","keywords":"","body":"Quick Start - React: Make your first XD plugin with React While there are many choices when it comes to picking a JavaScript framework to build an XD plugin, we want to cover one of the most popular frameworks, React, first. Once you're done, you'll have a solid grasp of the steps to take when starting to create your own XD plugin with React. Prerequisites Basic knowledge of HTML, CSS, JavaScript, and React A text editor to write your code in (like VSCode, Sublime Text, Brackets, Atom, etc) Quick Start tutorial node and npm installed Development Steps Complete code for this plugin can be found on GitHub. 0. Folder structure Note that we are going to use webpack to bundle JavaScript files for usage in XD and the yarn package manager to install dependencies. When you have the right structure, it will look like this: my-plugin-folder └── src └── main.jsx └── HelloForm.jsx └── react-shim.js └── manifest.json └── package.json └── webpack.config.js 1. Install dependencies In order to correctly use React in XD, you will have to install dependencies correctly. Follow the steps below: List the required dependencies in package.json { \"name\": \"helllo_react_jsx\", \"version\": \"1.0.0\", \"main\": \"main.js\", \"scripts\": { \"watch\": \"nodemon -w src -e js,jsx,css -w webpack.config.js -x yarn build\", \"build\": \"webpack --mode development\" }, \"license\": \"none\", \"private\": true, \"devDependencies\": { \"nodemon\": \"^1.18.7\", \"webpack\": \"^4.16.4\", \"webpack-cli\": \"^3.1.0\" }, \"dependencies\": { \"babel-core\": \"^6.26.3\", \"babel-loader\": \"^7.1.5\", \"babel-plugin-transform-react-jsx\": \"^6.24.1\", \"css-loader\": \"^1.0.0\", \"react\": \"^16.4.2\", \"react-dom\": \"^16.4.2\", \"style-loader\": \"^0.22.0\", \"yarn\": \"^1.12.3\" } } List the webpack configurations in webpack.config.js module.exports = { entry: \"./src/main.jsx\", output: { path: __dirname, filename: \"main.js\", libraryTarget: \"commonjs2\" }, devtool: \"none\", module: { rules: [ { test: /\\.jsx?$/, exclude: /node_modules/, loader: \"babel-loader\", options: { plugins: [\"transform-react-jsx\"] } }, { test: /\\.css$/, use: [\"style-loader\", \"css-loader\"] } ] }, externals: { scenegraph: \"scenegraph\" } }; As per webpack's documentation, The externals configuration option provides a way of excluding dependencies from the output bundles. Instead, the created bundle relies on that dependency to be present in the consumer's environment. Note that, in this example, we are excluding the scenegraph API from the output bundles since this dependency is present in the XD environment. Install yarn, if needed npm install -g yarn Install dependencies yarn install All dependencies are installed and we are good to go! 2. Create your main files Now, let's create your plugin files. Open your favorite text editor and create the following files and folders (we'll add code to them in later steps): manifest.json is your plugin’s manifest. This file includes information about the plugin, such as its name, the menu item(s) it adds to XD, and so on. Learn about the manifest here. src is your plugin's folder that contains all JavaScript files that are going to be compiled main.jsx is the main file for the plugin HelloForm.jsx is the file that contains the only React component we are going to use. Note that you can have multiple .jsx files if needed react-shim.js is a JavaScript file that helps React run smoothly in XD's environment. Further details to follow in a later section 3. Edit your plugin’s manifest In the previous step, you created a file named manifest.json. Open that file and paste in this JSON object: { \"id\": \"QUICKSTART_REACT\", \"name\": \"Quick Start - React\", \"version\": \"1.0.0\", \"description\": \"Description of your plugin.\", \"summary\": \"Summary of your plugin\", \"languages\": [\"en\"], \"author\": \"Your Name\", \"helpUrl\": \"https://mywebsite.com/help\", \"host\": { \"app\": \"XD\", \"minVersion\": \"13.0\" }, \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"Quick Start - React\", \"commandId\": \"main\" } ] } Be sure to replace the id value with the unique plugin ID you get from the Adobe Developer Console. \"id\": \"1234ABCD\", Make sure to read Quick Start tutorial to learn how to get your unique plugin ID from the Adobe Developer Console. If you're curious about what each entry in the manifest means, see the manifest documentation, where you can also learn about all manifest requirements for a plugin to be published in the XD Plugin Manager. The value of the commandId property may be any string; in this case, it's main. In the next section, we will see how this string is associated with the code for our plugin. 4. Create your plugin’s code Next, we need to create the JavaScript code for our plugin. As noted in the Quick Start tutorial, the code lives in a file named main.js. This file will be automatically created when Webpack compiles all JavaScript files in your src folder. In this tutorial, the src folder will contain the following: src └── main.jsx └── HelloForm.jsx └── react-shim.js Now, lets start writing code in these JavaScript files. First of all, as noted earlier, we need react-shim.js file to make React run without any issue in the XD environment. Paste this code into react-shim.js: if (window.setTimeout == null) { window.setTimeout = function(fn) { fn(); }; } if (window.clearTimeout == null) { window.clearTimeout = function() {}; } if (window.cancelAnimationFrame == null) { window.cancelAnimationFrame = function() {}; } if (window.requestAnimationFrame == null) { window.requestAnimationFrame = function() { console.log(\"requestAnimationFrame is not supported yet\"); }; } if (window.HTMLIFrameElement == null) { window.HTMLIFrameElement = class HTMLIFrameElement {}; } Since XD currently does not currently support cancelAnimationFrame, requestAnimationFrame, and HTMLIFrameElement, we create these empty functions and classes to prevent your plugin from crashing. As of XD 16, setTimeout and clearTimeout are supported in the XD plugin API, but are still included in the shim for compatibility with older versions of XD. Next, let's create a React component. Paste the following code in HelloForm.jsx: // [1] const React = require(\"react\"); // [2] const { Text, Color } = require(\"scenegraph\"); // [3] class HelloForm extends React.Component { // [4] constructor(props) { super(props); this.state = { name: \"\" }; // [5] // [6] this.onInputChange = e => { this.setState({ name: e.target.value }); }; // [7] this.onDoneClick = e => { // [8] const selection = this.props.selection; // [9] const newText = new Text(); newText.text = this.state.name; // [10] newText.styleRanges = [ { length: newText.text.length, fill: new Color(\"#00F\"), fontSize: 50 } ]; // [11] selection.insertionParent.addChild(newText); // [12] newText.moveInParentCoordinates(100, 100); // [13] props.dialog.close(); }; } // [14] render() { return ( React with JSX Components What is your name? {`Hello ${this.state.name}`} Done ); } } module.exports = HelloForm; This code does the following: Gets reference to react module installed in an earlier step Gets references to the Text and Color classes from XD’s scenegraph module. There are several different API modules you can load using require(). Creates a react component called HelloForm Since you are going to initialize state and bind methods, implements a constructor for this React component and calls super(props) to use props passed down from the parent Initializes a state property called name with an empty string onInputChange method sets the name state with the string value passed from the input field onDoneClick is triggered after the submission happens and manipulates XD objects Creates a reference to selection passed down as a prop Creates a Text instance and sets the text value as the input stored in the name state Styles the text. More info on styling text can be found in how-to-style-text tutorial addChild method inserts the created text into the ideal insertion point determined by the insertionParent property of the selection object Moves the added text 100 pixels from the top and 100 pixels from the left of the insertion point Closes the dialog Renders the component. Note that there is an input field to accept user's input and a button for the submission of the input Lastly, let's create the main jsx file, main.jsx. Paste the following code into main.jsx: // [1] const reactShim = require(\"./react-shim\"); // [2] const React = require(\"react\"); const ReactDOM = require(\"react-dom\"); // [3] const App = require(\"./HelloForm.jsx\"); function main(selection) { let dialog; function getDialog() { if (dialog == null) { // [4] dialog = document.createElement(\"dialog\"); // [5] ReactDOM.render(, dialog); } return dialog; } // [6] return document.body.appendChild(getDialog()).showModal(); } // [7] module.exports = { commands: { main } }; This code does the following: Loads react-shim.js to make React run in the XD environment Gets reference to react and react-dom modules installed earlier in the steps Imports our HelloForm component Creates a dialog element in the document Renders the imported HelloForm component and passes dialog and selection objects as props. Note that the dialog is reused, so it gets rendered only once. Loads the modal inside the XD document Exports an object, with a commands property. The value of commands is an object which associates the JavaScript handler function (main) with your manifest's commandId property. The command ID property name (here, main) must match the commandId value declared in your manifest exactly. 5. Compile the code Developement - Run yarn watch to compile the code and watch for changes. This process will create the main.js file to be read by Adobe XD. Production - Run yarn build to build the final version of your plugin. 5. Run your plugin So you’ve written a plugin using React! How do we run it? If you haven’t already done so, launch XD and open a new document. Then navigate to the Plugins > Quick Start - React menu item. Alternatively, if XD was already open, select Plugins > Development > Reload Plugins. Congratulations! You’ve built your first plugin using React! Next Steps Learn about debugging plugins Follow our tutorials See working code in our sample repos on GitHub Browse the API references "},"tutorials/quick-start-panel/":{"url":"tutorials/quick-start-panel/","title":"Quick start - Panel UI","keywords":"","body":"Quick Start: Make your first XD panel plugin Let’s walk through creating your first Adobe XD panel plugin together. We'll keep things simple in this Quick Start tutorial. Once you're done, you'll have a solid grasp of the steps to take when starting to create your own XD panel plugin. At the end of the tutorial, we'll suggest some next steps for going deeper with the XD plugin APIs. Prerequisites Basic knowledge of HTML, CSS, and JavaScript A text editor to write your code in (like VSCode, Sublime Text, Brackets, Atom, etc) Development Steps Complete code for this plugin can be found on GitHub. 0. Get a plugin ID from the Adobe Developer Console Before you start, you'll want to create a plugin project on the Adobe Developer Console. Go to the Adobe Developer Console and sign in or sign up Click \"Create Empty Project\" Create a plugin project by clicking \"Add XD Plugin\" Give it a project name. Note that this project name is not public; it is only visible to you and can be changed directly on the Console later. On the following page, get the 8-character unique plugin ID in the \"Plugin Details\" section. Optionally on the same page, download the starter project, which contains a functioning Hello, World sample plugin. We'll use your plugin ID in one of the next steps. 1. Identify where your plugins are located Adobe XD loads plugins that are in development from a develop folder in a specific location on your machine. To get to that folder, simply go to this menu item: Plugins > Development > Show Develop Folder. This will open the develop folder, which we'll use in the next step. 2. Create your plugin scaffold Next, you'll need to make a new folder within the develop folder to store the plugin files that you'll create below. Name your new plugin folder anything you like. Now, let's create your plugin files. Open your favorite text editor and create two files inside of your new plugin folder with these exact names: manifest.json This file includes information about the plugin, such as its name, the menu item(s) it adds to XD, and so on. Learn about the manifest here. main.js This file contains your JavaScript code that implements your plugin's functionality. Learn more about main.js here. These two files go into your plugin's parent directory. When you have the right structure, it will look like this: my-plugin-folder ├── main.js └── manifest.json It's possible to have more files if you want, but these files are the bare minimum requirement for your plugin to work, and are all we'll need for this Quick Start tutorial. 3. Create your plugin’s manifest In the previous step, you created a file named manifest.json. Open that file and paste in this JSON object: { \"id\": \"YOUR_ID_HERE\", \"name\": \"Enlarge a Rectangle\", \"version\": \"0.0.1\", \"description\": \"Description of your plugin.\", \"summary\": \"Summary of your plugin\", \"languages\": [\"en\"], \"author\": \"Your Name\", \"helpUrl\": \"https://mywebsite.com/help\", \"host\": { \"app\": \"XD\", \"minVersion\": \"18.0\" }, \"uiEntryPoints\": [ { \"type\": \"panel\", \"label\": \"Enlarge a Rectangle\", \"panelId\": \"enlargeRectangle\" } ] } Be sure to replace the id value with the unique plugin ID you got from the Adobe Developer Console in the first step: \"id\": \"1234ABCD\", If you're curious about what each entry means, see the manifest documentation, where you can also learn about all manifest requirements for a plugin to be published in the XD Plugin Manager. The value of the panelId property may be any string; in this case, it's enlargeRectangle. In the next section, we will see how this string is associated with the code for our plugin. 4. Create your plugin’s code Next, we need to create the JavaScript code for our plugin. The code lives in a file named main.js, which we created in step #2. Create a scaffold Let's create some empty functions first. Copy and paste this code into main.js: function create() {} function show(event) {} function update(selection) {} module.exports = { panels: { enlargeRectangle: { show, update } } }; Now, let's look at each function in detail, starting with a create helper function that we'll use to build our UI. Create the UI The create function is just a helper function we'll make to help us get started. It is going to create an HTML panel element, insert our markup, and add a click event listener. The function returns our UI in code, but does not display it (we'll get to that next): let panel; function create() { // [1] const html = ` .break { flex-wrap: wrap; } label.row > span { color: #8E8E8E; width: 20px; text-align: right; font-size: 9px; } label.row input { flex: 1 1 auto; } form { width:90%; margin: -20px; padding: 0px; } .show { display: block; } .hide { display: none; } ↕︎ ↔︎ Apply This plugin requires you to select a rectangle in the document. Please select a rectangle. `; function increaseRectangleSize() { // [2] const { editDocument } = require(\"application\"); // [3] const height = Number(document.querySelector(\"#txtV\").value); // [4] const width = Number(document.querySelector(\"#txtH\").value); // [5] // [6] editDocument({ editLabel: \"Increase rectangle size\" }, function(selection) { const selectedRectangle = selection.items[0]; // [7] selectedRectangle.width += width; // [8] selectedRectangle.height += height; }); } panel = document.createElement(\"div\"); // [9] panel.innerHTML = html; // [10] panel.querySelector(\"form\").addEventListener(\"submit\", increaseRectangleSize); // [11] return panel; // [12] } This code does the following: Creates a const called html for your UI markup, including elements for style, form, and so on. The form tag contains a div which includes two text input fields and a footer which has a button for users to click on. The p tag contains warning text which is used to warn users when they select a non-rectangle node inside the active XD document. Creates a nested function called increaseRectangleSize. Gets a reference to the editDocument method available in the application module. Gets user input value from the \"height\" input element. Gets user input value from the \"width\" input element. Makes a request XD to manipulate the active document by using the editDocument method. Gets the first currently selected node. (Some UI logic will be added later to ensure this is a rectangle.) Modifies the width and height of the selected rectangle. Creates a div element to serve as a container for your panel UI. Attaches the HTML created in step #1. Adds a submit listener for the form element, attaching the increaseRectangleSize function created in step #2. Returns the panel UI container to be used in the next step. Show the UI Next, let's look at the show function. The show function is one of the lifecycle methods for a panel plugin, and the only one that is required. The show function is called when your plugin is made visible to the user. function show(event) { // [1] if (!panel) event.node.appendChild(create()); // [2] } This code does the following: The show lifecycle method gives you access to an event argument which includes a node property that you can attach your user interface to. Adds the panel UI container returned from the create helper function to event.node if panel does not exist in the dom already. You can also optionally provide a hide lifecycle method for your panel, but we don't need to for this example. Update your UI The last lifecycle method, update, is an optional function which is called whenever the user changes the selection in the XD document or mutates a node within that selection. A mutation can be anything, including moves, resizes, etc. We'll look at this code below: function update(selection) { // [1] const { Rectangle } = require(\"scenegraph\"); // [2] const form = document.querySelector(\"form\"); // [3] const warning = document.querySelector(\"#warning\"); // [4] if (!selection || !(selection.items[0] instanceof Rectangle)) { // [5] form.className = \"hide\"; warning.className = \"show\"; } else { form.className = \"show\"; warning.className = \"hide\"; } } This code does the following: Uses the selection argument. update provides two arguments, selection and documentRoot. This example only uses selection. Gets a reference to the Rectangle object imported from the scenegraph module. Gets a reference to the form element in your HTML. Gets a reference to the p element with the warning message in your HTML. Checks if the user has selected anything and if the selection is a rectangle. If this validation passes, the form appears and the warning message is not shown. If not, the warning message is shown to the user and the form disappears. Export your lifecycle methods Finally, you need to export the panel lifecycle methods you created: module.exports = { panels: { enlargeRectangle: { show, update } } }; The above code exports an object with a panels property. The value of panels is also an object with a property that matches the panelId from your manifest, in this case enlargeRectangle. Finally, enlargeRectangle is an object containing your panel lifecycle methods. Note that the show lifecycle methods is required for all panel plugins, while the hide and update methods are optional. 5. Run your plugin So you’ve written a plugin! How do we run it? If you haven’t already done so, launch XD and open a new document. Then navigate to the Plugins > Enlarge a Rectangle menu item. This will open your panel in the plugin launchpad on the left-hand side of the XD application. Congratulations! You’ve built your first panel plugin for Adobe XD! Next Steps Learn about debugging plugins Follow our tutorials See working code in our sample repos on GitHub Browse the API references "},"tutorials/debugging/":{"url":"tutorials/debugging/","title":"Debugging plugins","keywords":"","body":"How to Debug Your Plugin Bugs happen! In this tutorial, you will learn how to debug your Adobe XD plugin. Prerequisite At least one plugin in your develop folder (you can create one using our Quick Start tutorial). Debugging Options There are two ways you can debug an XD plugin: For quick, simple debugging, use the Developer Console built into XD For in-depth debugging, set up your plugin for debugging with Chrome DevTools (beta) Quick debugging with Developer Console 1. Check the Developer Console In XD, click Plugins > Development > Developer Console. This displays information similar to what you'd find in the JS debugger's console view: Any console.log() output from your plugin Any error messages from XD due to plugin misbehavior, or failure to load a plugin Stack traces if your code throws an uncaught exception The console output for all installed XD plugins is mixed together in one single view here. 2. Reload your plugin after making fixes You can easily iterate on your plugin code without heaving to restart XD. Click Plugins > Development > Reload Plugins to reload all plugins in your develop folder. This will reflect any changes in manifest.json in addition to any changes to your JS code. There's also a handy keyboard shortcut to make reloading easier: Platform Keyboard shortcut macOS Shift-Cmd-R Windows Ctrl-Shift-R If there are any errors blocking the plugin from loading, they will appear in the Developer Console on reload: Debugging with Chrome DevTools (beta) 1. Enable debugging on your plugin Navigate to the root folder of your plugin and create a debug.json file: { \"port\": 9345, \"breakOnStart\": false } Debugging is only supported for plugins in the develop folder (not plugins installed from the Plugin Manager UI). Specify any port number you want. Advanced: Set breakOnStart to true if you want the debugger to immediately pause on the first line of code in your plugin the moment it starts loading. This is useful since you won't have a chance to open DevTools before this moment to set breakpoints before that initial code runs. 2. Launch Chrome DevTools Windows only: before launching XD, open an admin command prompt and run CheckNetIsolation LoopbackExempt -is -n=\"Adobe.CC.XD.adky2gkssdxte\" – do this each time you want to debug a plugin. Open Google Chrome and navigate to chrome://inspect (you must use Chrome) One-time setup: ensure \"Discover Network Targets\" is enabled. Click the Configure button next to this and add localhost:9345 (or whatever port number your debug.json file used). Click the \"inspect\" link under your plugin's ID. Beta: What works, what doesn't Currently, you can... Set breakpoints, pause & step through code, inspect the values of variables View objects and run code in the Console view View and edit the DOM structure of your plugin's UXP UI Most other DevTools features are not supported and may behave erratically if you attempt to use them. Important caveats: XD may be unstable while debugging a plugin. Don't debug when you have important XD documents open. Error messages are often missing from the DevTools Console. Use the Developer Console within XD (see \"Quick debugging\" above) to be sure you are not missing any important information. XD will be partially frozen while paused on a JS breakpoint. Don't try to interact with XD while paused. You may see a blank white panel to the left of the DevTools UI. Ignore this, as it does nothing. If debugging exposes any private fields and methods, do not attempt to use them. Plugins referring to private APIs will be rejected or removed from XD's plugin listing. Read the known issues for more details. Next Steps Ready to learn more about XD plugins? Learn about plugin structure Follow along with our tutorials Browse the API references "},"plugin-development-guidelines/":{"url":"plugin-development-guidelines/","title":"Plugin Development 101","keywords":"","body":"Plugin Development 101 On this page, we'll give you a quick overview of some basic concepts you need to know to build a successfull XD plugin. Here are four topics we recommend you get familiar with: Plugin structure JavaScript and XD plugin APIs XD Concepts Development best practices By learning these topics, you will fully understand how you can build an XD plugin. Here are some of the recommended next steps for you: Start by creating a very simple plugin by following our Quick Start tutorial Learn how to design your plugin by reading our Plugin Design Guidelines Try some of our samples on the samples repo on GitHub. Join the community. See our Community page to learn about how to connect. "},"reference/structure/":{"url":"reference/structure/","title":"Plugin structure","keywords":"","body":"Plugin Structure One folder and two files: that's all it takes to create an XD plugin! In this section, we'll tell you all about how plugins are structured. These tutorials will show you where to put your plugin files, how to name your plugin, and what files you need to create for an XD plugin. Plugin Location and Name Folder Structure Plugin Menu Structure "},"reference/structure/location.html":{"url":"reference/structure/location.html","title":"Plugin location","keywords":"","body":"Plugin location For XD to know your plugin exists, you'll need to put it in a certain folder on your computer and give it a name. On this page, you can learn where plugins are stored on your machine.. Parent folder path Adobe XD loads plugins from the plugins and develop folders. These folders are stored in a specific storage location based on your platform: Platform Path macOS ~/Library/Application\\ Support/Adobe/Adobe\\ XD/ Windows C:\\Users\\%USERNAME%\\AppData\\Local\\Packages\\Adobe.CC.XD_adky2gkssdxte\\LocalState\\ This path will eventually (if it doesn't already) contain two folders: develop and plugins. The develop folder The develop folder is used during plugin development, and is the only folder XD will reload plugins from when you reload plugins from the Plugins menu. XD makes it very easy for you to get to the develop folder: simply go to this menu item: Plugins > Development > Show Develop Folder. If there isn't a folder that already exists named develop, you can go ahead and create it yourself. The plugins folder The plugins folder is where production plugins are stored when the user installs them. During development, you should not store your plugin in this folder, instead opting for the develop folder, as noted above. In other words, you should not need to work with the plugins folder directly; XD will manage this folder for the user. "},"reference/structure/folder-structure.html":{"url":"reference/structure/folder-structure.html","title":"Folder structure","keywords":"","body":"Folder structure When you have the right structure for your XD plugin, it will look like this: my-plugin-folder ├── main.js └── manifest.json Your plugin's parent folder In the develop folder, create a new folder for your plugin with any name you like. Your plugin files Within the parent folder, you'll need at minimum two files, with these exact names: manifest.json is your plugin’s manifest. This file is where you include facts about your plugin, such as its name, the menu item(s) it adds to XD, and so on. Learn about the manifest here. main.js is your plugin’s code. This file contains your JavaScript code that implements the logic for your plugin. Learn more about main.js here. These two files go into your plugin's parent directory. The manifest.json and main.js files stored in your plugin's parent directory are the bare minimum requirement for your plugin to work, but it's possible to have more JavaScript files if you want. You can learn about including further JavaScript files in our JavaScript concepts section on using require. Next steps Read on to learn about the two required files: manifest.json main.js "},"reference/structure/manifest.html":{"url":"reference/structure/manifest.html","title":"manifest.json","keywords":"","body":"The manifest.json file The manifest is where you include metadata about your plugin. Simply put, the manifest is a list of facts about your plugin in the form of a JSON object. No executable code goes into your manifest. Example manifest { \"id\": \"YOUR_ID_HERE\", \"name\": \"Name of Your Plugin\", \"version\": \"0.0.1\", \"icons\": [ { \"width\": 24, \"height\": 24, \"path\": \"images/icon@1x.png\" }, { \"width\": 48, \"height\": 48, \"path\": \"images/icon@2x.png\" } ], \"host\": { \"app\": \"XD\", \"minVersion\": \"21.0\" }, \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"Hello World Command\", \"commandId\": \"helloCommand\" }, { \"type\": \"panel\", \"label\": \"Hello World Panel\", \"panelId\": \"helloPanel\" } ] } See the sections below to learn more about each key/value field. All fields are required unless otherwise noted below. Top-level metadata The top level of the manifest JSON object contains high-level information about your plugin. Here are the definitions of the keywords in the \"Required\" column: Develop - required field for XD to run the plugin. If excluded, XD won't load the plugin Publish - required field for plugins to be submitted in the Adobe Developer Console and published in the Plugin Manager Key path Type Description Required id string Unique identifier for your plugin. You can get your unique ID on the Adobe Developer Console. Develop / Publish name string The name should be 3 - 45 characters. Note: We recommend your plugin name matches the project name you created when getting your plugin ID from the Adobe Developer Console. Develop / Publish version string Version number of your plugin in x.y.z format. Version must be three segments and each version component must be between 0 and 99. Develop / Publish icons array Icons displayed in XD's plugins panel. PNG, JPG/JPEG formats are supported and the max file size for each icon is 1MB. Two sizes are required - [24, 48]. Note: Icons for XD's Plugin Manager are uploaded directly via the Adobe Developer Console, not included within your plugin itself. See our \"Publishing your plugin\" guide to learn more. Publish host.app string Indicates that this is a plugin for Adobe XD (currently, the only valid value here is \"XD\"). Develop / Publish host.minVersion string Minimum required version of the host app (in x.y format) that can run this plugin. The lowest valid version for headless and modal plugins is 13.0. The lowest valid version for panel plugins is 21.0. Note: The version number must be two segments. Typically, you'll leave the minor segment set to 0, e.g. 16.0. Develop / Publish host.maxVersion string Maximum version of host app that can run this plugin. Same formatting as host.minVersion. Optional uiEntryPoints arrayMenuItemDefinition> Describes the entries your plugin adds to the Plugins menu & \"plugin launchpad\" sidebar in XD. See the next section for details. Develop / Publish UI entry points The uiEntryPoints field is an array of objects matching the MenuItemDefinition format specified below. These entries appear both in the Plugins menu in the native menubar, and the \"plugin launchpad\" sidebar panel. See Plugin menu structure for details on how these entries are displayed. Each entry point specifies either commandId or panelId, to create either a direct-action command or a panel show/hide command. MenuItemDefinition Key Type Description type string Entry point type: either \"menu\" or \"panel\". label ?string|LocaleMap Required if multiple MenuItemDefinition objects defined; ignored if only one defined. Label for this menu item that the user will select to run your plugin. May be a single string or a dictionary of localized strings. commandId string Specify commandId to create a menu item that runs plugin code directly -- either a headless command, or a command with modal dialog UI. This identifier links the menu item to a handler function in your plugin's JavaScript code. This identifier needs to be unique within your plugin. Don't specify commandId and panelId at the same time. panelId string Specify panelId to create a menu item that opens panel UI for your plugin. This identifier links the menu item to a panel definition object in your plugin's JavaScript code. This identifier needs to be unique within your plugin. Don't specify commandId and panelId at the same time. shortcut Object Optional. Object defining Mac and Windows keyboard shortcuts for this menu item. See \"Keyboard shortcuts\" below for details. Keyboard shortcuts Example: \"shortcut\": { \"mac\": \"Cmd+Shift+P\", \"win\": \"Ctrl+Shift+P\" } Keyboard shortcuts are defined separately for each platform. Each definition is a string that follows this syntax: One or more modifier keys, in any order, each one followed by \"+\" Mac: modifiers may be Cmd, Ctrl, Opt / Alt, or Shift. Shortcut must contain at least one of Cmd or Ctrl. Win: modifiers may be Ctrl, Alt, or Shift. Shortcut must contain Ctrl. A letter or number key. Letters are case-insensitive (e.g. \"Cmd+P\" and \"Cmd+p\" mean the same thing and neither requires pressing Shift). Other keys (including punctuation, arrow keys, or F1-F12) are currently not supported. If your shortcut collides with a built-in XD command or another plugin's shortcut, your shortcut will be ignored and you'll see a warning printed to the developer console. Menu Localization Plugin menu item labels or panel labels can be localized to match XD's current UI language setting. Other manifest fields such as name and description cannot be localized yet. Localized labels are represented as an object containing multiple translations, instead of a single string value: \"label\": { \"default\": \"Menu Label\", \"fr\": \"Etiquette de Menu\", \"de\": \"Menübezeichnung\" } A default string is always required. The language must be a two-letter code from ISO 639-1, not a hyphenated code such as en-US. To avoid inconsistency with the rest of XD's built-in menu items, languages that aren't supported by XD are ignored. You can also localize strings that appear in your plugin's own dialog UI, by choosing which strings to use in your UI based on the value of application.appLanguage. "},"reference/structure/handlers.html":{"url":"reference/structure/handlers.html","title":"main.js","keywords":"","body":"The main.js file Every UI entry point you declare in manifest.json must be fulfilled by a definition exported from your main.js module. Exporting happens by setting the value of module.exports: module.exports = { commands: { // definitions for each commandId in manifest go here }, panels: { // definitions for each panelId in manifest go here }, }; The details of what you need to export are different depending on the type of UI entry point. One plugin may use multiple types of UI entry points. Direct-action commands (commandId) exports.commands is a map linking each commandId from the manifest to a JS handler function in your code. Manifest: \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"Hello World Command\", \"commandId\": \"helloCommand\" } ] main.js: function sayHello(selection, documentRoot) { console.log(\"Hello, world!\"); } module.exports = { commands: { helloCommand: sayHello } }; Notice how the exported map object makes the connection from manifest to code: The commandId from the manifest, helloCommand, is the key The handler function, sayHello, is the value that the key maps to The handler is called each time the command is invoked, and XD passes it two arguments providing useful context. Your handler function can show UI in a dialog box and/or edit the XD document. Panel UI (panelId) exports.panels is a map linking each panelId from the manifest to a JS panel object in your code. Manifest: \"uiEntryPoints\": [ { \"type\": \"panel\", \"label\": \"Hello World Panel\", \"panelId\": \"helloPanel\" } ] main.js: function show(event) { let dom = document.createElement(\"panel\"); dom.innerHTML = ` `; event.node.appendChild(dom); } function hide(event) { event.node.firstChild.remove(); } function update(selection, documentRoot) { // ...update panel DOM based on selection... } module.exports = { panels: { helloPanel: { show, hide, update } } }; Notice how the exported map object makes the connection from manifest to code: The panelId from the manifest, helloPanel, is the key An object with three methods (show(), hide(), and update()) is the value that the key maps to The panel object implements this interface: show() (required): called when your panel is made visible to the user. To populate the panel with UI elements, add DOM nodes to the event.node root node that is provided. hide() (optional): called when your panel is hidden/closed. update (optional): called whenever panel UI content should be updated. This includes when the panel is is shown, when the selection changes, or when the selected objects are mutated (move, resize, fill color change, etc.). This function should execute quickly since it's triggered for essentially every user action in XD while your panel is open. XD passes update() two arguments providing useful context. Typically, you'll attach UI event listeners to the DOM nodes in your panel, and these event listeners may edit the XD document using an application.editDocument() operation. Contextual arguments The handler function for commands (sayHello() above) and the update() function for panels are both called with two arguments that provide useful context about XD's current state: The current selection state The root node of the document's scenegraph The argument names selection and documentRoot seen in the code samples above are arbitrary, but you'll see this naming convention used throughout our documentation. Accessing app APIs XD calls into your plugin code via the above exports. To call into XD's APIs from your plugin code, see Accessing APIs. "},"reference/structure/menu-structure.html":{"url":"reference/structure/menu-structure.html","title":"Menu structure","keywords":"","body":"Plugin menu structure In your manifest.json, The uiEntryPoints field is an array of objects including all UI entry points your plugin has available. All entries listed in this array appear both in the Plugins menu in the native menubar and the \"plugin launchpad\" sidebar panel. Let's learn how these items appear in XD. Top level name No matter how many itmes you have in the uiEntryPoints array, XD will always use your plugin's name as the top level label for your plugin in the UI. For example, if you have \"PLUGIN NAME\" as your plugin name in your manifest.json file: \"name\": \"PLUGIN NAME\" XD will display this as the top menu item in the native menubar and in the \"plugin launchpad\": Submenu names So where do the labels you specify in uiEntryPoints show up in XD? For example, if you have a plugin with one modal-dialog command and one panel: \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"This is a modal\", \"commandId\": \"test\" }, { \"type\": \"panel\", \"label\": \"this is a panel\", \"panelId\": \"enlargeRectangle\" } ] You will see those labels shown as submenu items under the plugin's name: Single-item plugins If your plugin has only one item in the uiEntryPoints array, its label will be ignored. Instead of having a single submenu item nested under the plugin's name, XD will simply show the plugin's name itself as a directly actionable top-level menu item, which triggers the plugin's one entry point. For example: \"uiEntryPoints\": [ { \"type\": \"panel\", \"label\": \"this is a panel (IGNORED)\", \"panelId\": \"enlargeRectangle\" } ] Since there is only one item in the uiEntryPoints array, XD will ignore the label and display the plugin's name as the top menu item. This exception is applied to prevent user confusion and to promote the most ideal user experience. "},"reference/javascript/":{"url":"reference/javascript/","title":"JavaScript and XD plugin APIs","keywords":"","body":"JavaScript and XD Plugin APIs XD plugins are written in JavaScript, the language of the web which is also frequently used for servers, OS scripting, and more. If JavaScript is new to you, we recommend trying an introductory JavaScript tutorial elsewhere. You certainly don't need to know everything about JavaScript to build useful XD plugins; once you have a grasp on the basics of the language, you can learn as you create! If you're familiar with JavaScript, you'll find that many of your skills apply to creating XD plugins. There are some special rules of the road you'll want to know, and that's what this advanced concepts section is all about. In this section, we'll talk about JavaScript topics that are specific to XD plugin APIs. Topics include: JavaScript version and feature support Sync and Async The API environment "},"reference/javascript/javascript-support.html":{"url":"reference/javascript/javascript-support.html","title":"JavaScript support","keywords":"","body":"JavaScript version and feature support XD plugin APIs support \"modern JavaScript\"... but what does that mean exactly? This is the place to find out! Can I use ES5 features? Yes! This means you can use Array#map, Array#reduce, and numerous other language features introduced with ES5. In fact, you can write your whole plugin in ES5 if you so choose. What ES2015+ (ES6) features can I use? XD plugin APIs support most of ES2015 and beyond. You can use features such as: Template literals Classes Block-scoped variables ( let , const ) Object destructuring Default parameters Spread and Rest ( ... ) Arrow functions Asynchronous functions ( async / await ) Promises Can I use require? Yes, you can use require to import additional files. Note that require in XD does not follow Node.js-style resolution. You can only require files in your plugin directory relative to your file location, but not outside of your plugin directory. There is no lookup in a package.json or a node_modules directory. For example, the following works: const aFile = require(\"./aFile\"); const someJSON = require(\"./someJSON.json\"); const anotherFile = require(\"./path/to/file/file\"); const someLib = require(\"./node_modules/somelib\"); However, the following will not: const someLib = require(\"somelib\"); // no package.json lookup Can I use npm packages or Node.js APIs? XD's plugin sandbox does not include most Node.js APIs, such as unrestricted filesystem access or the ability to spawn external processes. Npm packages that only depend on the core JavaScript language APIs can work in XD, but because XD's require() differs (see above), you will likely have to use webpack or rollup in order to generate a single-file bundle first. "},"reference/javascript/sync-async.html":{"url":"reference/javascript/sync-async.html","title":"Sync and async","keywords":"","body":"Sync and Async XD plugin APIs support both synchronous and asynchronous code (commonly referred to as sync and async). Below, we'll talk a little about the difference, and what it means for your XD plugins. Note: \"Sync vs async\" is a topic frequently covered in JavaScript tutorials and articles around the web. For a broader introduction, consult your favorite search engine. Synchronous code When you write synchronous code, your code is executed line by line. Here's an example: const newElement = new Rectangle(); newElement.width = 100; newElement.height = 50; newElement.fill = new Color(\"Purple\"); Asynchronous code XD plugins also support asynchronous code with both Promises and async/await. Some XD plugin APIs are asynchronous in nature. You can also create your own Promises as you would in any JavaScript environment. Here's an example using the File API and Promise syntax: function sayHello(selection, documentRoot) { return fs.getFileForSaving().then(file => { return file.write(\"Hello, world!\"); }); } Here's that same example using async/await syntax: async function sayHello(selection, documentRoot) { let file = await fs.getFileForSaving(); file.write(\"Hello, world!\"); } We recommend async/await syntax over Promises. "},"reference/javascript/environment.html":{"url":"reference/javascript/environment.html","title":"API environment","keywords":"","body":"The API environment If you're used to writing JavaScript for web pages or Node.js servers, there are some things to know about the JavaScript environment when creating XD plugins. Not a browser and not Node.js While it may feel like it, the XD plugin API environment is not a browser, nor is it Node.js. This means that you shouldn't make assumptions about what APIs are available based on your experience in other JavaScript environments. However, we do follow standards for API surfaces where appropriate. For example, you'll find our implementation of XMLHttpRequest to work as you would expect. In some cases, we follow standards, but only support a subset of features you might expect in a browser. As an example, see our document on CSS support. Accessing global APIs Supported APIs that you would expect as window globals in other enviroments are also available as globals in XD. Examples include XMLHttpRequest , fetch, WebSocket , document, and more. Example: let req = new XMLHttpRequest(); APIs that are specific to XD are reachable via the require method. Examples include scenegraph, application, uxp, and more. Example: const { Text, Color } = require(\"scenegraph\"); "},"reference/core/":{"url":"reference/core/","title":"XD concepts","keywords":"","body":"XD concepts These important concepts are specific to plugins for XD: Plugin lifecycle Scenegraph Edit Context rules Properties with object values Coordinate spaces & units Automatic cleanups Accessing APIs "},"reference/core/lifecycle.html":{"url":"reference/core/lifecycle.html","title":"Plugin lifecycle","keywords":"","body":"Plugin lifecycle Here's an overview of how plugins are loaded, when plugin code runs, and how plugin \"edit operations\" work. Plugin loading Each XD document window loads a separate copy of your plugin's JavaScript code with a separate UXP UI document global (as if they were, say, separate browser windows). It's not yet possible for the JavaScript in one window to communicate with other windows, short of using a web server or other external channel. Each plugin is loaded into an isolated context with its own set of global variables. Different plugins cannot share objects or functions with each other. Your plugin's code remains resident until the document is closed (or until a developer runs the Reload Plugins command). This means you can store temporary \"session\" state in global or module-level variables. When plugins run Several different situations can cause code in your plugin to get executed: Initialization When loading, any \"top-level\" code in each module (JS file) is executed immediately. You can't edit the document or show UI at this point. Only perform tasks that are absolutely necessary for basic loading and initialization – defer as much as possible until later, when the user invokes your plugin for the first time. Direct-action menu commands Invocation – Each time one of your plugin's menu commands is invoked, XD calls your command handler function for the relevant commandId. Your command handler can edit the document or open a dialog box; if you return a Promise, these privileges extend until the Promise completes. See \"Edit operations\" for details. Dialog box DOM events – Since dialogs are typically open during an edit operation, this event handler code can edit the document too. Panel UI Panel lifecycle callbacks – XD invokes your plugin's panel callbacks when a panel is shown, hidden, or needs updating. These callbacks can update the UI only; you cannot edit the document. Panel UI DOM events – Most UI events in panels allow you to edit the document, but you must initiate an edit operation explicitly. Network responses and timers Other events can happen at any time, such as a network call finishing or a setTimeout() firing. If you've engineered an async edit operation's Promise to wait for these events before resolving, then these handlers can also edit the document. You can also run network requests and timers entirely in the background, outside of any edit operation, though this is discouraged. Plugin code running in the background can make XD slow. And although you'll have read-only access to the scenegraph, this is unsafe since your background code may run in the middle of some other asynchronous edit operation (whether from a built-in XD command, another plugin, etc.) – so your code might see an incorect intermediate state of the document. Edit operations An edit operation is the window of time in which your plugin is making a batch of related changes to the document. Roughly, one edit operation equals one Undo step. Your plugin can modify multiple properties on multiple scenegraph nodes during an edit operation, and they are all automatically batched together. Edit operations can only occur via user-initiated actions in your plugin: invoking a plugin menu command (and anything that stems from it, such as dialog boxes the command opens), or interacting with a plugin's panel UI. Edit operation duration An edit operation begins when: a) Your plugin's menu command handler is called (this is automatically wrapped in an edit operation) a) Your plugin's panel UI code explicitly calls application.editDocument() If the edit code returns synchronously, the edit operation is done as soon as it returns. If the edit code returns a Promise, the edit operation continues asynchronously until the Promise completes. The user can't do anything else in XD until the operation completes, so normally you'd only return a Promise if your plugin has a dialog box open that the user is interacting with or that is showing a progress indicator. If the edit throws an exception, or its Promise is rejected, the entire edit batch is atomically rolled back automatically by XD. Initiating an edit operation from panel UI Although menu commands automatically trigger an edit batch, panel UI events must opt into initiating one by specifically calling the application.editDocument() API. The function passed to editDocument() is treated just like a menu command handler at that point. You can only call editDocument() while handling a panel UI event which corresponds to an explicit user action (e.g. a \"click\" or \"input\" event). Consecutive edit operations triggered by the same UI and applying to the same selected nodes may get merged into a single Undo step by XD. See discussion of editDocument()'s mergeId option for details. Modal/exclusive UI While an edit operation is in progress, XD prevents any edits from other plugins or other features. The user can't interact with any XD UI other than dialogs shown by your plugin. Even if your plugin doesn't have a dialog box open during an async edit operation, the XD UI still remains frozen. If an edit operation continues for over 1 second without any UI being shown, XD shows a \"Plugin is working\" message which allows users to forcibly abort the edit operation. For this reason, during long-running async steps like network requests it's best to display your own nicer progress UI (users can always still cancel this too, by pressing Escape at any time). UI updates Just as in a web browser, XD won't update the UI in the middle of your plugin code's synchronous execution. As soon as there's an async gap in execution, any changes you've made to dialog box DOM or to the document scenegraph will be reflected in XD's UI. For example, if your plugin makes some partial edits to the scenegraph, then waits on a network request, then uses the results to make more edits – although the entire operation is atomic with respect to Undo, the user will see the partial edits displayed onscreen for a brief moment while your plugin code is idle waiting for the async network request to complete. "},"reference/core/scenegraph.html":{"url":"reference/core/scenegraph.html","title":"The scenegraph","keywords":"","body":"Scenegraph The XD document is represented as a hierarchical tree of nodes called the scenegraph. Some scenenodes may contain children (e.g. a Group or Artboard), while others are leaf nodes (e.g. a Rectangle or Text node). Typically, you access scenegraph nodes via the selection argument that is passed to your plugin command. You can modify properties on any scenenodes within the current edit context (see below), and you can add leaf nodes to the edit context, but you cannot make structural changes directly to the scenegraph tree - e.g. reordering nodes or changing nesting. To do this, instead use commands. "},"reference/core/edit-context.html":{"url":"reference/core/edit-context.html","title":"Edit Context rules","keywords":"","body":"Edit context rules The edit context is the scope within which your plugin is allowed to make edits or set the selection. It is a \"neighborhood\" of scenegraph nodes around the user's current selection. To access the contents of many container nodes such as RepeatGrids or SymbolInstances, the user must first drill down into the container by double clicking or Cmd-clicking it (Ctrl-clicking on Windows). Like nearly all commands in XD, your plugin is limited to making changes only within the scope of the current edit context. Note: these rules have changed in XD 17. If you intend to support XD 16 or earlier, follow the more restrictive edit context rules described in the previous version of these docs. The current edit context's scope is derived from the current selection: The \"edit context root\" is the node which is the closest common ancestor of all the selected nodes. It's typically indicated by a soft blue outline in the UI: As a special case, if the edit context root would be an Artboard, it is moved up to the root of the entire scenegraph instead. Nodes within this subtree are \"in scope\" for editing (or selection) if they are connected to the edit context root by a parent chain consisting entirely of plain Groups or Artboards. (A \"plain Group\" is a Group node with no mask). You can always safely assume that all selected nodes are in scope for editing. Examples Scenario 1: The user has selected two items inside a Group. The Group is the edit context root, and all its children are within scope for editing. In addition, if any of those children are nested Groups, their children are also in scope for editing (recursively, if any of those are Groups too). If any of the children are a different container type, however, the edit scope does not include that node's children: Scenario 2: The user has selected two items, each inside different Groups. The edit context root is Group 1, the closest common ancestor of the selected items. In this case, all nodes in the subtree of Group 1 are in scope for editing, but if this subtree contained any non-Group containers, their children would be off limits (as in the second example in Scenario 1). Scenario 3: The user has selected one item that is an immediate child of an Artboard. Per the special case noted above, the edit context root is the root of the entire document (the scenegraph's RootNode). This is true any time the user hasn't drilled into a particular container. The editable scope encompasses – at minumum – all Artboards, all other immediate children of the root node (aka the pasteboard), and all immediate children of all artboards (not just the one containing the selection). If any of those nodes is a plain Group, its children are also in scope for editing (recursively, if any of those are Groups too). What changes are allowed within the edit context? Simple changes can be made directly to the scenegraph nodes that are in scope: Change a property Delete a node Add a new leaf node (basic shape node) Structural changes cannot be made directly, since their impact extends to nodes outside the edit context's scope. You can make structural changes by scripting XD commands: Ungroup (or break apart other container types) - use the ungroup() command Create new Groups (add a whole tree of new nodes) - use the group() command Rearrange Z order - use commands such as bringToFront() If a plugin breaks any of these rules, its entire edit operation will be reverted to protect the user's document from corruption. Exceptions to these rules You can set pluginData on the root node of the scenegraph regardless of the current edit context, making it useful for storing plugin settings that are document-specific. The RepeatGrid APIs attachTextDataSeries() and attachImageDataSeries() can be called when either the RepeatGrid node or the target node being attached to is in the current edit context. "},"reference/core/properties-with-object-values.html":{"url":"reference/core/properties-with-object-values.html","title":"Properties with object values","keywords":"","body":"Properties with object values Some scenegraph properties have values that are not simple primitive types (e.g. numbers), but rather are objects with sub-properties of their own. In order to update the document with changes, you must invoke the top-level setter on the scenenode object itself – changing properties on the object value \"inline\" will not result in an update. For example: // Right: let color = node.fill; color.r = 0x80; node.fill = color; // update fill in the scenegraph by kicking the node's setter // Wrong - document will not update: node.color.r = 0x80; "},"reference/core/coordinate-spaces-and-units.html":{"url":"reference/core/coordinate-spaces-and-units.html","title":"Coordinate spaces & units","keywords":"","body":"Coordinate spaces & units Sizes and distances in XD are specified in DPI-independent pixels, equivalent to pixels on a 1x display. This is similar to the \"CSS pixels\" used in web design. Each layer of the scenegraph tree can apply a transform (rotation and/or translation), creating a hierarchy of nested coordinate spaces. Due to rotation, the X and Y axes of different coordinate spaces might point in different directions. Take the example of a rotated rectangle that is inside an artboard: The top-left corner of a node is not always located at (0,0) in its own local coordinate space. Use localBounds to get the true top-left of a node. For example, the baseline of a Point Text node is at Y=0 in its local coordinates, so its upper-left corner is at a negative Y value. Similarly, centered or right-aligned text will start at a negative X value in local coordinates. Here are some examples of nodes where the local origin is not the node's visual top-left corner: Typically, when discussing the bounds of a node we are referring to the bounds of its path outline – the hairline \"spine\" that its fill fits within and that the thickness of its stroke is anchored to. Nodes may have visible pixels that extend outside the path outline bounds. For example, a center or outside stroke protrudes beyond the path outline, as does the dropshadow and parts of the \"Object Blur\" effect: If you need a bounding box that encompasses all visible pixels of an object, use globalDrawBounds. The draw bounds are the bounds used when exporting a bitmap image, for example. However, in most other cases (including align/snapping), XD uses the path outline bounds. "},"reference/core/automatic-cleanups.html":{"url":"reference/core/automatic-cleanups.html","title":"Automatic cleanups","keywords":"","body":"Automatic cleanups To make writing your plugin simpler, XD performs a number of automated cleanups after each plugin command finishes: Artboard reparenting - If a node is changed to overlap an Artboard, it will automatically become a child of the artboard when the command finishes, and vice versa if a node no longer overlaps an Artboard. Selection - Deleted nodes are removed from the selection when the command finishes. Empty containers - If deleting node(s) has caused the parent container to become empty, it is automatically deleted as well after the command finishes. Component master->instance syncing - Most changes you make inside a Component master are automatically mirrored to all other copies of that Symbol, unless overridden by local changes in a particular instance. See Component / SymbolInstance docs for more details. Repeat Grid cell syncing - Most changes you make inside a Repeat Grid cell are automatically mirrored to all its other cells, except for certain properties such as text and images which XD permits to vary between grid cells. "},"reference/core/apis.html":{"url":"reference/core/apis.html","title":"Accessing APIs","keywords":"","body":"Available APIs Adobe XD provides several categories of APIs: APIs for interacting with XD itself, especially its document model, the scenegraph The UXP runtime, which provides all the capabilities that aren't XD-specific: A browser-like HTML and CSS engine which drives actual XD native UI components – it is not a complete browser engine, but lets you build your UI using familiar web APIs and frameworks. Network APIs similar to the web standard XHR, fetch, and WebSocket found in browsers. The storage API, offering sandboxed filesystem access. The usual core JavaScript language APIs you see in all JS runtimes, such as setTimeout() and Date. A simple module-loader require() API Read below for how to access XD and UXP APIs... XD-specific APIs Most XD APIs are accessed by loading a module via require(), but some are passed directly to your plugin's handler functions. selection - Indicates the selected nodes and related context This object is passed as an argument to your command handler function (see above) scenegraph - APIs available on document nodes Typically you use scenegraph objects by simply accessing the arguments passed to your command's handler function (selection and documentRoot). To create new nodes in the document, load this module explicitly to access the constructor functions:let Rectangle = require(\"scenegraph\").Rectangle; let node = new Rectangle(); commands - Invoke commands to change the document structure and perform other complex operations. let commands = require(\"commands\"); interactions - Data model for interactive prototyping features (also accessible from scenegraph nodes). let interactions = require(\"interactions\"); application - APIs for exporting content, initiating edits from panel UI, and getting version / locale info. let application = require(\"application\"); clipboard - Copy text to the clipboard. let clipboard = require(\"clipboard\"); UXP HTML DOM APIs – access just as in a browser, via the global document. Each plugin in XD gets its own document tree. Network APIs – access just as in a browser, via the global classes XMLHttpRequest and WebSocket , and the global function fetch() Storage APIs – access via const fs = require(\"uxp\").storage.localFileSystem; "},"devbestpractices/":{"url":"devbestpractices/","title":"Development best practices","keywords":"","body":"XD Plugin Development Best Practices XD Plugin Development Best Practices guide can be used to ensure that your plugin is functional in a variety of edge cases and provides a good experience to your end users. While it’s not a hard-and-fast requirement that you follow these best practices when submitting your plugin for review to the Plugin Manager, it is highly suggested that you try to follow the guidelines when and where it makes sense. Doing so ensures that your users have a good experience with both your plugin and Adobe XD itself. 1.0 Performance 2.0 Working with the Scenegraph 3.0 Network I/O 4.0 File I/O "},"devbestpractices/1-performance.html":{"url":"devbestpractices/1-performance.html","title":"1.0 Performance","keywords":"","body":"1.0 Performance One of Adobe XD's core tenants is performance. As such, your plugin should be as performant as possible, and should avoid introducing bottlenecks or impediments to your user's workflow. 1.1 Startup Adobe XD executes your plugin’s main JavaScript file whenever it is launched or a new document is opened or created. This is done to determine the various entry points and handlers your plugin provides. As part of this process, your plugin could conceivably perform other work at startup. You should avoid running arbitrary code at startup because this slows down loading all of the user’s plugins. (1.1.1) Test creating a blank document with your plugin installed. Ensure that creating a new document is as fast as it was when no plugins were installed. (1.1.2) If your plugin has a lot of code, parsing that code may take more than 10ms. Consider using a bundler to minify and split your code, using lazy loading as appropriate. You should also avoid displaying any user interface or launching an external URL during startup. (1.1.3) Never render a modal dialog during startup. (1.1.4) Never open a URL during startup. While performing I/O is a great way to load user preferences, ping a backend server, etc., this can cause delays during startup. Instead, handle your I/O tasks lazily — only performing the I/O when needed. For example, when loading user preferences, load them on the first invocation of your plugin, rather than at startup. (1.1.5) Avoid performing I/O at startup. 1.2 While Idle It is possible to execute your code asynchronously, and as such, you could schedule actions to occur in the future. It is important, then, not to throw up obstacles or impediments to the user's workflow unless they have explicitly initiated an action that results in such a behavior. (1.2.1) Never open a modal dialog when the user has not triggered a plugin action using a menu item or other method. (1.2.2) Never open a URL when the user has not triggered a plugin action using a menu item or other method. (1.2.3) Never put the user's machine into a hard loop while idle. This can waste battery life, slow down XD and other plugins, and cause other disturbances. 1.3 While Executing Your plugin should strive to perform its tasks as quickly as possible. What this means depends largely upon your plugin, but you should avoid blocking the user for a significant period of time without providing some means of cancellation. There are also two modes of execution: synchronous (blocking) and asynchronous. You should avoid running synchronous (blocking) code for more than any longer than necessary, since the user can't interact with your plugin or their document while your plugin is processing. (1.3.1) Avoid blocking the user for more than a couple seconds. (1.3.2) If your plugin needs several seconds to work, provide the user a way to cancel the operation. (1.3.3) If your plugin is going to take some time to complete, consider providing a progress indicator. "},"devbestpractices/2-scenegraph.html":{"url":"devbestpractices/2-scenegraph.html","title":"2.0 Scenegraph","keywords":"","body":"2.0 Interacting with the Scenegraph The scenegraph is a tree structure that represents the user’s document. You can use XD’s scenegraph module to manipulate the scenegraph. However, while doing so, there are some important guidelines to consider. 2.1 Don’t be destructive without permission Your plugin shouldn’t remove content from the scenegraph without the user’s permission. If an action is destructive, always ask for permission using a modal dialog first, and ensure that the button you use is a warning variant. (2.1.1) Ensure that your plugin is never destructive without permission (2.1.2) When using buttons that are destructive, always use the warning variant. 2.2 Handle selections (or lack thereof) properly Your plugin may be invoked in a variety of conditions. Your plugin should never fail silently — this gives the user the impression that they weren’t “heard” or “understood,” and will likely trigger the invocation again. The user may become confused as to why the plugin works in certain conditions and fails in others and blame your plugin, XD, or even blame the combination of installed plugins. (2.2.1) Your plugin should never fail silently if there is no active selection. Inform the user what the plugin expects via a modal dialog. (2.2.2) Your plugin should never fail silently if the active selection isn’t what your plugin expects. Inform the user what the plugin expects to be selected via a modal dialog. (2.2.3) Your plugin should be able to handle one or more selected items. How your plugin handles multiple items will depend upon what the plugin does. If it applies a style, for example, it should apply the same style to each selected item. (2.2.4) Your plugin should ignore selected items it can’t process. If that is representative of the entire selection, your plugin should tell the user that it found no items to process using a modal dialog. It’s also possible that your plugin can modify the user’s selection. (For example, commands.group). Your plugin should not do this unless it is something the user will expect. (2.2.5) Don’t modify the user’s selection unexpectedly. Finally, there may be cases where the selection changes between asynchronous execution phases in your plugin. You should ensure that you capture the initial selection separately and then compare the current selection before making changes. (2.2.6) Capture the initial user selection (selection.items.map(i => i)) (2.2.7) Compare the initial selection before doing any work after an asynchronous operation. If the selection differs from what you expect, fail and display a message like “Could not complete operation due to change of selection” to the user. (2.2.8) Never modify the document after an unexpected selection change. 2.3 Working with Artboards (or lack thereof) Your plugin should be able to handle the condition where there is no artboard, one artboard, or multiple artboards present in the document. (2.3.1) Your plugin should never fail silently if there is no artboard present. It can create an artboard if needed, or prompt the user to do so using a modal dialog. (2.3.2) Your plugin should never fail if there is an artboard present. (2.3.3) Your plugin should never fail if there are multiple artboards present. (2.3.4) Your plugin should never fail if there are multiple artboards selected. (2.3.5) When adding content to an artboard, the content should remain within the artboard’s bounds. Be sure to test in a document with only one artboard and in another document with two or more artboards. 2.4 Working with the Edit Context The edit context is the editable context within the scenegraph. Editing nodes outside the edit context will throw an exception. Your plugin should handle these exceptions if they occur. (2.4.1) Ensure your plugin never makes edits outside of the current edit context (2.4.2) If your plugin attempts to make edits outside of the current edit context, it must always handle the resulting error, and must never simply fail silently. (2.4.3) It is not suggested that you ungroup and regroup items in order to work around the edit context limitations. Doing so can lose various settings, including whether or not an item is marked for export and other metadata. This is a violation of guideline 2.0.1. 2.5 Handle gradients and other fills When working with shapes, it may be tempting to extract the color values without checking the type of fill. Doing so may cause your plugin to fail silently. What you do with non-solid colors is up to you, but your plugin shouldn't fail silently. (2.5.1) Handle shapes filled with bitmap data (2.5.2) Handle shapes filled with a linear gradient (2.5.3) Handle shapes filled with a radial gradient 2.9 Know when to use asynchronous logic If your plugin can execute quickly and has no need of I/O or UI, then you can modify the scenegraph synchronously. This is the easiest way to build a plugin. However, if your plugin takes a considerable amount of time to operate or uses any asynchronous API (and then needs to work with the scenegraph), you’ll need to use XD’s asynchronous scenegraph handling. (2.9.1) Synchronous plugins should execute quickly (less than 2s). If this is not possible, throw up a dialog indicating that the operation will take some time, and provide some indication of progress. (2.9.2) Modifying the scenegraph after any I/O or UI is displayed must always be asynchronous. (2.9.3) Your plugin should never fail with the error “Plugin id is not permitted to make changes from the background. Return a Promise to continue execution asynchronously.\" "},"devbestpractices/3-network-io.html":{"url":"devbestpractices/3-network-io.html","title":"3.0 Network I/O","keywords":"","body":"3.0 Network I/O Interacting with the network is a useful feature — you can communicate with remote or local servers to transmit data, images, and more. However, this can be an area with a lot of edge cases, error conditions, and more, so it is wise to be diligent with your logic. 3.1 Always use SSL/TLS when communicating with remote endpoints You should never transmit data in the clear. This means that your plugin should only ever target https:// or wss:// endpoints. (3.1.1) Your plugin must always use https or wss when communicating with remote endpoints. 3.2 Correctly handle online/offline and failure states If your plugin requires network access in order to function, you should be sure that your plugin works correctly if there is no route to your remote endpoint, or if the network is flaky or down for some reason. (3.2.1) Network requests must always have reasonable timeouts in case of network issues. (3.2.2) Your plugin should never assume that your host is available just because the network appears to be online. The user may be on a network without outside access. (3.2.3) If your plugin requires access to a remote host in order to function, the plugin should always notify the user upon invocation when there is no route present to the host rather than failing silently. (3.2.4) If a network request fails, your plugin should always attempt to recover gracefully (perhaps including retrying the attempt). If no recovery is possible, always inform the user instead of failing silently. 3.3 Handle long network requests If you expect that your plugin may make a network request that takes a considerable amount of time, don’t leave your user in doubt! Keep them up-to-date with your plugin’s progress, and provide a way to cancel the operation. (3.3.1) If a network request may take a considerable amount of time, display a progress UI. (3.3.2) Allow network requests to be cancellable. 3.9 Privacy Implications Sending the user’s data or analytics information to a remote endpoint has a whole host of privacy implications in today’s world, especially with the recent introduction of GDPR in Europe. (3.9.1) If your plugin sends data of any sort to a remote endpoint, your plugin should have a privacy statement. Where this is displayed is up to you (website, plugin’s “about” screen, etc.) (3.9.2) Plugin analytics should be configurable and opt-in. "},"devbestpractices/4-file-io.html":{"url":"devbestpractices/4-file-io.html","title":"4.0 File I/O","keywords":"","body":"4.0 File I/O In many cases, your plugin may need to create, read, and write files on the user’s persistent storage mediums. Your plugin should be respectful of the fact that it has access to a lot of potentially privileged information and should respect the user’s privacy. The plugin should also be mindful of not wasting a lot of space. 4.1 Handle I/O Exceptions There may well be cases when your File I/O attempt will fail. Your plugin should always handle the exceptions gracefully. (4.1.1) An exception encountered during a File I/O operation should never cause the plugin to fail silently. The plugin should attempt to recover if possible. If no recovery is possible, always inform the user via a modal dialog. (4.1.2) Don’t use “programmer-speak” when showing File I/O error messages. For example, if the user is out of disk space, give the user some options instead of throwing up a terse error message instead. For example, “You’re out of disk space. This plugin requires more disk space in order to complete its operation. Try removing temporary or unneeded files and then try again.” 4.2 Respect the user’s disk space (4.2.1) Don’t store unnecessary data in the plugin’s data folder. (4.2.2) Don’t expect data stored in the plugin’s temporary folder to persist for any considerable length of time. (4.2.3) Clean up after yourself — delete files stored in temporary or persistent storage when they are no longer needed. 4.3 Don’t store sensitive information on the user’s disk Although plugin’s can’t access other plugin data without the user first giving permission, the files that you store are themselves accessible to other applications running on your user’s machine. This means that if you were to save a user’s password to the file system, that password would now be accessible to any other application running on the machine. (4.3.1) Never store sensitive information (like passwords) to the user’s storage. (4.3.2) Request sensitive information each time it is needed (either from the user, or from a remote endpoint). (4.3.3) You can cache sensitive information in memory for the life of the current document. (4.3.4) Use time-limited, revokable tokens instead of passwords. 4.4 Never access user files without permission Although the File I/O API surface makes it difficult to access files outside of the plugin data folder and temporary folder without the user first providing some sort of permission using a file picker, it is incumbent upon your plugin to ensure that it doesn’t circumvent the user’s permissions to do so. (4.4.1) Always invoke a picker once per document session when accessing a user file (excludes temporary and plugin data). (4.4.2) Your plugin can cache access to a file for the lifetime of the document session. (4.4.3) Never ask for access to the root folder of the user’s storage volume. (4.4.4) Avoid asking for access to the user’s “Documents” folder (and other similar files.) (4.4.5) Never ask for permission to access files in another plugin’s folder. "},"tutorials/":{"url":"tutorials/","title":"Step-by-step Tutorials","keywords":"","body":"About the tutorials Do you like to learn by following step-by-step examples? If so, this is the section for you! Each of the tutorials contained within will teach you a specific skill related to the XD plugin APIs. With these tutorials, you can learn things like how to draw a line, how to make a network request, or how to display an image in your UI. To get the most out of the tutorials, follow along with them from top to bottom. If you get stuck while coding along, don't worry! We have code-complete sample repos on GitHub for each tutorial. Before you jump in, a quick note to save you some time: the tutorials will all assume you have completed our Quick Start tutorial. Make sure to do that before you jump in. Our tutorials are divided into these main areas: Working with content Working with I/O Building user interface Chances are there's something in each section that will be relevant to the XD plugin you're creating! "},"tutorials/content-index.html":{"url":"tutorials/content-index.html","title":"Working with content","keywords":"","body":"Working with content A fundamental use case for XD plugins is working with content. Whether you want to add lines or other shapes to an artboard, work with text and text styles, or move existing objects around a document, using XD plugin APIs to work with content will enable your plugin to compliment the user's design workflow with great speed and accuracy. The tutorials contained in this section will show you a few ways XD plugins can work with content: How to draw lines How to work with paths How to style text Working with a SceneNodeList "},"tutorials/how-to-draw-lines/":{"url":"tutorials/how-to-draw-lines/","title":"How to draw lines","keywords":"","body":"How to draw lines This sample demonstrates how to create a plugin that adds colored lines to the user's document. Prerequisites Basic knowledge of HTML, CSS, and JavaScript Quick Start Tutorial Debugging Tutorial Development Steps Complete code for this plugin can be found on GitHub. 1. Prepare your plugin scaffold First, edit the manifest file for the plugin you created in our Quick Start Tutorial. Replace the uiEntryPoints field of the manifest with the following: \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"Create lines\", \"commandId\": \"createLinesCommand\" } ] If you're curious about what each entry means, see the manifest documentation, where you can also learn about all manifest requirements for a plugin to be published in the XD Plugin Manager. Then, update your main.js file, mapping the manifest's commandId to a handler function. Replace the content of your main.js file with the following code: function createLinesCommand(selection) { // The body of this function is added later } module.exports = { commands: { createLinesCommand } }; The remaining steps in this tutorial describe additional edits to the main.js file. 2. Require in XD API dependencies For this tutorial, we just need access to two XD scenegraph classes and one XD module. Add the following lines to the top of your main.js file: // Add this to the top of your main.js file const { Line, Color } = require(\"scenegraph\"); const commands = require(\"commands\"); Now the Line and Color classes and commands module are required in and ready to be used. 3. Create a helper function Our plugin is going to assigning random colors to the lines we create! Add the lines of code below to your file: function randomColor() { const hexValues = ['00', '33', '66', '99', 'CC', 'FF']; const color = \"#\" + Array.from({ length: 3 }, _ => hexValues[Math.floor(Math.random() * hexValues.length)]).join(\"\"); return color; } This function returns a web-friendly color hex value (e.g., `\"#FFFFFF\"). This is just straight-up JavaScript; there's nothing specific to XD plugin APIs to cover here. 4. Create line data In this step, we're going to add a little more plain-old JavaScript. This time we'll add a data structure that will set us up to draw lines with the XD plugin API in the next step. Add this code to your file: const lineData = [ { startX: 100, startY: 110, endX: 210, endY: 233 }, { startX: 210, startY: 233, endX: 320, endY: 156 }, { startX: 320, startY: 156, endX: 400, endY: 300 }, { startX: 400, startY: 300, endX: 500, endY: 120 } ] A couple of things to note: In this example, the each line's startX and startY matches the former line's endX and endY. This ensures lines are connected to each other. But they don't have to connect; feel free to modifiy the data as you wish! The data structure here is important to note: lineData is an array. This gives us a way to store coordinates for multiple lines. We'll loop over this array in the next step. The array contains multiple objects that will be passed, one at a time, to the Line API. Since we're drawing lines, each object has a start and end coordinates for X and Y. 5. Create the main function In this step, we'll build out the main function, createLinesCommand, that we added in the first step. Each of the numbered comments are explained below the code: function createLinesCommand(selection) { // [1] let lines = []; // [2] lineData.forEach(data => { // [3] const line = new Line(); // [4.i] line.setStartEnd( // [4.ii] data.startX, data.startY, data.endX, data.endY ); line.strokeEnabled = true; // [4.iii] line.stroke = new Color(randomColor()); // [4.iv] line.strokeWidth = 3; // [4.v] lines.push(line); // [4.vi] selection.editContext.addChild(line) // [4.vii] }); selection.items = lines; // [5] commands.group(); // [6] } This function only needs the first contextual argument, selection, which gives access to the selection object inside XD. Create an empty array to contain all the Line objects we'll create. This array will be used in a later step. Loop over the lineData array, getting an individual data object each time through the loop. For each data object: Create a new instance of Line. Use the Line object's setter, .setStartEnd, to set the line data from our data object. Set the strokeEnabled property to true in order to draw a stroke for the line. Set the stroke color using the randomColor helper function. Set the width of the stroke using strokeWidth property. Append the line object into the lines array. Insert the line into the edit context using the selection.editContext.addChild method. This step adds the line to the document's scenegraph. Now that all of the Line objects have been added to the scenegraph, set the document's current selection to be those Line objects. Use the group command to combine all of the currently-selected objects (the Line objects) into a single group object. 6. Run the plugin After saving all of your changes, reload the plugin in XD and run it. The result should be similar to the following: Next Steps Want to expand on what you learned here? Have a look at these references to see options for customizing this sample plugin: Line Color Commands Ready to explore further? Take a look at our other resources: Tutorials Sample code repos "},"tutorials/how-to-create-paths/":{"url":"tutorials/how-to-create-paths/","title":"How to create paths","keywords":"","body":"How to create paths This sample demonstrates how to create path objects in XD. The path objects are used to construct a pie chart. Prerequisites Basic knowledge of HTML, CSS, and JavaScript Basic knowledge of Paths Quick Start Tutorial Debugging Tutorial Development Steps Complete code for this plugin can be found on GitHub. 1. Create plugin scaffold First, edit the manifest file for the plugin you created in our Quick Start Tutorial. Replace the uiEntryPoints field of the manifest with the following: \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"Create Pie Chart\", \"commandId\": \"createPieChartCommand\" } ] If you're curious about what each entry means, see the manifest documentation, where you can also learn about all manifest requirements for a plugin to be published in the XD Plugin Manager. Then, update your main.js file, mapping the manifest's commandId to a handler function. Replace the content of your main.js file with the following code: function createPieChartCommand(selection) { // The body of this function is added later } module.exports = { commands: { createPieChartCommand } }; The remaining steps in this tutorial describe additional edits to the main.js file. 2. Require in XD API dependencies For this tutorial, we just need access to two XD scenegraph classes. Add the following lines to the top of your main.js file: // Add this to the top of your main.js file const { Path, Color } = require(\"scenegraph\"); Now the Path and Color classes are required in and ready to be used. 3. Create helper functions Calculate a point on a circle Since our plugin will create a pie chart, this helper function will be used to return an x,y coordinates of each wedge in the pie chart. The function accepts radius and angle as parameters and use them to calculate the coordinates of a point on a circle at a given angle on the perimeter of the circle. Add the lines of code below to your file: function pointOnCircle(radius, angle) { const radians = angle * 2. * Math.PI / 360.; const xcoord = radius * Math.cos(radians); const ycoord = radius * Math.sin(radians); return xcoord + \",\" + ycoord; } This is just straight-up JavaScript; there's nothing specific to XD plugin APIs to cover here. We won't cover the math in depth, here's an overview what this helper function does: The angle is expressed in degrees. It must be converted to radians before passing it to the sine and cosine functions. More info: Math.cos, Math.sin The function will return the coordinates as a string in the x,y format, which will be used to be inserted to the path data, which also has to be a string Add a single pie wedge to the scenegraph Our plugin will also need to be able to add a single pie wedge to the scenegraph. Add the lines of code below to your file. Each of the numbered comments are explained below the code: function createWedge(selection, radius, startAngle, endAngle, color) { // [1] const startPt = pointOnCircle(radius, startAngle); const endPt = pointOnCircle(radius, endAngle); const pathData = `M0,0 L${startPt} A${radius},${radius},0,0,1,${endPt} L0,0`; // [2] const wedge = new Path(); // [3] wedge.pathData = pathData; // [4] wedge.fill = new Color(color); // [5] wedge.translation = {x: radius, y: radius}; // [6] selection.insertionParent.addChild(wedge); // [7] } This function accepts five arguments: The current selection in the scene graph (selection) The pie chart radius (chartRadius) The start radian of the wedge (startAngle) The end radian of the wedge (endAngle) The color of the wedge (color) Based on these arguments, pathData is constructed. The pen is moved to the origin, a line is drawn to the first point on the edge of the circle, an arc is drawn to the second point on the edge of the circle, and then a line is drawn back to the origin. For more information on how to create path data, please refer to Paths Create a new instance of Path Set pathData Set the color of the path object Move the path object down and to the right by radius units. As a result, the pie chart will appear with its top left corner positioned at 0,0 Insert the path object into the currently-selected artboard 4. Create the main function In this step, we'll build out the main function, createLinesHandlerFunction, that we added in the first step. This function creates four wedges: function createPieChartCommand(selection) { createWedge(selection, 100, 0, 90, \"red\"); createWedge(selection, 100, 90, 135, \"blue\"); createWedge(selection, 100, 135, 225, \"yellow\"); createWedge(selection, 100, 225, 360, \"purple\"); } Note that the end angle of each wedge matches the start angle of the next wedge. As a result, the wedges fit together to create a complete pie chart! 5. Run the plugin Ater saving all your changes, reload the plugin in XD and run it. The result should be similar to the following: Next Steps Want to expand on what you learned here? Have a look at these references to see options for customizing this sample plugin: Path Color Commands Ready to explore further? Take a look at our other resources: Tutorials Sample code repos "},"tutorials/how-to-style-text/":{"url":"tutorials/how-to-style-text/","title":"How to style text","keywords":"","body":"How to style text Creating styled text in Adobe XD is easy! In this tutorial, we'll show you how to create a text element with a specific color and font size, and also a text element with multiple inline colors. Prerequisites Basic knowledge of HTML, CSS, and JavaScript Quick Start Tutorial Debugging Tutorial Development Steps Complete code for this plugin can be found on GitHub. 1. Prepare your plugin scaffold First, edit the manifest file for the plugin you created in our Quick Start Tutorial. Replace the uiEntryPoints field of the manifest with the following: \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"Create Styled Text\", \"commandId\": \"createStyledTextCommand\" } ] If you're curious about what each entry means, see the manifest documentation, where you can also learn about all manifest requirements for a plugin to be published in the XD Plugin Manager. Then, update your main.js file, mapping the manifest's commandId to a handler function. Replace the content of your main.js file with the following code: function createStyledTextHandlerFunction(selection) { // The body of this function is added later } module.exports = { commands: { \"createStyledTextCommand\": createStyledTextHandlerFunction } }; The remaining steps in this tutorial describe additional edits to the main.js file. 2. Require in XD API dependencies For this tutorial, we just need access to two XD scenegraph classes. Add the following lines to the top of your main.js file: // Add this to the top of your main.js file const { Text, Color } = require(\"scenegraph\"); Now the Text and Color classes are required in and ready to be used. 3. Create the main function In this step, we'll build out the main function, createStyledTextHandlerFunction, that we added in the first step. This function will add red text to the user's doucment. Each of the numbered comments are explained below the code: function createStyledTextHandlerFunction(selection) { const node = new Text(); // [1] node.text = \"This is some red text\"; // [2] node.fill = new Color(\"#FF0000\"); // [3] node.fontSize = 24; selection.insertionParent.addChild(node); // [4] node.moveInParentCoordinates(20, 50); // [5] } Create the Text object. Populate text with a string. Set the color to red and the font size to 24 for the entire string. Add text to the scenegraph as a child of the currrently-selected artboard. Move text to a different position relative to the artboard's coordinate system. Character styles such as color and font size can also vary within the text. Read more below for details. 4. Test the plugin If you reload the plugin and run it, you should see the following result: Not bad for a few lines of code! Let's push it a little further. 5. Update the main function All red is ok, but we can make our text more colorful than that. Let's change the code to apply different styles to different parts of the text, resulting in rainbow-colored text. The styleRanges property lets us apply different styles to different ranges of the node's text: function createStyledTextHandlerFunction(selection) { const node = new Text(); const textData = [ // [1] {text: \"This \", color: \"red\"}, {text: \"is \", color: \"orange\"}, {text: \"some \", color: \"yellow\"}, {text: \"ra\", color: \"green\"}, {text: \"in\", color: \"blue\"}, {text: \"bow \", color: \"indigo\"}, {text: \"text\", color: \"violet\"} ]; node.text = textData.map(item => item.text).join(\"\"); // [2] node.styleRanges = textData.map(item => ({ // [3] length: item.text.length, fill: new Color(item.color) })); node.fontSize = 24; // [4] selection.insertionParent.addChild(node); node.moveInParentCoordinates(20, 50); } Here's what's changed: This data structure stores the text to be displayed, as well as the color to use for each fragment of text. Just as before, we set node.text equal to the text to be displayed. This time, the text string is created by concatenating together all the .text property values contained in the textData array. The Array#map gets us an array of strings, which we combine into a single string with Array#join. In this step, we build an array of style objects, applying each style to a few characters of the text string. We use Array#map again, this time converting each item in the textData array into a style object. The length of each style is equal to the length of the text string contained in one element of the textData array. The fill of each style uses the color value contained in one element of the textData array. We can still apply styles to the entire text node at once, as in the earlier example. Here, the font size will be set to the same value across all the style ranges we just created. The Color constructor understands some color names, but you have plenty of other options for defining colors precisely, including hex, rgba, and more. See the Color reference for more information. Here are a few things to notice about the styleRanges property of Text objects: styleRanges is an array of objects; you can have more than one style for a text node. Each range is given a length which determines the number of characters to which the style is applied, starting from the end of the previous style range. Character styles such as fill or fontSize can be set to different values in each style range, or they can be set on the Text node overall to apply the setting to all existing style ranges. 6. Run the plugin After saving all of your changes, reload the plugin in XD and run it. You'll now have rainbow-colored text: Next Steps Want to expand on what you learned here? Have a look at these references to see options for customizing this sample plugin: Text Color Ready to explore further? Take a look at our other resources: Tutorials Sample code repos "},"tutorials/how-to-work-with-scenenodelist/":{"url":"tutorials/how-to-work-with-scenenodelist/","title":"Working with a SceneNodeList","keywords":"","body":"How to work with a SceneNodeList This sample demonstrates how to work with a SceneNodeList in Adobe XD. The short version of this story is that a SceneNodeList is not an Array. Read on for details. Prerequisites Basic knowledge of HTML, CSS, and JavaScript. Quick Start Tutorial Debugging Tutorial Development Steps Complete code for this plugin can be found on GitHub. 1. Prepare your plugin scaffold First, edit the manifest file for the plugin you created in our Quick Start Tutorial. Replace the uiEntryPoints field of the manifest with the following: \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"Create Elements\", \"commandId\": \"createElements\" }, { \"type\": \"menu\", \"label\": \"Filter and Color\", \"commandId\": \"filterAndColor\" } ] If you're curious about what each entry means, see the manifest documentation, where you can also learn about all manifest requirements for a plugin to be published in the XD Plugin Manager. Then, update your main.js file, mapping both of the manifest's commandId to their respective handler functions. Replace the content of your main.js file with the code below. function createElements(selection) { // The body of this function is added later } function filterAndColor(selection, documentRoot) { // The body of this function is added later } module.exports = { commands: { createElements, filterAndColor } }; Note the different use of contextual arguments in each function: the first function only makes use of selection, which the second makes use of both selection and documentRoot. We'll look at why documentRoot is used in a later step. The remaining steps in this tutorial describe additional edits to the main.js file. 2. Require in XD API dependencies For this tutorial, we just need access to two XD scenegraph classes and one XD module. Add the following lines to the top of your main.js file: // Add this to the top of your main.js file const { Artboard, Rectangle, Ellipse, Text, Color } = require(\"scenegraph\"); Now the Artboard, Rectangle, Ellipse, Text, and Color classes are required in and ready to be used. 3. Create the handler function for createElements This function will do what it says on the label: create elements in the XD document. It's just here for the purpose of generating elements that will help us learn about the SceneNodeList in the next section. Because of that, we won't go into detail about the createElements function. In short, it will create a number of rectangles, ellipses, and text elements, and put them on your XD artboard. function createElements(selection) { for (let i = 0; i We'll run the command for this function in a later step. 4. Create the handler function for filterAndColor So let's take a look at working with a SceneNodeList! The function we create in this step will filter all content on the artboard for rectangles, and then color only the rectangles red. Recall that in the first step, we made a note of contextual arguments in command handlers, and particularly that this filterAndColor function makes use of the second documentRoot argument. Like any SceneNode, documentRoot has a .children property that returns a SceneNodeList. A SceneNodeList is not an Array. One notable difference is that, with a SceneNodeList, you access elements in the list using the #at method (for example, node.children.at(0) to get the first node in the list). You can learn more about the SceneNodeList class here. Let's fill out our handler function. Each of the numbered comments are explained below the code: function filterAndColor(selection, documentRoot) { documentRoot.children.forEach(node => { // [1] if (node instanceof Artboard) { // [2] let artboard = node; let rectangles = artboard.children.filter(artboardChild => { // [3] return artboardChild instanceof Rectangle; }) rectangles.forEach(rectangle => { // [4] rectangle.fill = new Color(\"red\"); }) } }) } Start from the documentRoot node and traverse down the tree using the .children property. Since .children is a SceneNodeList, it has a #forEach method that will let us iterate through the list, node by node. Since we started at the documentRoot level, the first thing we need to do is look for the artboards in the document. This line ensures that we only traverse down further if the current child node is an artboard. Once we've found an artboard, we look at its .children property, which is also a SceneNodeList. This SceneNodeList will contain all of the elements we created earlier. We use theSceneNodeList#filtermethod to filter the artboard's children down to arectangles` array. Finally, we iteracte over the rectangles array with #forEach, coloring each rectangle red as we go. 5. Run the plugin After saving all your changes, reload the plugin in XD. First, select an artboard and run the \"Create Elements\" command. You plugin will pull shapes on the artboard. Then, run the \"Filter and Color\" command: You've worked with a SceneNodeList to iterate through an artboard's contents and filter based on element type! Next Steps Want to expand on what you learned here? Have a look at these references to see options for customizing this sample plugin: SceneNodeList SceneNode Artboard Rectangle Ellipse Text Color Ready to explore further? Take a look at our other resources: Tutorials Sample code repos "},"tutorials/io-index.html":{"url":"tutorials/io-index.html","title":"Working with I/O","keywords":"","body":"Working with I/O If you want your plugin to go beyond the document to work with local files or web services, you'll want to learn about our file I/O and network I/O APIs. These tutorials will help you connect your XD plugin with the wider world: import from and export to the local machine, integrate with OAuth, or make network requests. The tutorials contained in this section will show you a few ways XD plugins can work with file and network I/O: How to export a rendition How to read a file How to integrate with OAuth How to make a simple network request "},"tutorials/how-to-export-a-rendition/":{"url":"tutorials/how-to-export-a-rendition/","title":"How to export a rendition","keywords":"","body":"How to export a rendition This sample describes how an XD plugin can invoke the default folder picker and generate a rendition of the selected artboard for export. Prerequisites Basic knowledge of HTML, CSS, and JavaScript. Quick Start Tutorial Debugging Tutorial Development Steps Complete code for this plugin can be found on GitHub. 1. Prepare your plugin scaffold First, edit the manifest file for the plugin you created in our Quick Start Tutorial. Replace the uiEntryPoints field of the manifest with the following: \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"Export Rendition\", \"commandId\": \"exportRendition\" } ] If you're curious about what each entry means, see the manifest documentation, where you can also learn about all manifest requirements for a plugin to be published in the XD Plugin Manager. Then, update your main.js file, mapping the manifest's commandId to a handler function. Replace the content of your main.js file with the following code: async function exportRendition(selection) { if (selection.items.length > 0) { // The body of this function is added later } } module.exports = { commands: { exportRendition } }; A couple of notes about the handler function shell above: This function will run asynchronously, as indicated by the async keyword at the beginning of the line. To learn more about what this means, see our document on sync and async support. Since this plugin will require user to select an object, we use an if statement to check if there is an XD object selected. The remaining steps in this tutorial describe additional edits to the main.js file. 2. Require in XD API dependencies For this tutorial, we just need access to one XD module and one UXP class. Add the following lines to the top of your main.js file: // Add this to the top of your main.js file const application = require(\"application\"); const fs = require(\"uxp\").storage.localFileSystem; Now the application module and localFileSystem class are required in and ready to be used. These modules are required to invoke the folder picker and export renditions. 3. Invoke the folder picker Here, we'll use uxp.storage.localFileSystem (our fs constant) to invoke the folder picker: const folder = await fs.getFolder(); const file = await folder.createFile(\"rendition.png\"); This will invoke the default folder picker for user to choose the save directory and create a file named rendition.png. 4. Define your rendition settings Next, we'll define the settings for our desired renditions. Note the data structure in the code below: an array of objects (in this case, one object). Each of the numbered comments are explained below the code: let renditionSettings = [{ node: selection.items[0], // [1] outputFile: file, // [2] type: application.RenditionType.PNG, // [3] scale: 2 // [4] }]; selection.items[0] refers to the first user-selected item in the document Set the outputFile property to the file constant we created in step #3 Set the type property to application.RenditionType.PNG Set the desired scale of the exported rendition We'll use this data structure containing our settings in the next step. 5. Create renditions This is where we attempt to create the renditions: application.createRenditions(renditionSettings) // [1] .then(results => { // [2] console.log(`PNG rendition has been saved at ${results[0].outputFile.nativePath}`); }) .catch(error => { // [3] console.log(error); }); The application#createRenditions method accepts as an argument the renditionSettings data structure that we created in step #4. createRenditions returns a Promise. We log success to the developer console. Any errors will land in .catch, which we also log to the developer console. 6. Run the plugin After saving all of your changes, reload the plugin in XD. Make sure to select an artboard and run the plugin command. You should see a folder picker like this one: The rendition will be saved at the specified location. Open the developer console to see your success or error message from the previous step. Next Steps Want to expand on what you learned here? Have a look at these references to see options for customizing this sample plugin: File I/O Export Renditions Ready to explore further? Take a look at our other resources: Tutorials Sample code repos "},"tutorials/how-to-read-a-file/":{"url":"tutorials/how-to-read-a-file/","title":"How to read a file","keywords":"","body":"How to read a file This tutorial will show you how an XD plugin can read in a file from the file system. As one of example of what you can do with a file, we'll extract text from the file and add that text to the scenegraph. Prerequisites Basic knowledge of HTML, CSS, and JavaScript. Quick Start Tutorial Debugging Tutorial Development Steps Complete code for this plugin can be found on GitHub. 1. Prepare your plugin scaffold First, edit the manifest file for the plugin you created in our Quick Start Tutorial. Replace the uiEntryPoints field of the manifest with the following: \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"Insert Text From File\", \"commandId\": \"insertTextFromFileCommand\" } ] If you're curious about what each entry means, see the manifest documentation, where you can also learn about all manifest requirements for a plugin to be published in the XD Plugin Manager. Then, update your main.js file, mapping the manifest's commandId to a handler function. Replace the content of your main.js file with the following code (note the presence of the async keyword, which we'll look at in a later step): async function insertTextFromFileHandler(selection) { // The body of this function is added later } module.exports = { commands: { \"insertTextFromFileCommand\": insertTextFromFileHandler } }; The remaining steps in this tutorial describe additional edits to the main.js file. 2. Require in XD API dependencies For this tutorial, we need access to two XD scenegraph dependencies and one UXP dependency. Add the following lines to the top of your main.js file: // Add this to the top of your main.js file const { Text, Color } = require(\"scenegraph\"); const fs = require(\"uxp\").storage.localFileSystem; Now the Text and Color classes are required in and ready to be used, as well as UXP's local file system provider. 3. Create a handler function Our plugin will allow the user to pick a file from the system file picker, read that file's contents, and add the contents to a text object on the scenegraph. Each of the numbered comments are explained below the code: async function insertTextFromFileHandler(selection) { // [1] const aFile = await fs.getFileForOpening({ types: [\"txt\"] }); // [2] if (!aFile) return; // [3] const contents = await aFile.read(); // [4] const text = new Text(); // [5] text.text = contents; text.styleRanges = [{ length: contents.length, fill: new Color(\"#0000ff\"), fontSize: 12 }]; selection.insertionParent.addChild(text); // [6] text.moveInParentCoordinates(10, 30); } This example uses XD's asynchronous Filo I/O APIs, so the handler function must be declared as an async method. To learn more about async support in XD plugin APIs, see our document on sync and async support. A file picker dialog is displayed, and the function waits for the user to select a text file. The selected file is assigned to aFile. The #getFileForOpening method is asynchronous, so the await keyword is used. If aFile is undefined (because the user did not select a file), then plugin exits. The contents of the file is read in, and returned as a string. See below for more detail. The #read method is asynchronous, so the await keyword is used. The contents of the string is added to a Text object. For details on Text properties, see the \"How to style text\" tutorial. The text object is added to and positioned on the selected artboard. 4. Run the plugin After saving all of your changes, reload the plugin in XD and run it. First you'll see a file picker: If you select a file containing text, the text should be added to the currently-selected artboard: Next Steps Want to expand on what you learned here? Have a look at these references to see options for customizing this sample plugin: File I/O Text Ready to explore further? Take a look at our other resources: Tutorials Sample code repos "},"tutorials/how-to-make-network-requests/":{"url":"tutorials/how-to-make-network-requests/","title":"How to make network requests","keywords":"","body":"How to make network requests This sample app will show you how to load an image in an XD object (Rectangle or Artboard) by making network requests using XHR and fetch. Prerequisites Basic knowledge of HTML, CSS, and JavaScript Basic knowledge of XMLHttpRequest and fetch Quick Start Tutorial Debugging Tutorial Development Steps Complete code for this plugin can be found on GitHub. 1. Create plugin scaffold First, edit the manifest file for the plugin you created in our Quick Start Tutorial. Replace the uiEntryPoints field of the manifest with the following: \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"How to make network requests\", \"commandId\": \"applyImage\" } ] If you're curious about what each entry means, see the manifest documentation, where you can also learn about all manifest requirements for a plugin to be published in the XD Plugin Manager. Then, update your main.js file, mapping the manifest's commandId to a handler function. Replace the content of your main.js file with the following code: function applyImage(selection) { // The body of this function is added later } module.exports = { commands: { applyImage } }; The remaining steps in this tutorial describe additional edits to the main.js file. 2. Require in XD API dependencies For this tutorial, we just need access to one XD scenegraph class. Add the following lines to the top of your main.js file: // Add this to the top of your main.js file const { ImageFill } = require(\"scenegraph\"); Now the ImageFill class is imported and ready to be used. 3. Write a helper function to make XHR requests Our XHR helper xhrBinary will make an HTTP GET request to any URL it is passed, and a return a Promise with an arraybuffer. function xhrBinary(url) { // [1] return new Promise((resolve, reject) => { // [2] const req = new XMLHttpRequest(); // [3] req.onload = () => { if (req.status === 200) { try { const arr = new Uint8Array(req.response); // [4] resolve(arr); // [5] } catch (err) { reject(`Couldnt parse response. ${err.message}, ${req.response}`); } } else { reject(`Request had an error: ${req.status}`); } } req.onerror = reject; req.onabort = reject; req.open('GET', url, true); req.responseType = \"arraybuffer\"; // [6] req.send(); }); } xhrBinary function takes a url as a parameter The function returns a Promise The function uses XMLHttpRequest to make network requests Once the correct response comes back, the function uses Unit8Array method to convert the response to an arraybuffer After the conversion, the promise is resolved Make sure the set the responseType as arraybuffer 4. Write a helper to apply ImageFill This helper function will create an ImageFill instance that can be applied to a user-selected XD scengraph object: function applyImagefill(selection, file) { // [1] const imageFill = new ImageFill(file); // [2] selection.items[0].fill = imageFill; // [3] } The function accepts the selection and a file as parameters Use the ImageFill class to create the fill Apply the image to the user-selected XD object We'll use this function in the next step. 5. Write a helper function to download the image Ok, you've just made three helper functions. Now we're going to tie them all together! Note the use of the async keyword at the beginning of the function. async function downloadImage(selection, jsonResponse) { // [1] try { const photoUrl = jsonResponse.message; // [2] const photoObj = await xhrBinary(photoUrl); // [3] const tempFolder = await fs.getTemporaryFolder(); // [4] const tempFile = await tempFolder.createFile(\"tmp\", { overwrite: true }); // [5] await tempFile.write(photoObj, { format: uxp.formats.binary }); // [6] applyImagefill(selection, tempFile); // [7] } catch (err) { console.log(\"error\") console.log(err.message); } } This helper function accepts the selection and a JSON response object as parameters Gets the URL from the JSON response Uses our async xhrBinary function to get an arraybuffer Uses the fs module and its getTemporaryFolder method to create a temp folder Uses the createFile method to create a temp file Uses the write method to write the binary file to store Uses applyImagefill to place the image into a user-selected XD object 6. Write the main handler function This is the function that will be called with the user runs our plugin command. function applyImage(selection) { if (selection.items.length) { // [1] const url = \"https://dog.ceo/api/breeds/image/random\"; // [2] return fetch(url) // [3] .then(function (response) { return response.json(); // [4] }) .then(function (jsonResponse) { return downloadImage(selection, jsonResponse); // [5] }); } else { console.log(\"Please select a shape to apply the downloaded image.\"); } } Checks if user has selected at least one object This is an example public URL to an image Pass the URL to fetch The first .then block returns the response JSON object The second .then block passes the selection and our JSON reponse to our downloadImage function, ultimately placing it in the document Next Steps Want to expand on what you learned here? Have a look at these references to see options for customizing this sample plugin: Network I/O XMLHttpRequest fetch Ready to explore further? Take a look at our other resources: Tutorials Sample code repos "},"tutorials/how-to-integrate-with-OAuth/":{"url":"tutorials/how-to-integrate-with-OAuth/","title":"How to integrate with OAuth","keywords":"","body":"How to Integrate with OAuth This tutorial will show you how to implement the OAuth workflow in an XD plugin, using the Dropbox API as an example. Auth workflows are necessarily complex, so this tutorial will be on the longer side and make use of some advanced concepts. Please read the each section carefully, especially the Prerequisites and Configuration sections. Prerequisites Basic knowledge of HTML, CSS, and JavaScript. Quick Start Tutorial Debugging Tutorial Familiarity with your OS's command line application Familiarity with OAuth A registered app on Dropbox with the following settings: Choose \"Dropbox API\" Choose \"Full Dropbox\" for the access type In Redirect URIs, add your own https ngrok URL (example: \"https://476322de.ngrok.io/callback\") or a secure public URL if you have one Technology Used [Install required] Node.js and the npm package manager OAuth ngrok Dropbox API Overview of the OAuth workflow There are three parts of this workflow: Your XD plugin Your server endpoints (for this development example, we'll create a local Node.js server) The service providers OAuth endpoints (for this example, the Dropbox API) The high-level workflow is as follows: The XD plugin pings the server to get the session ID The server returns a unique ID for the user's XD session Plugin opens a tab in user's default browser with a URL pointing to an endpoint on the server The server handles the entire OAuth code grant workflow The user gives necessary permissions to the plugin The server saves the access token paired with the session ID The plugin polls the server to check if the access token is available for the session ID. If the token is available, the server sends the access token back The plugin uses the access token to make API calls to the service API Configuration Complete code for this plugin can be found on GitHub. The following steps will help you get the sample code from our GitHub repo up and running. 1. Install Node.js packages Inside the sample repo's server folder, there is a package.json file that contains a list of dependencies. Run the following command from the top level directory of the repo to install the dependencies: $ cd server $ npm install 2. Use ngrok to create a public SSL URL You can use either ngrok to create a public SSL endpoint, or use your own public URL. To use ngrok, first download it to your machine. You can run ngrok from anywhere on your machine, but since we're already in the server folder, we'll move ngrok there for convenience. mv ~/Downloads/ngrok ./ Then we run it: ./ngrok http 8000 Now ngrok is forwarding all HTTP requests from port 8000 to a public SSL endpoint. You can see the forwarding endpoint currently being used in the ngrok terminal output. Note the forwarding endpoint; we'll use it in the next step. 3. Set your API credentials and public URL Enter the required credentials in public/config.js. You'll need: Your Dropbox API key Your Dropbox API secret Your ngrok public URL const dropboxApiKey = \"YOUR-DROPBOX-API-KEY\"; const dropboxApiSecret = \"YOUR-DROPBOX-SECRET\"; const publicUrl = \"YOUR-PUBLIC-URL\"; // e.g. https://476322de.ngrok.io/ try { if (module) { module.exports = { dropboxApiKey: dropboxApiKey, dropboxApiSecret: dropboxApiSecret, publicUrl: publicUrl } } } catch (err) { console.log(err); } Our server will make use of these settings in a later step. 4. Start the server After completing the configuration steps, start the server from the server folder: $ npm start Now you have a running server with an HTTPS endpoint and your Dropbox credentials ready to go. Development Steps Now we can get back to the XD plugin side of things! 1. Create plugin scaffold First, edit the manifest file for the plugin you created in our Quick Start Tutorial. Replace the uiEntryPoints field of the manifest with the following: \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"How to Integrate with OAuth (Must run Server first)\", \"commandId\": \"launchOAuth\" } ] If you're curious about what each entry means, see the manifest documentation, where you can also learn about all manifest requirements for a plugin to be published in the XD Plugin Manager. Then, update your main.js file, mapping the manifest's commandId to a handler function. Replace the content of your main.js file with the following code (note the presence of the async keyword, which we'll look at in a later step): async function launchOAuth(selection) { // The body of this function is added later } module.exports = { commands: { launchOAuth } }; The remaining steps in this tutorial describe additional edits to the main.js file. 2. Require in XD API dependencies For this tutorial, we just need access to two XD scenegraph classes. Add the following lines to the top of your plugin's top-level main.js file: const { Text, Color } = require(\"scenegraph\"); Now the Text and Color classes are required in and ready to be used. 3. Store the public URL Your plugin will also need to know your public URL. Since we used ngrok earlier, we'll make a constant with that URL: const publicUrl = \"YOUR-PUBLIC-URL\"; // e.g. https://476322de.ngrok.io/ This url will be used to send requests to your server. 4. Create a variable to store the access token Once you receive the access token from your server, you can use the token for API calls as long as the token is stored in memory and the XD session is alive. let accessToken; We'll assign the value later. 5. Write a helper function for XHR requests // XHR helper function function xhrRequest(url, method) { return new Promise((resolve, reject) => { // [1] const req = new XMLHttpRequest(); req.timeout = 6000; // [2] req.onload = () => { if (req.status === 200) { try { resolve(req.response); // [3] } catch (err) { reject(`Couldn't parse response. ${err.message}, ${req.response}`); } } else { reject(`Request had an error: ${req.status}`); } } req.ontimeout = () => { console.log(\"polling..\") // [4] resolve(xhrRequest(url, method)) } req.onerror = (err) => { console.log(err) reject(err) } req.open(method, url, true); // [5] req.responseType = 'json'; req.send(); }); } This helper function returns a promise object Request timeout is set to 6000 miliseconds On a successful request, the promise is resolved with req.response. In any other scenarios, the promise is rejected If the request was timed out after 6000 miliseconds, the function loops and keeps sending XHR request until the response is received The function sends the request to the specified url with the specified method 6. Get the session ID We'll make an XHR request. const rid = await xhrRequest(`${publicUrl}/getRequestId`, 'GET') .then(response => { return response.id; }) This part of the function sends a GET request to your server's getRequestId endpoint and returns response.id. Let's take a look at the code on the server side: /* Authorized Request IDs (simulating database) */ const requestIds = {}; // [1] app.get('/getRequestId', function (req, res) { /* Simulating writing to a database */ for (let i = 1; i Note that there is a global variable, requestIDs, which is an empty JavaScript object. For the sake of simplicity, we are using this object to simulate a database This loop function simulates writing to a database by creating a new id, save the id in the global object, and res.json with the id 7. Open the default browser with the URL pointing to your server To open the machine's default browser from an XD plugin, we can use UXP's shell module: require(\"uxp\").shell.openExternal(`${publicUrl}/login?requestId=${rid}`) This will open the browser with the url pointing to an endpoint on your server. Let's take a look at the code on the server side. app.get('/login', function (req, res) { let requestId = req.query.requestId; // [1] /* This will prompt user with the Dropbox auth screen */ res.redirect(`https://www.dropbox.com/oauth2/authorize?response_type=code&client_id=${dropboxApiKey}&redirect_uri=${publicUrl}/callback&state=${requestId}`) // [2] }) app.get('/callback', function (req, res) { /* Retrieve authorization code from request */ let code = req.query.code; // [3] let requestId = req.query.state; /* Set options with required paramters */ let requestOptions = { // [4] uri: `https://api.dropboxapi.com/oauth2/token?grant_type=authorization_code&code=${code}&client_id=${dropboxApiKey}&client_secret=${dropboxApiSecret}&redirect_uri=${publicUrl}/callback`, method: 'POST', json: true } /* Send a POST request using the request library */ request(requestOptions) // [5] .then(function (response) { /* Store the token in req.session.token */ req.session.token = response.access_token; // [6] /* Simulating writing to a database */ requestIds[requestId][\"accessToken\"] = response.access_token; // [7] res.end() }) .catch(function (error) { res.json({ 'response': 'Log in failed!' }); }); }) /login route grabs the requestId from the query parameter and redirects to the Dropbox's authorize endpoint and pass the requestId to the optional parameter, state. This redirect will prompt the login screen on the user's browser Once the dropbox API returns the code to the specified callback endpoint, /callback, which then parses the code and the requestId Set requestOptions object with Dropbox's token URI Use the request library to send the POST request Store the access token received from Dropbox in the session object Simulate writing to a database by paring the access token with requestId and storing it to requestIds global object 8. Poll the server until access token is received accessToken = await xhrRequest(`${publicUrl}/getCredentials?requestId=${rid}`, 'GET') .then(tokenResponse => { return tokenResponse.accessToken; }) As noted in step #4, the xhrRequest helper function is designed to poll the server if the initial request is not responded in 6000 miliseconds. Once the user completes the OAuth workflow in the browser, polling should stop and this request should be returned with the access token. 9. Show a dialog indicating the token has been received // create the dialog let dialog = document.createElement(\"dialog\"); // [1] // main container let container = document.createElement(\"div\"); // [2] container.style.minWidth = 400; container.style.padding = 40; // add content let title = document.createElement(\"h3\"); // [3] title.style.padding = 20; title.textContent = `XD and Dropbox are now connected`; container.appendChild(title); // close button let closeButton = document.createElement(\"button\"); // [4] closeButton.textContent = \"Got it!\"; container.appendChild(closeButton); closeButton.onclick = (e) => { // [5] dialog.close(); } document.body.appendChild(dialog); // [6] dialog.appendChild(container); dialog.showModal() Just like HTML DOM APIs, you can use document.createElement method to create UI objects. Elements have the style property which contains metrics properties you can set The dialog element is the modal window that pops down in XD Create a container div element Create a h3 element to let the user know the auth workflow has been completed You need at least one exit point. Create a close button and add it to the container Create a listener for the click event and close the dialog Attach the dialog to the document, add the container, and use showModal method to show the modal 10. Make an API call to Dropbox const dropboxProfileUrl = `https://api.dropboxapi.com/2/users/get_current_account?authorization=Bearer%20${accessToken}`; // [1] const dropboxProfile = await xhrRequest(dropboxProfileUrl, 'POST'); // [2] Note that received accessToken is included in this Dropbox API call to retrieve the current account's profile xhrRequest helper function is used again to make this POST call 10. Create a text element to show the profile information inside the current artboard const text = new Text(); // [1] text.text = JSON.stringify(dropboxProfile); // [2] text.styleRanges = [ // [3] { length: text.text.length, fill: new Color(\"#0000ff\"), fontSize: 10 } ]; selection.insertionParent.addChild(text); // [4] text.moveInParentCoordinates(100, 100); // [5] Create a new Text instance in XD Populate the text with the stringified version of the profile json object Add the styleRanges for the text Insert the text Move the text inside the artboard to make it visible Next Steps Ready to explore further? Take a look at our other resources: Tutorials Sample code repos "},"tutorials/ui-index.html":{"url":"tutorials/ui-index.html","title":"Building user interfaces","keywords":"","body":"Building user interfaces While plenty of XD plugins are perfectly suited to run like headless scripts, many plugins will need to interact with the user in some way. XD plugins can display UI in the form of modal dialogs, built with JavaScript and a supported subset of HTML and CSS. For simple alerts and messages, we've also built various helpers which make it easy to display important messages, get user feedback, and more. The tutorials in this section will focus on the UI you can generate using these helpers. Should you need more power than these helpers provide, you can learn more by reading the User Interface design section and our User Interface API references. The tutorials contained in this section will get you on your way to building plugin UI well-suited for XD utilizing the Plugin Toolkit library. Before continuing, please ensure that you install the tooklit in your project, as follows: Click the \"Clone or Download\" button on the right side of the Plugin Toolkit page Uncompress the zip file after the download completes Copy the lib folder to your plugin project Now you're ready to display simple messages to your users! How to show an alert How to ask user for confirmation More complex UI There are a lot of ways to render more complex UI. Check out our plugin design documentation to learn more about UX patterns and creating UI. "},"tutorials/how-to-show-an-alert/":{"url":"tutorials/how-to-show-an-alert/","title":"How to show an alert","keywords":"","body":"How to show an alert There will be times when you need to show a simple message to your user. This tutorial will show you an easy way to display an informational message like the following: Other times you'll need to display an error alert, which looks like this: Technology Used Plugin Toolkit Prerequisites Basic knowledge of HTML, CSS, and JavaScript. Quick Start Tutorial Debugging Tutorial Development Steps Complete code for this plugin can be found on GitHub. 1. Prepare your manifest.json file First, edit the manifest file for the plugin you created in our Quick Start Tutorial. Replace the uiEntryPoints field of the manifest with the following: \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"How to show an alert\", \"commandId\": \"showAlert\" }, { \"type\": \"menu\", \"label\": \"How to show an error\", \"commandId\": \"showError\" } ] If you're curious about what each entry means, see the manifest documentation, where you can also learn about all manifest requirements for a plugin to be published in the XD Plugin Manager. 2. Add the \"plugin helpers\" library Creating dialogs can take a lot of boilerplate code, but we've created a small library that makes it simple to display simple dialogs in the form of a \"helper\" library. This library is located at https://github.com/AdobeXD/plugin-toolkit. To add the library to your project, you can: Click the \"Clone or Download\" button on the right side of the page Uncompress the zip file after the download completes Copy the lib folder to your plugin project 3. Require the dialogs module in main.js Add the following to your main.js: const { alert, error } = require(\"./lib/dialogs.js\"); This will import a alert function that we can call to display an alert. The error function can be used to display the error variation. 4. Create a function to display the alert async function showAlert() { /* we'll display a dialog here */ } Next, inside this function, we call alert to render the message. This function takes several parameters: The dialog's title The text you want to display to the user in the dialog's body – you can pass as many lines of text as you want (but be careful: dialogs won't scroll automatically!) Let's see what that looks like in code: await alert(\"Connect to the Internet\", //[1] \"In order to function correctly, this plugin requires access to the Internet. Please connect to a network that has Internet access.\"); //[2] 5. Create a function to display an error alert async function showError() { /* we'll display a dialog here */ } Inside this function, we call error to render the message. Just like alert, this function takes several parameters: The dialog's title The text you want to display to the user in the dialog's body – you can pass as many lines of text as you want (but be careful: dialogs won't scroll automatically!) Let's see what that looks like in code: await error(\"Synchronization Failed\", //[1] \"Failed to synchronize all your changes with our server. Some changes may have been lost.\", \"Steps you can take:\", \"* Save your document\", \"* Check your network connection\", \"* Try again in a few minutes\"); //[2] Note that the we passed several lines of text to error, including some markdown-like list items. The dialogs module understands a very limited subset of markdown; for more see the Plugin Toolkit. 6. Create the menu handler We need to export a menu handler from the main.js file so that XD knows what to do with our plugin: module.exports = { commands: { showAlert, showError } } Make sure to your commands match the manifest's commandIds written in the first step. Guidelines It's important to know when to show an alert because they do obstruct the user's ability to interact with XD. As such, you should follow these guidelines: Don't display \"success\" alerts when it's obvious that the plugin has been successful. Do display a \"success\" alert if your plugin's operation is completed, but the user would have no way of knowing. Do use human-readable language. Don't use technical jargon unless it's language the user is already familiar with. Next Steps Other than alert and error, there are other useful dialog helpers that you might be interested in. How to ask for confirmation User Interface design Other samples "},"tutorials/how-to-ask-user-for-confirmation/":{"url":"tutorials/how-to-ask-user-for-confirmation/","title":"Asking user for confirmation","keywords":"","body":"Asking the user for confirmation There are many times when a plugin will need to ask the user whether or not it should proceed with a given course of action. This tutorial will show you an easy way to get user confirmation before proceeding with a task. Technology Used Plugin Toolkit Prerequisites Basic knowledge of HTML, CSS, and JavaScript. Quick Start Tutorial Debugging Tutorial Development Steps Complete code for this plugin can be found on GitHub. 1. Prepare your manifest.json file First, edit the manifest file for the plugin you created in our Quick Start Tutorial. Replace the uiEntryPoints field of the manifest with the following: \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"Confirmation\", \"commandId\": \"showConfirm\" } ] If you're curious about what each entry means, see the manifest documentation, where you can also learn about all manifest requirements for a plugin to be published in the XD Plugin Manager. 2. Add the \"plugin helpers\" library Creating dialogs can take a lot of boilerplate code, but we've created a small library that makes it simple to display simple dialogs in the form of a \"helper\" library. This library is located at https://github.com/AdobeXD/plugin-toolkit. To add the library to your project, you can: Click the \"Clone or Download\" button on the right side of the page Uncompress the zip file after the download completes Copy the lib folder to your plugin project 3. Require the dialogs module in main.js Add the following to your main.js: const { confirm } = require(\"./lib/dialogs.js\"); This will import a confirm function that we can call to display a confirmation dialog. 4. Create a function to display the confirmation async function showConfirm() { /* we'll display a dialog here */ } Next, inside this function, we call confirm to actually show the confirmation dialog. confirm takes three arguments: The dialog's title The text you want to display to the user in the dialog's body The two buttons from which you want the user to choose (A confirmation dialog can only have two buttons) Let's see what that looks like in code: const feedback = await confirm(\"Enable Smart Filters?\", //[1] \"Smart filters are nondestructive and will preserve your original images.\", //[2] [\"Cancel\", \"Enable\"] /*[3]*/ ); Note that the third argument is an array of strings. These identify the names of the two buttons that will display in the confirmation dialog. These are given in the order they would appear on a macOS machine, which means that the \"cancel\" or negative button is listed first, and the \"ok\" or acceptance button is listed last. 5. React to which button was pressed When the dialog is closed, some useful information about which button was pressed will be provided. You can access this using the which property on the feedback variable (return value from confirm). switch (feedback.which) { case 0: /* User canceled */ break; case 1: /* User clicked Enable */ break; } As you can see, the value of which maps to the buttons as specified when calling confirm. So 0 is the \"Cancel\" button and 1 is the \"Enable\" button. 6. Create the menu handler We need to export a menu handler from the main.js file so that XD knows what to do with our plugin: module.exports = { commands: { showConfirm } } Make sure to your commands match the manifest's commandIds written in the first step. Next Steps Ready to explore further? Take a look at our other resources: Tutorials Sample code repos "},"reference/":{"url":"reference/","title":"Technical Reference","keywords":"","body":"Technical Reference Use this section to access the API references, know what are the currently known issues, and learn what is new and what has changed. API references Known issues Change log Glossary Here are some of the recommended next steps for you: Try some of our samples on the samples repo on GitHub. Join the community. See our Community page to learn about how to connect. Share your plugin. See our Distribution page to learn various options to share your plugin. "},"reference/reference-index.html":{"url":"reference/reference-index.html","title":"API references","keywords":"","body":"API References There are two main types of APIs you can use to create your XD plugin. While Unified Extensibility Platform (UXP) provides commonly used APIs across different Creative Cloud applications, Host APIs enable developers to extend XD specific features. UXP APIs Host APIs For more information on how UXP and host APIs work together, refer to Accessing APIs. Read \"How to read the reference documentation\" to learn how to read symbols inside the docs. "},"reference/uxp/":{"url":"reference/uxp/","title":"UXP","keywords":"","body":"Unified Extensibility Platform (UXP) Unified Extensibility Platform (UXP) is a new extensibility architecture that provides commonly used APIs across different Creative Cloud applications. These common APIs include File I/O, Network I/O, and a User Interface layer. In this API reference docs, we organized UXP APIs into three categories: Network Storage Shell OS UI "},"reference/uxp/network-index.html":{"url":"reference/uxp/network-index.html","title":"Network APIs","keywords":"","body":"Network Network I/O The Network I/O subsystem mimics the standards found on the web. The following API surfaces are available: Web Sockets XD Documentation MDN documentation XMLHttpRequest XD Documentation MDN documentation Fetch XD Documentation MDN documentation Web Socket Support The entire web socket API is supported, except for extensions handling. XMLHttpRequest Support Most of the XHR API surface is supported, including: Setting request headers Getting response headers Event handling Sending text and binary data Text is expected to be UTF8 encoded. Binary data must use ArrayBuffer, not Blob Unsupported portions of the surface: responseURL Sending / receiving Blobs is not supported Synchronous XHR will throw an error Fetch Support Fetch is polyfilled on top of the XHR implementation using https://github.com/github/fetch. "},"reference/uxp/class/XMLHttpRequest.html":{"url":"reference/uxp/class/XMLHttpRequest.html","title":"XMLHttpRequest","keywords":"","body":" XMLHttpRequest ~XMLHttpRequest new XMLHttpRequest() .responseURL .readyState .responseText .responseXML .response .status .statusText .timeout .timeout .responseType .responseType .withCredentials .withCredentials .upload .abort() .getAllResponseHeaders() .getResponseHeader(name) .open(method, url, [async], [user], [password]) .overrideMimeType(mimetype) .setRequestHeader(header, data) .send([data]) new XMLHttpRequest() The constructor initializes an XMLHttpRequest. It must be called before any other method calls. xmlHttpRequest.responseURL Unsupported Read only xmlHttpRequest.readyState Returns an unsigned short, the state of the request. Returns: int - returns the state of the XMLHttpRequest client. Read only xmlHttpRequest.responseText Returns a DOMString that contains the response to the request as text, or null if the request was unsuccessful or has not yet been sent. Returns: string - returns the received text response. Read only xmlHttpRequest.responseXML Returns the XML document that supports W3C DOM level2 specification. The XML document is constructed with received bytes using XMLHttpRequest. Returns: object - returns the XML document response. Throws: DOMException if responseType is not the empty string or \"document\". Read only xmlHttpRequest.response Returns the response from the server in the type specified by responseType. Only valid after the load event fires. Returns: string or ArrayBuffer or Blob or Object - returns an ArrayBuffer, Blob, Document, JavaScript object, or a DOMString, depending on the value of; XMLHttpRequest.responseType that contains the response entity body. Read only xmlHttpRequest.status Returns: string - returns the HTTP status code received from the server. Read only xmlHttpRequest.statusText Returns: string - returns the response's status message with regard to the HTTP status code received from the server. Read only xmlHttpRequest.timeout The number of milliseconds a request can take before automatically being terminated. The default value is 0, which means there is no timeout. xmlHttpRequest.timeout Terminates a request and a timeout event will be dispatched after the given time has passed. Throws: DOMException if called for synchronous request. Param Type Description value number number of milliseconds a request can take automatically being terminated. xmlHttpRequest.responseType Returns: string - returns a string taken from the XMLHttpRequestResponseType enum which specifies; what type of data the response contains. xmlHttpRequest.responseType Param Type Description value string A string indicating the type of data contained in the response. This should be \"arraybuffer\", \"blob\", \"document\", \"json\" or \"text\". xmlHttpRequest.withCredentials Indicates whether to send cookies on a HTTP request. When the value is set to true, XMLHttpRequest sends cookies. Otherwise, cookies are not sent. xmlHttpRequest.withCredentials Throws: DOMException when set if state is not unsent or opened. Param Type Default Description [value] Boolean true whether to send cookies on a HTTP request. xmlHttpRequest.upload If XMLHttpRequest has data in the body to upload, upload related event will be notified via XMLHttpRequest.upload. Returns: XMLHttpRequestEventUpload - returns XMLHttpRequestEventUpload object. Read only xmlHttpRequest.abort() Aborts the request if it has already been sent. xmlHttpRequest.getAllResponseHeaders() Returns sorted and combined response’s header list. Each header field is defined by a group of [lower cased name]\": \"[value]\"\\r\\n\". Combined value is separated by \", \". Returns: string - returns response’s header list. Read only xmlHttpRequest.getResponseHeader(name) Returns the matching value of the given field name in response's header. The search key value is case-insensitive Returns: string - returns the value of the given name in response's header list. Read only Param Type Description name string The name to search in response's header list. xmlHttpRequest.open(method, url, [async], [user], [password]) Initializes a request. This method is to be used from JavaScript code; to initialize a request from native code, use openRequest() instead. Self-signed certificates are not currently supported for HTTPS connections. Param Type Default Description method string The HTTP request method to use, such as \"GET\", \"POST\", \"PUT\", \"DELETE\", etc. Ignored for non-HTTP(S) URLs. url string A DOMString representing the URL to send the request to. [async] boolean true An optional Boolean parameter, defaulting to true, indicating whether or not to perform the operation asynchronously. If this value is false, the send() method does not return until the response is received. If true, notification of a completed transaction is provided using event listeners. This must be true if the multipart attribute is true, or an exception will be thrown. [user] string null The optional user name to use for authentication purposes; by default, this is the null value. [password] string null The optional password to use for authentication purposes; by default, this is the null value. xmlHttpRequest.overrideMimeType(mimetype) Use a MIME type other than the one provided by the server when interpreting the data being transferred in a request. If parsing the MIME type fails, \"application/octet-stream\" will be used to interpret the data. Throws: DOMException if state is loading or done Param Type Description mimetype string MIME type Since Only UTF-8 is supported for charset of text encoding, MIME type’s parameters \"charset\" with other values than 'UTF-8' is not valid. xmlHttpRequest.setRequestHeader(header, data) Sets the value of an HTTP request header. You must call setRequestHeader()after open(), but before send(). Param Type Description header string The name of the header whose value is to be set. data string The value to set as the body of the header. xmlHttpRequest.send([data]) Sends the request. If the request is asynchronous (which is the default), this method returns as soon as the request is sent. Param Type Default Description [data] * A body of data to be sent in the XHR request. This can be: A Document, in which case it is serialized before being sent. A BodyInit, which as per the Fetch spec can be a Blob, BufferSource, FormData, URLSearchParams, ReadableStream, or USVString object. If no value is specified for the body, a default value of null is used. The best way to send binary content (e.g. in file uploads) is by using an ArrayBufferView or Blob in conjunction with the send() method. There is a caveat for sending a FormData object. The files in the FormData object are being read after calling this method. To ensure uploading files as-is, the file contents or files shouldn't be changed until uploading files to the server is done. @see XMLHttpRequest.upload. If there is a problem during reading files, the XMLHttpRequest transaction initiated by this method can be aborted with an error event fired. "},"reference/uxp/function/fetch.html":{"url":"reference/uxp/function/fetch.html","title":"fetch","keywords":"","body":" fetch(input, [init]) Returns: Promise. - @see Response Throws: TypeError when init.body is set and init.method is either \"GET\" or \"HEAD\". when either network error or network time-out occurs after a http request is made. when there is a failure in reading files in FormData during posting FormData. Param Type Default Description input string or Request either the URL string to connect with or a Request object having the URL and the init option in the below. [init] Object custom options for a HTTP request. [init.method] Object \"GET\" the HTTP request method. [init.headers] Headers the HTTP request headers to add. [init.body] string or ArrayBuffer or TypedArray or FormData the body that is included in the HTTP request body. There is a caveat for sending a FormData object. @see XMLHttpRequest.send. [init.credentials] string \"\\\"omit\\\"\" indicates whether to send cookies. Possible values and functions are as follows: \"omit\" : cookies are NOT sent, \"same-origin\" and \"include\" : cookies are sent. "},"reference/uxp/class/WebSocket.html":{"url":"reference/uxp/class/WebSocket.html","title":"WebSocket","keywords":"","body":" WebSocket ~WebSocket new WebSocket(url, protocols) .protocol .bufferedAmount .binaryType .binaryType .send(data) .close([code], [reason]) new WebSocket(url, protocols) Param Type Description url string The URL to which to connect; this should be the URL to which the WebSocket server will respond. protocols string or Array. Either a single protocol string or an array of protocol strings. Example usage: var ws = new WebSocket(\"ws://demos.kaazing.com/echo\",\"xmpp\"); Throws an exception of Error Object if invalid url or protocols is passed webSocket.protocol Returns: string - returns a string indicating the name of the sub-protocol the server selected; this will be one of the strings specified in the protocols parameter when creating the WebSocket object. webSocket.bufferedAmount Returns: number - returns the number of bytes of data that have been queued using calls to send() but not yet transmitted to the network. This value resets to zero once all queued data has been sent. This value does not reset to zero when the connection is closed; if you keep calling send(), this will continue to climb. Read only webSocket.binaryType Param Type Description data string A string indicating the type of binary data being transmitted by the connection. This should be either \"blob\" if DOM Blob objects are being used or \"arraybuffer\" if ArrayBuffer objects are being used. webSocket.binaryType Returns: string - returns the string indicating the binary data type. webSocket.send(data) Enqueues the specified data to be transmitted to the other end over the WebSocket connection, increasing the value of bufferedAmount by the number of bytes needed to contain the data. If the data can't be sent (for example, because it needs to be buffered but the buffer is full), the socket is closed automatically. Param Type Description data string or ArrayBuffer or ArrayBufferView Data to be sent Example usage: ws.send(new Float32Array([ 5, 2, 1, 3, 6, -1 ])) ws.send(new Int32Array([5,-1]).buffer) webSocket.close([code], [reason]) Closes the websocket connection Param Type Default Description [code] integer 1000 A integer value as per https://developer.mozilla.org/en-US/docs/Web/API/WebSocket#close(). [reason] string \"\" A human-readable string explaining why the connection is closing. Throws an exception of Error Object if invalid code or reason is passed "},"reference/uxp/storage-index.html":{"url":"reference/uxp/storage-index.html","title":"Storage APIs","keywords":"","body":"Storage Using the File API XD provides a simple, cross-platform API surface that makes it easy to read and write text and binary files. Three key things to note: Instead of working with string paths, you work with File and Folder objects. Access to the user's files requires showing a file picker UI, but you can access temporary files and any files packaged inside your plugin without needing any user interaction. If you have a File/Folder object, then you have access to the corresponding item on disk. File APIs are asynchronous, returning Promises which you can use with then() or the async/await keywords. Getting access to the local file system Start using the file system APIs by obtaining a FileSystemProvider object (shortened to fs in the code here): const fs = require(\"uxp\").storage.localFileSystem; You can use the fs object to access a temporary folder or your plugin's own folder immediately, or request access to user folders by showing a file picker: // These require no user interaction: const tempFolder = await fs.getTemporaryFolder(); const pluginFolder = await fs.getPluginFolder(); // read-only access to the plugin's install folder const pluginDataFolder = await fs.getDataFolder(); // folder to store settings // Display file/folder picker UI to access user files: const userFolder = await fs.getFolder(); // folder picker const aFile = await fs.getFileForOpening(); // \"Open\" file picker, suitable for reading contents const anotherFile = await fs.getFileForSaving(\"hello.txt\"); // \"Save\" file picker, suitable for writing contents If you have a Folder, you can use getEntries() to enumerate the folder's contents: const entries = await folder.getEntries(); entries.forEach(entry => console.log(entry.name)); If you have a File, you can read and write its contents like so: const contents = await aFile.read(); await anotherFile.write(contents); You can create new files inside a folder you have access to: const newFile = await folder.createEntry(\"examples.txt\", {overwrite: true}); newFile.write(\"Hello, world!\"); See the full reference. "},"reference/uxp/module/storage.html":{"url":"reference/uxp/module/storage.html","title":"Storage module","keywords":"","body":" storage Category: uxp, io, file storage .Entry .name : string .provider : FileSystemProvider .url : URL .nativePath : string .isEntry : boolean .isFile : boolean .isFolder : boolean .toString() ⇒ string .copyTo(folder, options) ⇒ Promise .moveTo(folder, options) ⇒ Promise .delete() ⇒ Promise .getMetadata() ⇒ Promise. .EntryMetadata .name : string .size : number .dateCreated : Date .dateModified : Date .isFile : boolean .isFolder : boolean .File .mode : Symbol .read(options) ⇒ Promise. .write(data, options) .FileSystemProvider .getFileForOpening(options) ⇒ Promise. or Promise.> .getFileForSaving(suggestedName, options) ⇒ Promise. .getFolder() ⇒ Promise. .getTemporaryFolder() ⇒ Promise. .getDataFolder() ⇒ Promise. .getPluginFolder() ⇒ Promise. .getFsUrl(entry) ⇒ URL .getNativePath(entry) ⇒ string .Folder ⇐ Entry .getEntries() ⇒ Promise.> .createFile(name, options) ⇒ Promise. .createFolder(name) ⇒ Folder .getEntry(filePath) ⇒ Promise. .renameEntry(entry, newName, options) ⇒ Promise .localFileSystem : LocalFileSystemProvider .errors : Errors .AbstractMethodInvocationError ⇐ Error .ProviderMismatchError ⇐ Error .EntryIsNotAnEntryError ⇐ Error .EntryIsNotAFolderError ⇐ Error .EntryIsNotAFileError ⇐ Error .NotAFileSystemError ⇐ Error .OutOfSpaceError ⇐ Error .PermissionDeniedError ⇐ Error .EntryExistsError ⇐ Error .FileIsReadOnlyError ⇐ Error .DomainNotSupportedError ⇐ Error .InvalidFileNameError ⇐ Error .fileTypes .text .images .all .formats .utf8 : Symbol .binary : Symbol .modes .readOnly : Symbol .readWrite : Symbol .types .file : Symbol .folder : Symbol storage.Entry An Entry is the base class for File and Folder. You'll never instantiate an Entry directly, but it provides the common fields and methods that both File and Folder share. Important: An Entry object may exist even if the corresponding file/folder on disk does not currently exist. It's possible for multiple Entry objects to represent the same item on disk, for example if the item was picked via multiple separate file picker invocations. Kind: static class of storage Since: XD 13 .Entry .name : string .provider : FileSystemProvider .url : URL .nativePath : string .isEntry : boolean .isFile : boolean .isFolder : boolean .toString() ⇒ string .copyTo(folder, options) ⇒ Promise .moveTo(folder, options) ⇒ Promise .delete() ⇒ Promise .getMetadata() ⇒ Promise. entry.name : string The name of this entry. Read-only. Kind: instance property of Entry Read only: true Since: XD 13 Example console.log(anEntry.name); entry.provider : FileSystemProvider The associated provider that services this entry. Read-only. Kind: instance property of Entry Read only: true Since: XD 13 Example if (entryOne.provider !== entryTwo.provider) { throw new Error(\"Providers are not the same\"); } entry.url : URL The url of this entry. You can use this url as the src attribute of an tag in the UI. Read-only. Kind: instance property of Entry Read only: true Since: XD 13 Example console.log(anEntry.url); entry.nativePath : string The platform native file-system path of this entry. Read-only Kind: instance property of Entry Read only: true Since: XD 13 Example console.log(anEntry.nativePath); entry.isEntry : boolean Indicates that this instance is an Entry. Useful for type-checking. Kind: instance property of Entry Example if (something.isEntry) { return something.getMetadata(); } entry.isFile : boolean Indicates that this instance is not a File. Useful for type- checking. Kind: instance property of Entry Read only: true Example if (!anEntry.isFile) { return \"This entry is not a file.\"; } entry.isFolder : boolean Indicates that this instance is not a folder. Useful for type- checking. Kind: instance property of Entry Read only: true Example if (!anEntry.isFolder) { return \"This entry is not a folder.\"; } entry.toString() ⇒ string Returns the details of the given entry like name, type and native path in a readable string format. Kind: instance method of Entry Since: XD 13 entry.copyTo(folder, options) ⇒ Promise Copies this entry to the specified folder. The Entry object passed to this function will continue to reference the original item - it is not updated to reference the copy. Kind: instance method of Entry Throws: EntryExists if the attempt would overwrite an entry and overwrite is false PermissionDenied if the underlying file system rejects the attempt OutOfSpace if the file system is out of storage space Since: XD 13 Param Type Default Description folder Folder the folder to which to copy this entry options * [options.overwrite] boolean false if true, allows overwriting existing entries Example await someFile.copyTo(someFolder); Example await someFile.copyTo(someFolder, {overwrite: true}); Example await someFolder.copyTo(anotherFolder, {overwrite: true}); entry.moveTo(folder, options) ⇒ Promise Moves this entry to the target folder, optionally specifying a new name. The Entry object passed to this function is automatically updated to reference the new location, however any other Entry objects referencing the original item will not be updated, and will thus no longer point to an item that exists on disk. Kind: instance method of Entry Since: XD 13 Param Type Default Description folder Folder the folder to which to move this entry options * [options.overwrite] boolean false If true allows the move to overwrite existing files [options.newName] string If specified, the entry is renamed to this name Example await someFile.moveTo(someFolder); Example await someFile.moveTo(someFolder, {overwrite: true}); Example await someFolder.moveTo(anotherFolder, {overwrite: true}); Example await someFile.moveTo(someFolder, {newName: 'masterpiece.txt'}) Example await someFile.moveTo(someFolder, {newName: 'novel.txt', {overwrite: true}) entry.delete() ⇒ Promise Removes this entry from the file system. If the entry is a folder, you must remove the files inside before removing the folder. Kind: instance method of Entry Since: XD 13 Example await aFile.delete(); entry.getMetadata() ⇒ Promise. Returns this entry's metadata. Kind: instance method of Entry Since: XD 13 Example const metadata = await aFile.getMetadata(); storage.EntryMetadata Metadata for an entry. It includes useful information such as: size of the file (if a file) date created date modified name You'll never instantiate an EntryMetadata directly; instead use getMetadata to get metadata for a specific File or Folder entry. Kind: static class of storage .EntryMetadata .name : string .size : number .dateCreated : Date .dateModified : Date .isFile : boolean .isFolder : boolean entryMetadata.name : string The name of the entry. Kind: instance property of EntryMetadata entryMetadata.size : number The size of the entry, if a file. Zero if a folder. Kind: instance property of EntryMetadata entryMetadata.dateCreated : Date The date this entry was created. Kind: instance property of EntryMetadata entryMetadata.dateModified : Date The date this entry was modified. Kind: instance property of EntryMetadata entryMetadata.isFile : boolean Indicates if the entry is a file Kind: instance property of EntryMetadata entryMetadata.isFolder : boolean Indicates if the entry is a folder Kind: instance property of EntryMetadata storage.File Represents a file on a file system. Provides methods for reading from and writing to the file. You'll never instantiate a File directly; instead you'll get access via a FileSystemProvider. method such as getFileForOpening(). Kind: static class of storage Since: XD 13 Important: A File object may exist even if the corresponding file on disk does not currently exist. It's possible for multiple File objects to represent the same file on disk, for example if the file was picked via multiple separate file picker invocations. .File .mode : Symbol .read(options) ⇒ Promise. .write(data, options) file.mode : Symbol Indicates whether this File object supports read-only or read-write access. See readOnly and readWrite. Kind: instance property of File Since: XD 13 Example if (aFile.mode === modes.readOnly) { throw new Error(\"Can't write to a file opened as read-only.\"); } file.read(options) ⇒ Promise. Reads data from the file and returns it. The file format can be specified with the format option. If a format is not supplied, the file is assumed to be a text file using UTF8 encoding. Kind: instance method of File Returns: Promise. - the contents of the file Since: XD 13 Param Type Default Description options Object [options.format] Symbol formats.utf8 Optional. Format to read: one of storage.formats.utf8 or storage.formats.binary. Example const text = await myNovel.read(); // 'text' is a string Example const data = await myNovel.read({format: formats.binary}); // 'data' is an ArrayBuffer console.log(\"File is \" + data.byteLength + \" bytes long.\"); file.write(data, options) Writes data to a file, appending if desired. The format of the file is controlled via the format option, and defaults to UTF8. Kind: instance method of File Throws: FileIsReadOnly if writing to a read-only file OutOfSpace If writing to the file causes the file system to exceed the available space (or quota) Since: XD 13 Param Type Default Description data string or ArrayBuffer Data to write to the file options Object [options.format] Symbol formats.utf8 Optional. Format to write: storage.formats.utf8 or storage.formats.binary. Example await myNovel.write(\"It was a dark and stormy night.\\n\"); Example const data = new Uint8Array([0xFF, 0xA1]); await aDataFile.write(data, {format: formats.binary}); // writes a 2-byte file storage.FileSystemProvider Provides access to files and folders on a file system. You don't instantiate this directly; instead you'll use an instance that has already been created for you. Kind: static class of storage Since: XD 13 .FileSystemProvider .getFileForOpening(options) ⇒ Promise. or Promise.> .getFileForSaving(suggestedName, options) ⇒ Promise. .getFolder() ⇒ Promise. .getTemporaryFolder() ⇒ Promise. .getDataFolder() ⇒ Promise. .getPluginFolder() ⇒ Promise. .getFsUrl(entry) ⇒ URL .getNativePath(entry) ⇒ string fileSystemProvider.getFileForOpening(options) ⇒ Promise. or Promise.> Gets a file (or files) suitable for reading by displaying an \"Open\" file picker dialog to the user. File entries returned by this API are read-only - use getFileForSaving to get a File entry you can write to. The user can select multiple files only if the allowMultiple option is true. Kind: instance method of FileSystemProvider Returns: Promise. or Promise.> - ?File if allowMultiple is false (null if picker canceled); or !Array if allowMultiple is true (length 0 if picker canceled) Since: XD 13 Param Type Default Description options Object [options.types] Array. ['*'] Optional. Allowed file extensions, with no \".\" prefix; use storage.fileTypes.all to allow any file to be picked [options.allowMultiple] boolean false Optional. If true, multiple files can be selected and this API returns Array.If false, only one file can be selected and this API returns a File directly. Example const file = await fs.getFileForOpening(); if (!file) { // file picker dialog was canceled return; } const text = await file.read(); Example const files = await fs.getFileForOpening({allowMultiple: true, types: fileTypes.images}); if (files.length === 0) { // no files selected } fileSystemProvider.getFileForSaving(suggestedName, options) ⇒ Promise. Gets a file reference suitable for read-write by displaying a \"Save\" file picker dialog to the user. If the act of writing to the file would overwrite it, the file picker will prompt the user to confirm before returning a result to you. Kind: instance method of FileSystemProvider Returns: Promise. - returns the selected file, or null if canceled Since: XD 13 Param Type Description suggestedName string Required. The file extension should match one of the options specified in the types option. options Object [options.types] Array. Required. Allowed file extensions, with no \".\" prefix. Example const file = await fs.getFileForSaving(\"output.txt\", { types: [ \"txt\" ]}); if (!file) { // file picker was cancelled return; } await file.write(\"It was a dark and stormy night\"); fileSystemProvider.getFolder() ⇒ Promise. Gets a folder from the file system via a folder picker dialog. The files and folders within can be accessed via getEntries. Any files within are read-write. If the user cancels the picker, null is returned instead. Kind: instance method of FileSystemProvider Returns: Promise. - the selected folder or null if picker is canceled. Since: XD 13 Example const folder = await fs.getFolder(); const myNovel = (await fs.getEntries()).find(entry => entry.name.includes('novel')); const text = await myNovel.read(); fileSystemProvider.getTemporaryFolder() ⇒ Promise. Returns a temporary folder. The contents of the folder may be lost when the host application is closed. Kind: instance method of FileSystemProvider Since: XD 13 Example const temp = await fs.getTemporaryFolder(); fileSystemProvider.getDataFolder() ⇒ Promise. Returns a folder that can be used for storing plugin-specific data without needing user interaction though a file picker. Its contents remain persistent when the host application is updated and when your plugin is updated. Kind: instance method of FileSystemProvider Since: XD 13 fileSystemProvider.getPluginFolder() ⇒ Promise. Returns an plugin's folder – this folder and everything within it are read only. This contains all the Plugin related packaged assets. Kind: instance method of FileSystemProvider Since: XD 13 fileSystemProvider.getFsUrl(entry) ⇒ URL Returns the fs url of given entry. Kind: instance method of FileSystemProvider Param Type entry Entry fileSystemProvider.getNativePath(entry) ⇒ string Returns the platform native file system path of given entry. Kind: instance method of FileSystemProvider Param Type entry Entry storage.Folder ⇐ Entry Represents a folder on a file system. You'll never instantiate this directly, but will get it by calling getTemporaryFolder, getFolder, or via getEntries. Important: A Folder object may exist even if the corresponding folder on disk does not currently exist. It's possible for multiple Folder objects to represent the same folder on disk, for example if the folder was picked via multiple separate folder picker invocations. Kind: static class of storage Extends: Entry Since: XD 13 .Folder ⇐ Entry .getEntries() ⇒ Promise.> .createFile(name, options) ⇒ Promise. .createFolder(name) ⇒ Folder .getEntry(filePath) ⇒ Promise. .renameEntry(entry, newName, options) ⇒ Promise folder.getEntries() ⇒ Promise.> Returns an array of entries contained within this folder. Kind: instance method of Folder Returns: Promise.> - The entries within the folder. Since: XD 13 Example const entries = await aFolder.getEntries(); const allFiles = entries.filter(entry => entry.isFile); folder.createFile(name, options) ⇒ Promise. Creates a File object within this folder, which need not correspond to a file that exists on disk yet. Important: If the file already exists on disk (and overwrite is true), creates a File object but does not modify the existing file on disk in any way. If the file does not exist yet, creates a File object but does not create the file on disk yet. You can then use write to create the file and give it content. Kind: instance method of Folder Returns: Promise. - the created file entry Since: XD 13 Param Type Default Description name string the name of the file to create. options Object [options.overwrite] boolean false If false, the call will fail if the file already exists. If true, the call will succeed regardless of whether the file currently exists on disk. Example const myNovelTxtFile = await aFolder.createFile(\"mynovel.txt\"); folder.createFolder(name) ⇒ Folder Creates a Folder object within this folder and creates the folder on disk. Unlike createFile(), this call does modify the disk, and it cannot be used if the folder already exists (use getEntry in that case). Important: If the folder already exists on disk, fails with an error. If the folder does not exist yet, immediately creates it on disk and then returns a Folder object for it. Kind: instance method of Folder Returns: Folder - the created folder entry object Since: XD 13 Param Type Description name string the name of the folder to create. Example const myCollectionsFolder = await aFolder.createFolder(\"collections\"); folder.getEntry(filePath) ⇒ Promise. Returns a File or Folder entry for an item that already exists on disk within this folder or its hierarchy of subfolders. Fails if no entry with the given name/path currently exists on disk. Kind: instance method of Folder Returns: Promise. - the fetched entry. Since: XD 13 Param Type Description filePath string Name, with optional relative path prefix, of an existing entry within this folder Example const myNovel = await aFolder.getEntry(\"mynovel.txt\"); folder.renameEntry(entry, newName, options) ⇒ Promise Renames an item on disk to a new name within the same folder. The Entry object passed to this function is automatically updated to reference the new name, however any other Entry objects referencing the original item will not be updated, and will thus no longer point to an item that exists on disk. Kind: instance method of Folder Since: XD 13 Param Type Default Description entry Entry entry to rename (File or Folder). Must exist. newName string the new name to assign options any [options.overwrite] boolean false if true, renaming can overwrite an existing entry Example await myNovels.rename(myNovel, \"myFantasticNovel.txt\"); storage.localFileSystem : LocalFileSystemProvider Kind: static property of storage storage.errors : Errors Kind: static property of storage .errors : Errors .AbstractMethodInvocationError ⇐ Error .ProviderMismatchError ⇐ Error .EntryIsNotAnEntryError ⇐ Error .EntryIsNotAFolderError ⇐ Error .EntryIsNotAFileError ⇐ Error .NotAFileSystemError ⇐ Error .OutOfSpaceError ⇐ Error .PermissionDeniedError ⇐ Error .EntryExistsError ⇐ Error .FileIsReadOnlyError ⇐ Error .DomainNotSupportedError ⇐ Error .InvalidFileNameError ⇐ Error errors.AbstractMethodInvocationError ⇐ Error Attempted to invoke an abstract method. Kind: static class of errors Extends: Error errors.ProviderMismatchError ⇐ Error Attempted to execute a command that required the providers of all entries to match. Kind: static class of errors Extends: Error errors.EntryIsNotAnEntryError ⇐ Error The object passed as an entry is not actually an Entry. Kind: static class of errors Extends: Error errors.EntryIsNotAFolderError ⇐ Error The entry is not a folder, but was expected to be a folder. Kind: static class of errors Extends: Error errors.EntryIsNotAFileError ⇐ Error The entry is not a file, but was expected to be. Kind: static class of errors Extends: Error errors.NotAFileSystemError ⇐ Error The instance was expected to be a file system, but wasn't. Kind: static class of errors Extends: Error errors.OutOfSpaceError ⇐ Error The file system is out of space (or quota has been exceeded) Kind: static class of errors Extends: Error errors.PermissionDeniedError ⇐ Error The file system revoked permission to complete the requested action. Kind: static class of errors Extends: Error errors.EntryExistsError ⇐ Error An attempt was made to overwrite an entry without indicating that it was safe to do so via overwrite: true. Kind: static class of errors Extends: Error errors.FileIsReadOnlyError ⇐ Error An attempt was made to write to a file that was opened as read-only. Kind: static class of errors Extends: Error errors.DomainNotSupportedError ⇐ Error Domain is not supported by the current FileSystemProvider instance. Kind: static class of errors Extends: Error errors.InvalidFileNameError ⇐ Error The file name contains invalid characters Kind: static class of errors Extends: Error storage.fileTypes This namespace describes the various file type extensions that can used be used in some FS file open methods. Kind: static constant of storage .fileTypes .text .images .all fileTypes.text Text file extensions Kind: static property of fileTypes fileTypes.images Image file extensions Kind: static property of fileTypes fileTypes.all All file types Kind: static property of fileTypes storage.formats This namespace describes the file content formats supported in FS methods like read and write. Kind: static constant of storage .formats .utf8 : Symbol .binary : Symbol formats.utf8 : Symbol UTF8 File encoding Kind: static property of formats formats.binary : Symbol Binary file encoding Kind: static property of formats storage.modes This namespace describes the access modes that can be supported by a given File entry. Kind: static constant of storage .modes .readOnly : Symbol .readWrite : Symbol modes.readOnly : Symbol The file is read-only; attempts to write will fail. Kind: static property of modes modes.readWrite : Symbol The file is read-write. Kind: static property of modes storage.types This namespace describes the type of the entry. Whether file or folder etc. Kind: static constant of storage .types .file : Symbol .folder : Symbol types.file : Symbol A file; used when creating an entity Kind: static property of types types.folder : Symbol A folder; used when creating an entity Kind: static property of types "},"reference/uxp/class/Shell.html":{"url":"reference/uxp/class/Shell.html","title":"Shell","keywords":"","body":" Shell To get an instance: require(\"uxp\").shell shell.openExternal(url) Opens the url in an the system browser. Param Type url string or URL "},"reference/uxp/class/OS.html":{"url":"reference/uxp/class/OS.html","title":"OS","keywords":"","body":" OS See: https://nodejs.org/api/os.html OS .platform() .release() os.platform() Gets the platform we are running on (eg. \"win10\", \"darwin\") Returns: string - the string representing the platform os.release() Gets the release number of the os (eg. \"10.0.1.1032\") Returns: string - the string representing the release "},"reference/uxp/ui-index.html":{"url":"reference/uxp/ui-index.html","title":"UI APIs","keywords":"","body":"User interface Reference See the following references: HTML CSS Events "},"reference/uxp/namespace/css.html":{"url":"reference/uxp/namespace/css.html","title":"CSS support","keywords":"","body":" css : object Kind: global namespace css : object .color .border-top-color .border-left-color .border-right-color .border-bottom-color .background-color .border-top .border-left .border-right .border-bottom .border-top-style .border-left-style .border-right-style .border-bottom-style .border-top-left-radius .border-top-right-radius .border-bottom-left-radius .border-bottom-right-radius .opacity : float .overflow .overflow-x .overflow-y .background-image .border-color .border-radius .border-radius .background .margin-top .margin-left .margin-right .margin-bottom .width .height .max-width .max-height .min-width .min-height .top .left .right .bottom .padding-top .padding-left .padding-right .padding-bottom .border-top-width .border-left-width .border-right-width .border-bottom-width .flex-basis .flex-grow .flex-shrink .order .flex .border-width .margin .padding .font-family .letter-spacing .font-size .align-content .align-items .align-self .units .background-attachment .background-repeat .background-size .border-style .display .flex-direction .flex-wrap .font-style .font-weight .justify-content .position .text-align .text-overflow .visibility .white-space css.color Specifies the text color for an element. Supported color formats are as follows: Named Colors (See https://github.com/colorjs/color-name/blob/master/index.js) Hex colors RGB and RGBA colors HSL and HSLA colors Kind: static property of cssSee https://developer.mozilla.org/en/docs/Web/CSS/color https://github.com/colorjs/color-name/blob/master/index.js css.border-top-color Specifies the border color for an element's top border. Supported color formats are as follows: Named Colors (See https://github.com/colorjs/color-name/blob/master/index.js) Hex colors RGB and RGBA colors An element's border can only consist of a single color. If you specify multiple border colors, you'll see a warning on the JavaScript console. Kind: static property of cssSee https://developer.mozilla.org/en/docs/Web/CSS/border-top-color https://github.com/colorjs/color-name/blob/master/index.js css.border-left-color Specifies the border color for an element's left border. Supported color formats are as follows: Named Colors (See https://github.com/colorjs/color-name/blob/master/index.js) Hex colors RGB and RGBA colors An element's border can only consist of a single color. If you specify multiple border colors, you'll see a warning on the JavaScript console. Kind: static property of cssSee https://developer.mozilla.org/en/docs/Web/CSS/border-left-color https://github.com/colorjs/color-name/blob/master/index.js css.border-right-color Specifies the border color for an element's right border. Supported color formats are as follows: Named Colors (See https://github.com/colorjs/color-name/blob/master/index.js) Hex colors RGB and RGBA colors An element's border can only consist of a single color. If you specify multiple border colors, you'll see a warning on the JavaScript console. Kind: static property of cssSee https://developer.mozilla.org/en/docs/Web/CSS/border-right-color https://github.com/colorjs/color-name/blob/master/index.js css.border-bottom-color Specifies the border color for an element's bottom border. Supported color formats are as follows: Named Colors (See https://github.com/colorjs/color-name/blob/master/index.js) Hex colors RGB and RGBA colors An element's border can only consist of a single color. If you specify multiple border colors, you'll see a warning on the JavaScript console. Kind: static property of cssSee https://developer.mozilla.org/en/docs/Web/CSS/border-bottom-color https://github.com/colorjs/color-name/blob/master/index.js css.background-color Specifies the background color for an element. Supported color formats are as follows: Named Colors (See https://github.com/colorjs/color-name/blob/master/index.js) Hex colors RGB and RGBA colors HSL and HSLA colors Kind: static property of cssSee https://developer.mozilla.org/en/docs/Web/CSS/background-color https://github.com/colorjs/color-name/blob/master/index.js css.border-top Shorthand for specifying the style, color, and width of the top border. An element's border can only consist of a single color. If you specify multiple border colors, you'll see a warning on the JavaScript console. The only visible border style that is supported is solid. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-top css.border-left Shorthand for specifying the style, color, and width of the left border. An element's border can only consist of a single color. If you specify multiple border colors, you'll see a warning on the JavaScript console. The only visible border style that is supported is solid. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-left css.border-right Shorthand for specifying the style, color, and width of the right border. An element's border can only consist of a single color. If you specify multiple border colors, you'll see a warning on the JavaScript console. The only visible border style that is supported is solid. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-right css.border-bottom Shorthand for specifying the style, color, and width of the bottom border. An element's border can only consist of a single color. If you specify multiple border colors, you'll see a warning on the JavaScript console. The only visible border style that is supported is solid. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-bottom css.border-top-style Specifies the style of the top border. The only visible border style that is supported is solid. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-top-style css.border-left-style Specifies the style of the left border. The only visible border style that is supported is solid. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-left-style css.border-right-style Specifies the style of the right border. The only visible border style that is supported is solid. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-right-style css.border-bottom-style Specifies the style of the bottom border. The only visible border style that is supported is solid. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-bottom-style css.border-top-left-radius Sets the top left border radius. If you need to clip an image, be sure to set overflow: hidden. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-top-left-radius css.border-top-right-radius Sets the top right border radius. If you need to clip an image, be sure to set overflow: hidden. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-top-right-radius css.border-bottom-left-radius Sets the bottom left border radius. If you need to clip an image, be sure to set overflow: hidden. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-bottom-left-radius css.border-bottom-right-radius Sets the bottom right border radius. If you need to clip an image, be sure to set overflow: hidden. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-bottom-right-radius css.opacity : float Sets the opacity of an element. The value is between 0 (transparent) and 1 (opaque). Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/opacity css.overflow Shorthand which determines what is done with content that overflows the element's bounds. Supports visible, hidden,auto, andscroll`. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/overflow css.overflow-x Determines what is done with content that overflows the element's horizontal bounds. Supports visible, hidden,auto, andscroll`. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/overflow-x css.overflow-y Determines what is done with content that overflows the element's vertical bounds. Supports visible, hidden,auto, andscroll`. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/overflow-y css.background-image Specifies a background image. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/background-image css.border-color Specifies the border color for an element. Supported color formats are as follows: Named Colors (See https://github.com/colorjs/color-name/blob/master/index.js) Hex colors RGB and RGBA colors An element's border can only consist of a single color. If you specify multiple border colors, you'll see a warning on the JavaScript console. Kind: static property of cssSee https://developer.mozilla.org/en/docs/Web/CSS/border-color https://github.com/colorjs/color-name/blob/master/index.js css.border-radius Shorthand for specifying the border radius Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-radius css.border-radius Shorthand for specifying the border width, color, and style. Supported color formats are as follows: Named Colors (See https://github.com/colorjs/color-name/blob/master/index.js) Hex colors RGB and RGBA colors An element's border can only consist of a single color. If you specify multiple border colors, you'll see a warning on the JavaScript console. Kind: static property of cssSee https://developer.mozilla.org/en/docs/Web/CSS/border-radius https://github.com/colorjs/color-name/blob/master/index.js css.background Shorthand for specifying the background of an element. Supports colors, images, and linear gradients. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/background css.margin-top Specifies the top margin. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/margin-top css.margin-left Specifies the left margin. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/margin-left css.margin-right Specifies the right margin. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/margin-right css.margin-bottom Specifies the bottom margin. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/margin-bottom css.width Specifies the width of an element. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/width css.height Specifies the height of an element. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/height css.max-width Specifies the maximum width of an element. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/max-width css.max-height Specifies the maximum height of an element. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/max-height css.min-width Specifies the minimum width of an element. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/min-width css.min-height Specifies the minimum height of an element. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/min-height css.top Sets the top position of the element when relatively or absolutely positioned. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/top css.left Sets the left position of the element when relatively or absolutely positioned. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/left css.right Sets the right position of the element when relatively or absolutely positioned. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/right css.bottom Sets the bottom position of the element when relatively or absolutely positioned. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/bottom css.padding-top Specifies the top padding. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/padding-top css.padding-left Specifies the left padding. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/padding-left css.padding-right Specifies the right padding. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/padding-right css.padding-bottom Specifies the bottom padding. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/padding-bottom css.border-top-width Specifies the width of the top border. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-top-width css.border-left-width Specifies the width of the left border. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-left-width css.border-right-width Specifies the width of the right border. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-right-width css.border-bottom-width Specifies the width of the bottom border. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-bottom-width css.flex-basis Specifies the value used for calculating the flex basis. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/flex-basis css.flex-grow Sets the flex grow factor. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/flex-grow css.flex-shrink Sets the flex shrink factor. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/flex-shrink css.order Sets the order of display for this flex element. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/order css.flex Shorthand for setting flex-grow, flex-shrink, and flex-basis. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/flex css.border-width Specifies the width of the element's border. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/border-width css.margin Shorthand for setting the element's margins. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/margin css.padding Shorthand for setting the element's padding. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/padding css.font-family Renders the element using the specified font family, if installed on the user's machine. Fallbacks are not supported. Don't use quotes with this value. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/font-family css.letter-spacing Sets the distance between letters. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/letter-spacing css.font-size Sets the font size. Kind: static property of cssSee: https://developer.mozilla.org/en/docs/Web/CSS/font-size css.align-content Kind: static enum of cssProperties Name Default Description \"flex-start\" 0 Align to the starting position \"flex-end\" 1 Align to the ending position center 2 Align to the center \"space-between\" 3 Add space between the elements \"space-around\" 4 Add space around the elements stretch 5 Stretch content css.align-items Kind: static enum of cssProperties Name Default Description \"flex-start\" 0 Align items to the start \"flex-end\" 1 Align items to the end center 2 Align items to the center baseline 3 Align items to baseline (UNSUPPORTED) stretch 4 Stretch items css.align-self Kind: static enum of cssProperties Name Default Description auto 0 \"flex-start\" 1 Align to start \"flex-end\" 2 Align to end center 3 Align to center baseline 4 Align to baseline (UNSUPPORTED) stretch 5 Stretch css.units Kind: static enum of cssProperties Name Default Description px 0 Pixel units (default) \"%\" 1 Percentage css.background-attachment Kind: static enum of cssProperties Name Default Description scroll 0 The background image scrolls along with content. Default. fixed 1 The background image is fixed while scrolling. UNSUPPORTED. local 2 UNSUPPORTED. css.background-repeat Kind: static enum of cssProperties Name Default Description \"no-repeat\" 0 Don't repeat the background image; default. repeat 1 Repeat the background image in both axes. UNSUPPORTED. \"repeat-x\" 2 Repeat the background image in horizontally. UNSUPPORTED. \"repeat-y\" 3 Repeat the background image in vertically. UNSUPPORTED. css.background-size Kind: static enum of cssProperties Name Default Description auto 0 Automatically size the background image; default. contain 1 Contain the image within the bounds of the element without altering the aspect ratio. cover 2 Ensure that the image fills the bounds of the element without altering the aspect ratio. css.border-style Kind: static enum of cssProperties Name Default Description none 0 No border hidden 1 Hidden border dotted 2 Dotted border; UNSUPPORTED dashed 3 Dashed border; UNSUPPORTED solid 4 Solid border double 5 Double border; UNSUPPORTED groove 6 Grooved border; UNSUPPORTED ridge 7 Ridged border; UNSUPPORTED inset 8 Inset border; UNSUPPORTED outset 9 Outset border; UNSUPPORTED css.display Kind: static enum of cssProperties Name Default Description none 0 Don't display the item; removes from layout. flex 1 Display using flexbox layout. block 2 Display using block layout; default. inline 3 Display using inline layout; UNSUPPORTED. \"inline-block\" 4 Display using inline-block layout; UNSUPPORTED. \"inline-flex\" 5 Display using inline-flex layout; UNSUPPORTED. css.flex-direction Kind: static enum of cssProperties Name Default Description row 0 Layout in a horizontal (row) direction \"row-reverse\" 1 Layout in a horizontal (row) direction, but reverse the order of elements column 2 layout in a vertical (column) direction \"column-reverse\" 3 layout in a vertical (column) direction, but reverse the order of elements css.flex-wrap Kind: static enum of cssProperties Name Default Description nowrap 0 Don't wrap; default. wrap 1 Wrap \"wrap-reverse\" 2 Wrap, reverse; UNSUPPORTED. css.font-style Kind: static enum of cssProperties Name Default Description normal 0 Normal font style; default. italic 1 Italic (if the font supports it). css.font-weight Kind: static enum of cssProperties Name Default Description normal 0 Normal font weight; default. bold 1 Bold font weight. lighter 2 Lighter font weight. bolder 3 Bolder font weight. 50 4 100 5 200 6 300 7 400 8 500 9 550 10 600 11 700 12 800 13 850 14 900 15 950 16 1000 17 css.justify-content Kind: static enum of cssProperties Name Default Description \"flex-start\" 0 Justify content to the end \"flex-end\" 1 Align content to the end center 2 Align content to the center \"space-between\" 3 Add space between elements \"space-around\" 4 Add space around elements css.position Kind: static enum of cssProperties Name Default Description static 0 Positioned using normal layout rules; default. absolute 1 Element is positioned absolutely, relative to its nearest positioned ancestor. Does not affect layout. relative 2 Element is positioned relative to where it would have been positioned when using static. css.text-align Kind: static enum of cssProperties Name Default Description left 0 Left align center 1 Center right 2 Right align justify 3 Justify; UNSUPPORTED css.text-overflow Kind: static enum of cssProperties Name Default Description clip 0 Clip text content; default. ellipsis 1 Show an ellipsis. css.visibility Kind: static enum of cssProperties Name Default Description visible 0 Show the element; default. hidden 1 Hide the element. Layout is unaffected, so space is reserved for the element. css.white-space Kind: static enum of cssProperties Name Default Description normal 0 Allow wrapping. Default. nowrap 1 Prevent breaking on white space. "},"reference/uxp/ui-classes-index.html":{"url":"reference/uxp/ui-classes-index.html","title":"Classes","keywords":"","body":"UI Classes Attr CharacterData Clipboard Comment CSSRule CSSRuleList CSSStyleDeclaration CSSStyleRule CSSStyleSheet Document DocumentFragment DOMException DOMTokenList NamedNodeMap Node NodeList StyleSheet StyleSheetList Text "},"reference/uxp/class/Attr.html":{"url":"reference/uxp/class/Attr.html","title":"Attr","keywords":"","body":" Attr Extends: Node See: https://developer.mozilla.org/en-US/docs/Web/API/Attr Attr new Attr(document, nodeName) .nodeName : string .localName : string .name : string .specified : boolean .value : * .nodeType : number .nodeValue : * .ownerElement : Element .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .attributes .remove() .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new Attr(document, nodeName) Creates an instance of Attr. Param Type document Document nodeName string attr.nodeName : string Read only attr.localName : string Read only attr.name : string Read only attr.specified : boolean Read only attr.value : * attr.nodeType : number Read only attr.nodeValue : * attr.ownerElement : Element Read only attr.contentEditable Read only attr.isConnected : boolean Read only attr.parentNode : Node Read only attr.parentElement : Element Read only attr.firstChild : Node Read only attr.lastChild : Node Read only attr.previousSibling : Node Read only attr.nextSibling : Node Read only attr.firstElementChild : Node Read only attr.lastElementChild : Node Read only attr.previousElementSibling : Node Read only attr.nextElementSibling : Node Read only attr.textContent : string attr.childNodes : NodeList Read only attr.children : HTMLCollection Read only attr.ownerDocument Read only attr.attributes Read only attr.remove() Overrides: remove attr.hasChildNodes() attr.cloneNode(deep) Param Type deep boolean attr.appendChild(child) Param Type child Node attr.insertBefore(child, before) Param Type child Node before Node attr.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node attr.removeChild(child) Param Type child Node attr.before(...nodes) Param Type ...nodes Array. attr.after(...nodes) Param Type ...nodes Array. attr.replaceWith(...nodes) Param Type ...nodes Array. attr.contains(node) Param Type node Node attr.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false attr.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false attr.dispatchEvent(event) Param Type event * "},"reference/uxp/class/CharacterData.html":{"url":"reference/uxp/class/CharacterData.html","title":"CharacterData","keywords":"","body":" CharacterData Extends: Node See: https://developer.mozilla.org/en-US/docs/Web/API/CharacterData CharacterData new CharacterData(document, textContent) .data : string .textContent : string .nodeValue : string .length : number .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .childNodes : NodeList .children : HTMLCollection .ownerDocument .attributes .substringData(offset, count) .appendData(arg) .insertData(offset, arg) .deleteData(offset, count) .replaceData(offset, count, arg) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new CharacterData(document, textContent) Creates an instance of CharacterData. Param Type document * textContent * characterData.data : string characterData.textContent : string Overrides: textContent characterData.nodeValue : string characterData.length : number Read only characterData.contentEditable Read only characterData.isConnected : boolean Read only characterData.parentNode : Node Read only characterData.parentElement : Element Read only characterData.firstChild : Node Read only characterData.lastChild : Node Read only characterData.previousSibling : Node Read only characterData.nextSibling : Node Read only characterData.firstElementChild : Node Read only characterData.lastElementChild : Node Read only characterData.previousElementSibling : Node Read only characterData.nextElementSibling : Node Read only characterData.childNodes : NodeList Read only characterData.children : HTMLCollection Read only characterData.ownerDocument Read only characterData.attributes Read only characterData.substringData(offset, count) Param Type offset * count * characterData.appendData(arg) Param Type arg string characterData.insertData(offset, arg) Param Type offset number arg string characterData.deleteData(offset, count) Param Type offset number count number characterData.replaceData(offset, count, arg) Param Type offset number count number arg string characterData.hasChildNodes() characterData.cloneNode(deep) Param Type deep boolean characterData.appendChild(child) Param Type child Node characterData.insertBefore(child, before) Param Type child Node before Node characterData.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node characterData.removeChild(child) Param Type child Node characterData.remove() characterData.before(...nodes) Param Type ...nodes Array. characterData.after(...nodes) Param Type ...nodes Array. characterData.replaceWith(...nodes) Param Type ...nodes Array. characterData.contains(node) Param Type node Node characterData.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false characterData.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false characterData.dispatchEvent(event) Param Type event * "},"reference/uxp/class/Clipboard.html":{"url":"reference/uxp/class/Clipboard.html","title":"Clipboard","keywords":"","body":"ERROR, Cannot find class. "},"reference/uxp/class/Comment.html":{"url":"reference/uxp/class/Comment.html","title":"Comment","keywords":"","body":" Comment Extends: CharacterData See: https://developer.mozilla.org/en-US/docs/Web/API/Comment Comment new Comment(document, comment) .nodeName : string .nodeType : number .data : string .textContent : string .nodeValue : string .length : number .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .childNodes : NodeList .children : HTMLCollection .ownerDocument .attributes .substringData(offset, count) .appendData(arg) .insertData(offset, arg) .deleteData(offset, count) .replaceData(offset, count, arg) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new Comment(document, comment) Creates an instance of Comment. Param Type document Document comment string comment.nodeName : string Read only comment.nodeType : number Read only comment.data : string comment.textContent : string comment.nodeValue : string comment.length : number Read only comment.contentEditable Read only comment.isConnected : boolean Read only comment.parentNode : Node Read only comment.parentElement : Element Read only comment.firstChild : Node Read only comment.lastChild : Node Read only comment.previousSibling : Node Read only comment.nextSibling : Node Read only comment.firstElementChild : Node Read only comment.lastElementChild : Node Read only comment.previousElementSibling : Node Read only comment.nextElementSibling : Node Read only comment.childNodes : NodeList Read only comment.children : HTMLCollection Read only comment.ownerDocument Read only comment.attributes Read only comment.substringData(offset, count) Param Type offset * count * comment.appendData(arg) Param Type arg string comment.insertData(offset, arg) Param Type offset number arg string comment.deleteData(offset, count) Param Type offset number count number comment.replaceData(offset, count, arg) Param Type offset number count number arg string comment.hasChildNodes() comment.cloneNode(deep) Param Type deep boolean comment.appendChild(child) Param Type child Node comment.insertBefore(child, before) Param Type child Node before Node comment.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node comment.removeChild(child) Param Type child Node comment.remove() comment.before(...nodes) Param Type ...nodes Array. comment.after(...nodes) Param Type ...nodes Array. comment.replaceWith(...nodes) Param Type ...nodes Array. comment.contains(node) Param Type node Node comment.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false comment.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false comment.dispatchEvent(event) Param Type event * "},"reference/uxp/class/CSSRule.html":{"url":"reference/uxp/class/CSSRule.html","title":"CSSRule","keywords":"","body":" CSSRule Category: browser, cssom See: https://developer.mozilla.org/en-US/docs/Web/API/CSSRule "},"reference/uxp/class/CSSRuleList.html":{"url":"reference/uxp/class/CSSRuleList.html","title":"CSSRuleList","keywords":"","body":" CSSRuleList Category: browser, cssom See: https://developer.mozilla.org/en-US/docs/Web/API/CSSRuleList CSSRuleList .length : number .item(index) cssRuleList.length : number The number of rules in this list Read only cssRuleList.item(index) Return the rule at the specified index Param Type index number "},"reference/uxp/class/CSSStyleDeclaration.html":{"url":"reference/uxp/class/CSSStyleDeclaration.html","title":"CSSStyleDeclaration","keywords":"","body":" CSSStyleDeclaration Category: browser, cssom See: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration CSSStyleDeclaration .length .parentRule : CSSStyleRule .item(index) .getPropertyValue(property) .setProperty(property, value, [priority]) .removeProperty(property) cssStyleDeclaration.length Number of properties in this style declaration Read only cssStyleDeclaration.parentRule : CSSStyleRule Get the parent style rule Read only cssStyleDeclaration.item(index) Return the property name at the specified index. Param Type index number cssStyleDeclaration.getPropertyValue(property) Returns the value of the specified property Param Type property DOMString cssStyleDeclaration.setProperty(property, value, [priority]) Set the property value Param Type Default property DOMString value DOMString [priority] string \"\" cssStyleDeclaration.removeProperty(property) Remove the specified property Param Type property DOMString "},"reference/uxp/class/CSSStyleRule.html":{"url":"reference/uxp/class/CSSStyleRule.html","title":"CSSStyleRule","keywords":"","body":" CSSStyleRule Extends: CSSRule Category: browser, cssom See: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleRule CSSStyleRule .type .selectorText : string .style : CSSStyleDeclaration .parentStyleSheet : CSSStyleSheet cssStyleRule.type Returns the type of the CSS Rule Read only cssStyleRule.selectorText : string Selector text cssStyleRule.style : CSSStyleDeclaration Get the style declaration itself Read only cssStyleRule.parentStyleSheet : CSSStyleSheet Get the parent style sheet Read only "},"reference/uxp/class/CSSStyleSheet.html":{"url":"reference/uxp/class/CSSStyleSheet.html","title":"CSSStyleSheet","keywords":"","body":" CSSStyleSheet Extends: StyleSheet Category: browser, cssom See: https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleSheet CSSStyleSheet new CSSStyleSheet() .cssRules : CSSRuleList .rules : CSSRuleList .href : DOMString .type : DOMString .insertRule(rule, [index]) .deleteRule(index) new CSSStyleSheet() Represents a CSS style sheet cssStyleSheet.cssRules : CSSRuleList Return the list of CSS Rules Read only cssStyleSheet.rules : CSSRuleList Return the list of CSS Rules Read only cssStyleSheet.href : DOMString Read only cssStyleSheet.type : DOMString Default: undefined Read only cssStyleSheet.insertRule(rule, [index]) Insert a CSS Rule at the specified index. Param Type Default rule * [index] number 0 cssStyleSheet.deleteRule(index) Delete the rule at the specified index Param Type index * "},"reference/uxp/class/Document.html":{"url":"reference/uxp/class/Document.html","title":"Document","keywords":"","body":" Document Extends: Node See: https://developer.mozilla.org/en-US/docs/Web/API/Document Document new Document() .onLine : boolean .nodeName : string .nodeType : number .uxpContainer .activeElement : Node .documentElement : Document .head : HTMLHeadElement .body : HTMLBodyElement .clipboard : Clippoard .styleSheets : StyleSheetList .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .attributes .createElement(nodeName) .createElementNS(ns, nodeName) .createAttribute(nodeName) .createTextNode([text]) .createComment([comment]) .createDocumentFragment() .cloneNode(deep) .adoptNode(externalNode, deep) .importNode(externalNode, deep) .querySelector(selector) .querySelectorAll(selector) .getElementsByClassName(name) .getElementsByTagName(name) .getElementById(id) .hasChildNodes() .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new Document() Creates an instance of Document. document.onLine : boolean Indicates if the computer is online Read only document.nodeName : string Read only document.nodeType : number Read only document.uxpContainer document.activeElement : Node Read only document.documentElement : Document Read only document.head : HTMLHeadElement Read only document.body : HTMLBodyElement Read only document.clipboard : Clippoard Read only document.styleSheets : StyleSheetList Read only document.contentEditable Read only document.isConnected : boolean Read only document.parentNode : Node Read only document.parentElement : Element Read only document.firstChild : Node Read only document.lastChild : Node Read only document.previousSibling : Node Read only document.nextSibling : Node Read only document.firstElementChild : Node Read only document.lastElementChild : Node Read only document.previousElementSibling : Node Read only document.nextElementSibling : Node Read only document.textContent : string document.childNodes : NodeList Read only document.children : HTMLCollection Read only document.ownerDocument Read only document.attributes Read only document.createElement(nodeName) Param Type nodeName string document.createElementNS(ns, nodeName) Param Type ns string nodeName string document.createAttribute(nodeName) Param Type nodeName string document.createTextNode([text]) Param Type Default [text] string \"\" document.createComment([comment]) Param Type Default [comment] string \"\" document.createDocumentFragment() document.cloneNode(deep) Overrides: cloneNode Param Type deep boolean document.adoptNode(externalNode, deep) Param Type externalNode Node deep boolean document.importNode(externalNode, deep) Param Type externalNode Node deep boolean document.querySelector(selector) Param Type selector string document.querySelectorAll(selector) Param Type selector string document.getElementsByClassName(name) Param Type name string document.getElementsByTagName(name) Param Type name string document.getElementById(id) Param Type id string document.hasChildNodes() document.appendChild(child) Param Type child Node document.insertBefore(child, before) Param Type child Node before Node document.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node document.removeChild(child) Param Type child Node document.remove() document.before(...nodes) Param Type ...nodes Array. document.after(...nodes) Param Type ...nodes Array. document.replaceWith(...nodes) Param Type ...nodes Array. document.contains(node) Param Type node Node document.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false document.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false document.dispatchEvent(event) Param Type event * "},"reference/uxp/class/DocumentFragment.html":{"url":"reference/uxp/class/DocumentFragment.html","title":"DocumentFragment","keywords":"","body":" DocumentFragment Extends: Node See: https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment DocumentFragment .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .attributes .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) documentFragment.contentEditable Read only documentFragment.isConnected : boolean Read only documentFragment.parentNode : Node Read only documentFragment.parentElement : Element Read only documentFragment.firstChild : Node Read only documentFragment.lastChild : Node Read only documentFragment.previousSibling : Node Read only documentFragment.nextSibling : Node Read only documentFragment.firstElementChild : Node Read only documentFragment.lastElementChild : Node Read only documentFragment.previousElementSibling : Node Read only documentFragment.nextElementSibling : Node Read only documentFragment.textContent : string documentFragment.childNodes : NodeList Read only documentFragment.children : HTMLCollection Read only documentFragment.ownerDocument Read only documentFragment.attributes Read only documentFragment.hasChildNodes() documentFragment.cloneNode(deep) Param Type deep boolean documentFragment.appendChild(child) Param Type child Node documentFragment.insertBefore(child, before) Param Type child Node before Node documentFragment.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node documentFragment.removeChild(child) Param Type child Node documentFragment.remove() documentFragment.before(...nodes) Param Type ...nodes Array. documentFragment.after(...nodes) Param Type ...nodes Array. documentFragment.replaceWith(...nodes) Param Type ...nodes Array. documentFragment.contains(node) Param Type node Node documentFragment.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false documentFragment.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false documentFragment.dispatchEvent(event) Param Type event * "},"reference/uxp/class/DOMException.html":{"url":"reference/uxp/class/DOMException.html","title":"DOMException","keywords":"","body":"ERROR, Cannot find class. "},"reference/uxp/class/DOMTokenList.html":{"url":"reference/uxp/class/DOMTokenList.html","title":"DOMTokenList","keywords":"","body":" DOMTokenList DOMTokenList supports the ClassList and other token list functionality See https://dom.spec.whatwg.org/#interface-domtokenlist https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList DOMTokenList .length .value .add(...tokens) .remove(...tokens) .replace(oldToken, newToken) .toggle(token, force) .item(index) .contains(token) .supports(token) domTokenList.length Returns the number of tokens in the list Read only See: https://dom.spec.whatwg.org/#dom-domtokenlist-length domTokenList.value The serialized string value of the token list Read only See: https://dom.spec.whatwg.org/#dom-domtokenlist-value domTokenList.add(...tokens) Adds the specified tokens to the token list. If the token is already present, no error is thrown. Throws: DOMException See: https://dom.spec.whatwg.org/#dom-domtokenlist-add Param Type ...tokens string domTokenList.remove(...tokens) Removes the specified items from the token list. If the token is not present, no error is thrown. Throws: DOMException See: https://dom.spec.whatwg.org/#dom-domtokenlist-remove Param Type ...tokens string domTokenList.replace(oldToken, newToken) Replaces an old token with a new token. If the old token doesn't exist, no action occurs, and false is returned. Throws: DOMException See: https://dom.spec.whatwg.org/#dom-domtokenlist-replace Param Type oldToken any newToken any domTokenList.toggle(token, force) Toggles a token within the list. If force is not present, then the following rules are applied: if the token is present, it is removed, and false is returned if the token isn't present, it is added, and true is returned If force is supplied, then: if true, the token is added if false, the token is removed Returns: boolean - if the token exists in the last after the operation Throws: DOMException See: https://dom.spec.whatwg.org/#dom-domtokenlist-toggle Param Type token string force boolean domTokenList.item(index) Return the item at the specified index, or null if the index is out-of-range Returns: string - the item at the index, or null if index is out of range Throws: DOMException See: https://dom.spec.whatwg.org/#dom-domtokenlist-item Param Type index number domTokenList.contains(token) Returns whether the token is in the list or not. Returns: boolean - if true, the token is in the list, otherwise it isn't Throws: DOMException See: https://dom.spec.whatwg.org/#dom-domtokenlist-contains Param Type token any domTokenList.supports(token) Returns true if the token is acceptable to the list; otherwise returns false. If false is returned, passing the token would throw an error when calling any other method. Returns: boolean - if true, the token is acceptable when calling other methods See: https://dom.spec.whatwg.org/#dom-domtokenlist-supports Param Type token string "},"reference/uxp/class/Element.html":{"url":"reference/uxp/class/Element.html","title":"Element","keywords":"","body":" Element Extends: Node See: https://developer.mozilla.org/en-US/docs/Web/API/Element Element new Element(document, nodeName, namespaceURI) .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new Element(document, nodeName, namespaceURI) Creates an instance of Element. Param Type document * nodeName * namespaceURI * element.nodeName : string Read only element.localName : string Read only element.tagName : string Read only element.nodeType : number Read only element.namespaceURI : string Read only element.id : string element.tabIndex : number element.className : string element.attributes : NamedNodeMap Overrides: attributes Read only element.style : Style Read only element.clientLeft : number Read only element.clientTop : number Read only element.clientWidth : number Read only element.clientHeight : number Read only element.height : string or Number The height of the element element.width : string or Number The width of the element element.offsetParent : Element Read only element.offsetLeft : number Read only element.offsetTop : number Read only element.offsetWidth : number Read only element.offsetHeight : number Read only element.scrollLeft : number element.scrollTop : number element.scrollWidth : number Read only element.scrollHeight : number Read only element.uxpContainer : UXPContainer Read only element.disabled : boolean element.innerHTML : string element.outerHTML : string element.contentEditable Read only element.isConnected : boolean Read only element.parentNode : Node Read only element.parentElement : Element Read only element.firstChild : Node Read only element.lastChild : Node Read only element.previousSibling : Node Read only element.nextSibling : Node Read only element.firstElementChild : Node Read only element.lastElementChild : Node Read only element.previousElementSibling : Node Read only element.nextElementSibling : Node Read only element.textContent : string element.childNodes : NodeList Read only element.children : HTMLCollection Read only element.ownerDocument Read only element.scrollIntoView() element.scrollIntoViewIfNeeded() element.focus() element.blur() element.getAttribute(name) Param Type name string element.setAttribute(name, value) Param Type name string value string element.removeAttribute(name) Param Type name string element.hasAttribute(name) Param Type name string element.getAttributeNode(name) Param Type name string element.setAttributeNode(newAttr) Param Type newAttr * element.removeAttributeNode(oldAttr) Param Type oldAttr * element.click() element.getElementsByClassName(name) Param Type name string element.getElementsByTagName(name) Param Type name string element.querySelector(selector) Param Type selector string element.querySelectorAll(selector) Param Type selector string element.getBoundingClientRect() element.insertAdjacentHTML(position, value) Param Type position value string element.insertAdjacentElement(position, node) Param Type position * node * element.insertAdjacentText(position, text) Param Type position * text * element.hasChildNodes() element.cloneNode(deep) Param Type deep boolean element.appendChild(child) Param Type child Node element.insertBefore(child, before) Param Type child Node before Node element.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node element.removeChild(child) Param Type child Node element.remove() element.before(...nodes) Param Type ...nodes Array. element.after(...nodes) Param Type ...nodes Array. element.replaceWith(...nodes) Param Type ...nodes Array. element.contains(node) Param Type node Node element.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false element.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false element.dispatchEvent(event) Param Type event * "},"reference/uxp/class/NamedNodeMap.html":{"url":"reference/uxp/class/NamedNodeMap.html","title":"NamedNodeMap","keywords":"","body":" NamedNodeMap See: https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap NamedNodeMap new NamedNodeMap(node) .length : number .getNamedItem(name) .setNamedItem(attr) .removeNamedItem(name) .item(index) new NamedNodeMap(node) Creates an instance of NamedNodeMap. Param Type node Node namedNodeMap.length : number Read only namedNodeMap.getNamedItem(name) Param Type name * namedNodeMap.setNamedItem(attr) Param Type attr * namedNodeMap.removeNamedItem(name) Param Type name * namedNodeMap.item(index) Param Type index * "},"reference/uxp/class/Node.html":{"url":"reference/uxp/class/Node.html","title":"Node","keywords":"","body":" Node Extends: EventTarget See: https://developer.mozilla.org/en-US/docs/Web/API/Node Node new Node(ownerDocument) instance .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .attributes .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) static .ELEMENT_NODE .ATTRIBUTE_NODE .TEXT_NODE .DOCUMENT_NODE .DOCUMENT_FRAGMENT_NODE .COMMENT_NODE new Node(ownerDocument) Creates an instance of Node. Param Type ownerDocument * node.contentEditable Read only node.isConnected : boolean Read only node.parentNode : Node Read only node.parentElement : Element Read only node.firstChild : Node Read only node.lastChild : Node Read only node.previousSibling : Node Read only node.nextSibling : Node Read only node.firstElementChild : Node Read only node.lastElementChild : Node Read only node.previousElementSibling : Node Read only node.nextElementSibling : Node Read only node.textContent : string node.childNodes : NodeList Read only node.children : HTMLCollection Read only node.ownerDocument Read only node.attributes Read only node.hasChildNodes() node.cloneNode(deep) Param Type deep boolean node.appendChild(child) Param Type child Node node.insertBefore(child, before) Param Type child Node before Node node.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node node.removeChild(child) Param Type child Node node.remove() node.before(...nodes) Param Type ...nodes Array. node.after(...nodes) Param Type ...nodes Array. node.replaceWith(...nodes) Param Type ...nodes Array. node.contains(node) Param Type node Node node.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false node.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false node.dispatchEvent(event) Param Type event * Node.ELEMENT_NODE Node.ATTRIBUTE_NODE Node.TEXT_NODE Node.DOCUMENT_NODE Node.DOCUMENT_FRAGMENT_NODE Node.COMMENT_NODE "},"reference/uxp/class/NodeList.html":{"url":"reference/uxp/class/NodeList.html","title":"NodeList","keywords":"","body":" NodeList See: https://developer.mozilla.org/en-US/docs/Web/API/NodeList NodeList new NodeList(staticList, updater) .length : number .item(index) .keys() .values() .entries() .forEach(callback) new NodeList(staticList, updater) Creates an instance of NodeList. Param Type staticList * updater * nodeList.length : number Read only nodeList.item(index) Param Type index number nodeList.keys() nodeList.values() nodeList.entries() nodeList.forEach(callback) Param Type callback * "},"reference/uxp/class/StyleSheet.html":{"url":"reference/uxp/class/StyleSheet.html","title":"StyleSheet","keywords":"","body":" StyleSheet Category: browser, cssom See: https://developer.mozilla.org/en-US/docs/Web/API/StyleSheet StyleSheet new StyleSheet() .href : DOMString .type : DOMString new StyleSheet() Represents a single style sheet. INCOMPLETE styleSheet.href : DOMString Read only styleSheet.type : DOMString Default: undefined Read only "},"reference/uxp/class/StyleSheetList.html":{"url":"reference/uxp/class/StyleSheetList.html","title":"StyleSheetList","keywords":"","body":" StyleSheetList Category: browser, cssom See: https://developer.mozilla.org/en-US/docs/Web/API/StyleSheetList StyleSheetList new StyleSheetList() .length : number .item(index) new StyleSheetList() An array-like list of stylesheets. styleSheetList.length : number The number of stylesheets Read only styleSheetList.item(index) Return the stylesheet at the specified index Param Type index number "},"reference/uxp/class/Text.html":{"url":"reference/uxp/class/Text.html","title":"Text","keywords":"","body":" Text Extends: CharacterData See: https://developer.mozilla.org/en-US/docs/Web/API/Text Text new Text(document, textContent) .nodeName : string .nodeType : number .data : string .textContent : string .nodeValue : string .length : number .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .childNodes : NodeList .children : HTMLCollection .ownerDocument .attributes .substringData(offset, count) .appendData(arg) .insertData(offset, arg) .deleteData(offset, count) .replaceData(offset, count, arg) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new Text(document, textContent) Creates an instance of Text. Param Type document * textContent * text.nodeName : string Default: \"\\\"#text\\\"\" Read only text.nodeType : number Default: Node.TEXT_NODE Read only text.data : string text.textContent : string text.nodeValue : string text.length : number Read only text.contentEditable Read only text.isConnected : boolean Read only text.parentNode : Node Read only text.parentElement : Element Read only text.firstChild : Node Read only text.lastChild : Node Read only text.previousSibling : Node Read only text.nextSibling : Node Read only text.firstElementChild : Node Read only text.lastElementChild : Node Read only text.previousElementSibling : Node Read only text.nextElementSibling : Node Read only text.childNodes : NodeList Read only text.children : HTMLCollection Read only text.ownerDocument Read only text.attributes Read only text.substringData(offset, count) Param Type offset * count * text.appendData(arg) Param Type arg string text.insertData(offset, arg) Param Type offset number arg string text.deleteData(offset, count) Param Type offset number count number text.replaceData(offset, count, arg) Param Type offset number count number arg string text.hasChildNodes() text.cloneNode(deep) Param Type deep boolean text.appendChild(child) Param Type child Node text.insertBefore(child, before) Param Type child Node before Node text.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node text.removeChild(child) Param Type child Node text.remove() text.before(...nodes) Param Type ...nodes Array. text.after(...nodes) Param Type ...nodes Array. text.replaceWith(...nodes) Param Type ...nodes Array. text.contains(node) Param Type node Node text.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false text.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false text.dispatchEvent(event) Param Type event * "},"reference/uxp/ui-html-index.html":{"url":"reference/uxp/ui-html-index.html","title":"HTML elements","keywords":"","body":"UI HTML Elements Supported HTML Tags Any tag not listed below will be treated as a div tag. Category Tag Attribute Layout Notes and links Container dialog N/A Modal Dialog div Block Container element footer Block Footer containing pill buttons form Block Form (containing elements) Text b Block Bold text p Block Paragraph (equivalent to div) h1 Block Style differences within dialog form h2 Block \" h3 Block \" h4 Block \" h5 Block \" h6 Block \" p Block Paragraph (equivalent to div) span Block Text element Images img Block Display image elements button uxp-variant=\"cta\" Block Pill Button (Call To Action) button uxp-variant=\"primary\" Block Pill Button (Primary) button uxp-variant=\"secondary\" Block Pull Button (Secondary) button uxp-variant=\"warning\" Block Pull Button (Warning) button uxp-variant=\"action\" Block Action Button button uxp-selected=\"true\" Block Selected Action Button button uxp-quiet=\"true\" Block Quiet variation (except call to action) input] type=\"checkbox\" Block Checkbox input] type=\"image\" Block Image Button input] type=\"number\" Block Text field input] type=\"range\" Block Slider input] type=\"text\" Block Text field input] type=\"text\" uxp-quiet=\"true\" Block Quiet text field select Block Dropdown option N/A Dropdown options textarea Block Standard text area textarea uxp-quiet=\"true\" Block Quiet text area Menus menu N/A Context menu menuitem N/A Context menu items "},"reference/uxp/class/HTMLElement.html":{"url":"reference/uxp/class/HTMLElement.html","title":"HTMLElement","keywords":"","body":" HTMLElement Extends: Element See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement HTMLElement new HTMLElement(document, nodeName, namespaceURI) .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLElement(document, nodeName, namespaceURI) Creates an instance of HTMLElement. Param Type document * nodeName * namespaceURI * htmlElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlElement.nodeName : string Read only htmlElement.localName : string Read only htmlElement.tagName : string Read only htmlElement.nodeType : number Read only htmlElement.namespaceURI : string Read only htmlElement.id : string htmlElement.tabIndex : number htmlElement.className : string htmlElement.attributes : NamedNodeMap Read only htmlElement.style : Style Read only htmlElement.clientLeft : number Read only htmlElement.clientTop : number Read only htmlElement.clientWidth : number Read only htmlElement.clientHeight : number Read only htmlElement.height : string or Number The height of the element htmlElement.width : string or Number The width of the element htmlElement.offsetParent : Element Read only htmlElement.offsetLeft : number Read only htmlElement.offsetTop : number Read only htmlElement.offsetWidth : number Read only htmlElement.offsetHeight : number Read only htmlElement.scrollLeft : number htmlElement.scrollTop : number htmlElement.scrollWidth : number Read only htmlElement.scrollHeight : number Read only htmlElement.uxpContainer : UXPContainer Read only htmlElement.disabled : boolean htmlElement.innerHTML : string htmlElement.outerHTML : string htmlElement.contentEditable Read only htmlElement.isConnected : boolean Read only htmlElement.parentNode : Node Read only htmlElement.parentElement : Element Read only htmlElement.firstChild : Node Read only htmlElement.lastChild : Node Read only htmlElement.previousSibling : Node Read only htmlElement.nextSibling : Node Read only htmlElement.firstElementChild : Node Read only htmlElement.lastElementChild : Node Read only htmlElement.previousElementSibling : Node Read only htmlElement.nextElementSibling : Node Read only htmlElement.textContent : string htmlElement.childNodes : NodeList Read only htmlElement.children : HTMLCollection Read only htmlElement.ownerDocument Read only htmlElement.scrollIntoView() htmlElement.scrollIntoViewIfNeeded() htmlElement.focus() htmlElement.blur() htmlElement.getAttribute(name) Param Type name string htmlElement.setAttribute(name, value) Param Type name string value string htmlElement.removeAttribute(name) Param Type name string htmlElement.hasAttribute(name) Param Type name string htmlElement.getAttributeNode(name) Param Type name string htmlElement.setAttributeNode(newAttr) Param Type newAttr * htmlElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlElement.click() htmlElement.getElementsByClassName(name) Param Type name string htmlElement.getElementsByTagName(name) Param Type name string htmlElement.querySelector(selector) Param Type selector string htmlElement.querySelectorAll(selector) Param Type selector string htmlElement.getBoundingClientRect() htmlElement.insertAdjacentHTML(position, value) Param Type position value string htmlElement.insertAdjacentElement(position, node) Param Type position * node * htmlElement.insertAdjacentText(position, text) Param Type position * text * htmlElement.hasChildNodes() htmlElement.cloneNode(deep) Param Type deep boolean htmlElement.appendChild(child) Param Type child Node htmlElement.insertBefore(child, before) Param Type child Node before Node htmlElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlElement.removeChild(child) Param Type child Node htmlElement.remove() htmlElement.before(...nodes) Param Type ...nodes Array. htmlElement.after(...nodes) Param Type ...nodes Array. htmlElement.replaceWith(...nodes) Param Type ...nodes Array. htmlElement.contains(node) Param Type node Node htmlElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLAnchorElement.html":{"url":"reference/uxp/class/HTMLAnchorElement.html","title":"Anchor","keywords":"","body":" HTMLAnchorElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement HTMLAnchorElement new HTMLAnchorElement(document, nodeName, namespaceURI) .href : string .pathname : string .protocol : string .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLAnchorElement(document, nodeName, namespaceURI) Creates an instance of HTMLAnchorElement. Param Type document * nodeName * namespaceURI * htmlAnchorElement.href : string The href value for the anchor htmlAnchorElement.pathname : string The path portion of the anchor's href Read only htmlAnchorElement.protocol : string The protocol portion of the anchor's href. Read only htmlAnchorElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlAnchorElement.nodeName : string Read only htmlAnchorElement.localName : string Read only htmlAnchorElement.tagName : string Read only htmlAnchorElement.nodeType : number Read only htmlAnchorElement.namespaceURI : string Read only htmlAnchorElement.id : string htmlAnchorElement.tabIndex : number htmlAnchorElement.className : string htmlAnchorElement.attributes : NamedNodeMap Read only htmlAnchorElement.style : Style Read only htmlAnchorElement.clientLeft : number Read only htmlAnchorElement.clientTop : number Read only htmlAnchorElement.clientWidth : number Read only htmlAnchorElement.clientHeight : number Read only htmlAnchorElement.height : string or Number The height of the element htmlAnchorElement.width : string or Number The width of the element htmlAnchorElement.offsetParent : Element Read only htmlAnchorElement.offsetLeft : number Read only htmlAnchorElement.offsetTop : number Read only htmlAnchorElement.offsetWidth : number Read only htmlAnchorElement.offsetHeight : number Read only htmlAnchorElement.scrollLeft : number htmlAnchorElement.scrollTop : number htmlAnchorElement.scrollWidth : number Read only htmlAnchorElement.scrollHeight : number Read only htmlAnchorElement.uxpContainer : UXPContainer Read only htmlAnchorElement.disabled : boolean htmlAnchorElement.innerHTML : string htmlAnchorElement.outerHTML : string htmlAnchorElement.contentEditable Read only htmlAnchorElement.isConnected : boolean Read only htmlAnchorElement.parentNode : Node Read only htmlAnchorElement.parentElement : Element Read only htmlAnchorElement.firstChild : Node Read only htmlAnchorElement.lastChild : Node Read only htmlAnchorElement.previousSibling : Node Read only htmlAnchorElement.nextSibling : Node Read only htmlAnchorElement.firstElementChild : Node Read only htmlAnchorElement.lastElementChild : Node Read only htmlAnchorElement.previousElementSibling : Node Read only htmlAnchorElement.nextElementSibling : Node Read only htmlAnchorElement.textContent : string htmlAnchorElement.childNodes : NodeList Read only htmlAnchorElement.children : HTMLCollection Read only htmlAnchorElement.ownerDocument Read only htmlAnchorElement.scrollIntoView() htmlAnchorElement.scrollIntoViewIfNeeded() htmlAnchorElement.focus() htmlAnchorElement.blur() htmlAnchorElement.getAttribute(name) Param Type name string htmlAnchorElement.setAttribute(name, value) Param Type name string value string htmlAnchorElement.removeAttribute(name) Param Type name string htmlAnchorElement.hasAttribute(name) Param Type name string htmlAnchorElement.getAttributeNode(name) Param Type name string htmlAnchorElement.setAttributeNode(newAttr) Param Type newAttr * htmlAnchorElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlAnchorElement.click() htmlAnchorElement.getElementsByClassName(name) Param Type name string htmlAnchorElement.getElementsByTagName(name) Param Type name string htmlAnchorElement.querySelector(selector) Param Type selector string htmlAnchorElement.querySelectorAll(selector) Param Type selector string htmlAnchorElement.getBoundingClientRect() htmlAnchorElement.insertAdjacentHTML(position, value) Param Type position value string htmlAnchorElement.insertAdjacentElement(position, node) Param Type position * node * htmlAnchorElement.insertAdjacentText(position, text) Param Type position * text * htmlAnchorElement.hasChildNodes() htmlAnchorElement.cloneNode(deep) Param Type deep boolean htmlAnchorElement.appendChild(child) Param Type child Node htmlAnchorElement.insertBefore(child, before) Param Type child Node before Node htmlAnchorElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlAnchorElement.removeChild(child) Param Type child Node htmlAnchorElement.remove() htmlAnchorElement.before(...nodes) Param Type ...nodes Array. htmlAnchorElement.after(...nodes) Param Type ...nodes Array. htmlAnchorElement.replaceWith(...nodes) Param Type ...nodes Array. htmlAnchorElement.contains(node) Param Type node Node htmlAnchorElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlAnchorElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlAnchorElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLBodyElement.html":{"url":"reference/uxp/class/HTMLBodyElement.html","title":"Body","keywords":"","body":" HTMLBodyElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLBodyElement HTMLBodyElement new HTMLBodyElement(document, nodeName, namespaceURI) .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLBodyElement(document, nodeName, namespaceURI) Creates an instance of HTMLBodyElement. Param Type document * nodeName * namespaceURI * htmlBodyElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlBodyElement.nodeName : string Read only htmlBodyElement.localName : string Read only htmlBodyElement.tagName : string Read only htmlBodyElement.nodeType : number Read only htmlBodyElement.namespaceURI : string Read only htmlBodyElement.id : string htmlBodyElement.tabIndex : number htmlBodyElement.className : string htmlBodyElement.attributes : NamedNodeMap Read only htmlBodyElement.style : Style Read only htmlBodyElement.clientLeft : number Read only htmlBodyElement.clientTop : number Read only htmlBodyElement.clientWidth : number Read only htmlBodyElement.clientHeight : number Read only htmlBodyElement.height : string or Number The height of the element htmlBodyElement.width : string or Number The width of the element htmlBodyElement.offsetParent : Element Read only htmlBodyElement.offsetLeft : number Read only htmlBodyElement.offsetTop : number Read only htmlBodyElement.offsetWidth : number Read only htmlBodyElement.offsetHeight : number Read only htmlBodyElement.scrollLeft : number htmlBodyElement.scrollTop : number htmlBodyElement.scrollWidth : number Read only htmlBodyElement.scrollHeight : number Read only htmlBodyElement.uxpContainer : UXPContainer Read only htmlBodyElement.disabled : boolean htmlBodyElement.innerHTML : string htmlBodyElement.outerHTML : string htmlBodyElement.contentEditable Read only htmlBodyElement.isConnected : boolean Read only htmlBodyElement.parentNode : Node Read only htmlBodyElement.parentElement : Element Read only htmlBodyElement.firstChild : Node Read only htmlBodyElement.lastChild : Node Read only htmlBodyElement.previousSibling : Node Read only htmlBodyElement.nextSibling : Node Read only htmlBodyElement.firstElementChild : Node Read only htmlBodyElement.lastElementChild : Node Read only htmlBodyElement.previousElementSibling : Node Read only htmlBodyElement.nextElementSibling : Node Read only htmlBodyElement.textContent : string htmlBodyElement.childNodes : NodeList Read only htmlBodyElement.children : HTMLCollection Read only htmlBodyElement.ownerDocument Read only htmlBodyElement.scrollIntoView() htmlBodyElement.scrollIntoViewIfNeeded() htmlBodyElement.focus() htmlBodyElement.blur() htmlBodyElement.getAttribute(name) Param Type name string htmlBodyElement.setAttribute(name, value) Param Type name string value string htmlBodyElement.removeAttribute(name) Param Type name string htmlBodyElement.hasAttribute(name) Param Type name string htmlBodyElement.getAttributeNode(name) Param Type name string htmlBodyElement.setAttributeNode(newAttr) Param Type newAttr * htmlBodyElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlBodyElement.click() htmlBodyElement.getElementsByClassName(name) Param Type name string htmlBodyElement.getElementsByTagName(name) Param Type name string htmlBodyElement.querySelector(selector) Param Type selector string htmlBodyElement.querySelectorAll(selector) Param Type selector string htmlBodyElement.getBoundingClientRect() htmlBodyElement.insertAdjacentHTML(position, value) Param Type position value string htmlBodyElement.insertAdjacentElement(position, node) Param Type position * node * htmlBodyElement.insertAdjacentText(position, text) Param Type position * text * htmlBodyElement.hasChildNodes() htmlBodyElement.cloneNode(deep) Param Type deep boolean htmlBodyElement.appendChild(child) Param Type child Node htmlBodyElement.insertBefore(child, before) Param Type child Node before Node htmlBodyElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlBodyElement.removeChild(child) Param Type child Node htmlBodyElement.remove() htmlBodyElement.before(...nodes) Param Type ...nodes Array. htmlBodyElement.after(...nodes) Param Type ...nodes Array. htmlBodyElement.replaceWith(...nodes) Param Type ...nodes Array. htmlBodyElement.contains(node) Param Type node Node htmlBodyElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlBodyElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlBodyElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLButtonElement.html":{"url":"reference/uxp/class/HTMLButtonElement.html","title":"Button","keywords":"","body":" HTMLButtonElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement HTMLButtonElement new HTMLButtonElement(document, nodeName, namespaceURI) .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLButtonElement(document, nodeName, namespaceURI) Creates an instance of HTMLButtonElement. Param Type document Document nodeName string namespaceURI string htmlButtonElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlButtonElement.nodeName : string Read only htmlButtonElement.localName : string Read only htmlButtonElement.tagName : string Read only htmlButtonElement.nodeType : number Read only htmlButtonElement.namespaceURI : string Read only htmlButtonElement.id : string htmlButtonElement.tabIndex : number htmlButtonElement.className : string htmlButtonElement.attributes : NamedNodeMap Read only htmlButtonElement.style : Style Read only htmlButtonElement.clientLeft : number Read only htmlButtonElement.clientTop : number Read only htmlButtonElement.clientWidth : number Read only htmlButtonElement.clientHeight : number Read only htmlButtonElement.height : string or Number The height of the element htmlButtonElement.width : string or Number The width of the element htmlButtonElement.offsetParent : Element Read only htmlButtonElement.offsetLeft : number Read only htmlButtonElement.offsetTop : number Read only htmlButtonElement.offsetWidth : number Read only htmlButtonElement.offsetHeight : number Read only htmlButtonElement.scrollLeft : number htmlButtonElement.scrollTop : number htmlButtonElement.scrollWidth : number Read only htmlButtonElement.scrollHeight : number Read only htmlButtonElement.uxpContainer : UXPContainer Read only htmlButtonElement.disabled : boolean htmlButtonElement.innerHTML : string htmlButtonElement.outerHTML : string htmlButtonElement.contentEditable Read only htmlButtonElement.isConnected : boolean Read only htmlButtonElement.parentNode : Node Read only htmlButtonElement.parentElement : Element Read only htmlButtonElement.firstChild : Node Read only htmlButtonElement.lastChild : Node Read only htmlButtonElement.previousSibling : Node Read only htmlButtonElement.nextSibling : Node Read only htmlButtonElement.firstElementChild : Node Read only htmlButtonElement.lastElementChild : Node Read only htmlButtonElement.previousElementSibling : Node Read only htmlButtonElement.nextElementSibling : Node Read only htmlButtonElement.textContent : string htmlButtonElement.childNodes : NodeList Read only htmlButtonElement.children : HTMLCollection Read only htmlButtonElement.ownerDocument Read only htmlButtonElement.scrollIntoView() htmlButtonElement.scrollIntoViewIfNeeded() htmlButtonElement.focus() htmlButtonElement.blur() htmlButtonElement.getAttribute(name) Param Type name string htmlButtonElement.setAttribute(name, value) Param Type name string value string htmlButtonElement.removeAttribute(name) Param Type name string htmlButtonElement.hasAttribute(name) Param Type name string htmlButtonElement.getAttributeNode(name) Param Type name string htmlButtonElement.setAttributeNode(newAttr) Param Type newAttr * htmlButtonElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlButtonElement.click() htmlButtonElement.getElementsByClassName(name) Param Type name string htmlButtonElement.getElementsByTagName(name) Param Type name string htmlButtonElement.querySelector(selector) Param Type selector string htmlButtonElement.querySelectorAll(selector) Param Type selector string htmlButtonElement.getBoundingClientRect() htmlButtonElement.insertAdjacentHTML(position, value) Param Type position value string htmlButtonElement.insertAdjacentElement(position, node) Param Type position * node * htmlButtonElement.insertAdjacentText(position, text) Param Type position * text * htmlButtonElement.hasChildNodes() htmlButtonElement.cloneNode(deep) Param Type deep boolean htmlButtonElement.appendChild(child) Param Type child Node htmlButtonElement.insertBefore(child, before) Param Type child Node before Node htmlButtonElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlButtonElement.removeChild(child) Param Type child Node htmlButtonElement.remove() htmlButtonElement.before(...nodes) Param Type ...nodes Array. htmlButtonElement.after(...nodes) Param Type ...nodes Array. htmlButtonElement.replaceWith(...nodes) Param Type ...nodes Array. htmlButtonElement.contains(node) Param Type node Node htmlButtonElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlButtonElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlButtonElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLDialogElement.html":{"url":"reference/uxp/class/HTMLDialogElement.html","title":"Dialog","keywords":"","body":" HTMLDialogElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement HTMLDialogElement new HTMLDialogElement(document, nodeName, namespaceURI) .open : boolean .returnValue : * .REJECTION_REASON_NOT_ALLOWED .REJECTION_REASON_DETACHED .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .showModal() .close([returnValue]) .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLDialogElement(document, nodeName, namespaceURI) Creates an instance of HTMLDialogElement. Param Type document * nodeName * namespaceURI * htmlDialogElement.open : boolean Read only htmlDialogElement.returnValue : * htmlDialogElement.REJECTION_REASON_NOT_ALLOWED When the promise returned from openDialog() is rejected, error.code can be equal to this value, which means that the application does not allow showing dialogs (e.g. only one dialog is allowed). htmlDialogElement.REJECTION_REASON_DETACHED When the promise returned from openDialog() is rejected, error.code can be equal to this value, which means that the node has been detached from DOM tree. htmlDialogElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlDialogElement.nodeName : string Read only htmlDialogElement.localName : string Read only htmlDialogElement.tagName : string Read only htmlDialogElement.nodeType : number Read only htmlDialogElement.namespaceURI : string Read only htmlDialogElement.id : string htmlDialogElement.tabIndex : number htmlDialogElement.className : string htmlDialogElement.attributes : NamedNodeMap Read only htmlDialogElement.style : Style Read only htmlDialogElement.clientLeft : number Read only htmlDialogElement.clientTop : number Read only htmlDialogElement.clientWidth : number Read only htmlDialogElement.clientHeight : number Read only htmlDialogElement.height : string or Number The height of the element htmlDialogElement.width : string or Number The width of the element htmlDialogElement.offsetParent : Element Read only htmlDialogElement.offsetLeft : number Read only htmlDialogElement.offsetTop : number Read only htmlDialogElement.offsetWidth : number Read only htmlDialogElement.offsetHeight : number Read only htmlDialogElement.scrollLeft : number htmlDialogElement.scrollTop : number htmlDialogElement.scrollWidth : number Read only htmlDialogElement.scrollHeight : number Read only htmlDialogElement.uxpContainer : UXPContainer Read only htmlDialogElement.disabled : boolean htmlDialogElement.innerHTML : string htmlDialogElement.outerHTML : string htmlDialogElement.contentEditable Read only htmlDialogElement.isConnected : boolean Read only htmlDialogElement.parentNode : Node Read only htmlDialogElement.parentElement : Element Read only htmlDialogElement.firstChild : Node Read only htmlDialogElement.lastChild : Node Read only htmlDialogElement.previousSibling : Node Read only htmlDialogElement.nextSibling : Node Read only htmlDialogElement.firstElementChild : Node Read only htmlDialogElement.lastElementChild : Node Read only htmlDialogElement.previousElementSibling : Node Read only htmlDialogElement.nextElementSibling : Node Read only htmlDialogElement.textContent : string htmlDialogElement.childNodes : NodeList Read only htmlDialogElement.children : HTMLCollection Read only htmlDialogElement.ownerDocument Read only htmlDialogElement.showModal() Show the modal dialog. Returns: Promise - A promise that resolves when the dialog is closed (NSC) after calling the close() method or clicking the \"submit\" button. The promise will be resolved with returnValue as a parameter. The promise can be rejected if the dialog was closed for other reasons e.g. the user hit escape or closed the window, or if the application does not allow showing the dialog. The error parameter will give more details. error.code will be one of the values from HTMLDialogElement.rejectionReasons. htmlDialogElement.close([returnValue]) Closes the dialog; setting the return value (optional) Param Type [returnValue] * htmlDialogElement.scrollIntoView() htmlDialogElement.scrollIntoViewIfNeeded() htmlDialogElement.focus() htmlDialogElement.blur() htmlDialogElement.getAttribute(name) Param Type name string htmlDialogElement.setAttribute(name, value) Param Type name string value string htmlDialogElement.removeAttribute(name) Param Type name string htmlDialogElement.hasAttribute(name) Param Type name string htmlDialogElement.getAttributeNode(name) Param Type name string htmlDialogElement.setAttributeNode(newAttr) Param Type newAttr * htmlDialogElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlDialogElement.click() htmlDialogElement.getElementsByClassName(name) Param Type name string htmlDialogElement.getElementsByTagName(name) Param Type name string htmlDialogElement.querySelector(selector) Param Type selector string htmlDialogElement.querySelectorAll(selector) Param Type selector string htmlDialogElement.getBoundingClientRect() htmlDialogElement.insertAdjacentHTML(position, value) Param Type position value string htmlDialogElement.insertAdjacentElement(position, node) Param Type position * node * htmlDialogElement.insertAdjacentText(position, text) Param Type position * text * htmlDialogElement.hasChildNodes() htmlDialogElement.cloneNode(deep) Param Type deep boolean htmlDialogElement.appendChild(child) Param Type child Node htmlDialogElement.insertBefore(child, before) Param Type child Node before Node htmlDialogElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlDialogElement.removeChild(child) Param Type child Node htmlDialogElement.remove() htmlDialogElement.before(...nodes) Param Type ...nodes Array. htmlDialogElement.after(...nodes) Param Type ...nodes Array. htmlDialogElement.replaceWith(...nodes) Param Type ...nodes Array. htmlDialogElement.contains(node) Param Type node Node htmlDialogElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlDialogElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlDialogElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLFormElement.html":{"url":"reference/uxp/class/HTMLFormElement.html","title":"Form","keywords":"","body":" HTMLFormElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement HTMLFormElement .elements .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) htmlFormElement.elements Returns an HTMLCollection containing all of the form controls. It should technicaly be an HTMLFormControlsCollection which subclasses HTMLCollection. TODO: Implement HTMLFormControlsCollection and use it here. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/elements htmlFormElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlFormElement.nodeName : string Read only htmlFormElement.localName : string Read only htmlFormElement.tagName : string Read only htmlFormElement.nodeType : number Read only htmlFormElement.namespaceURI : string Read only htmlFormElement.id : string htmlFormElement.tabIndex : number htmlFormElement.className : string htmlFormElement.attributes : NamedNodeMap Read only htmlFormElement.style : Style Read only htmlFormElement.clientLeft : number Read only htmlFormElement.clientTop : number Read only htmlFormElement.clientWidth : number Read only htmlFormElement.clientHeight : number Read only htmlFormElement.height : string or Number The height of the element htmlFormElement.width : string or Number The width of the element htmlFormElement.offsetParent : Element Read only htmlFormElement.offsetLeft : number Read only htmlFormElement.offsetTop : number Read only htmlFormElement.offsetWidth : number Read only htmlFormElement.offsetHeight : number Read only htmlFormElement.scrollLeft : number htmlFormElement.scrollTop : number htmlFormElement.scrollWidth : number Read only htmlFormElement.scrollHeight : number Read only htmlFormElement.uxpContainer : UXPContainer Read only htmlFormElement.disabled : boolean htmlFormElement.innerHTML : string htmlFormElement.outerHTML : string htmlFormElement.contentEditable Read only htmlFormElement.isConnected : boolean Read only htmlFormElement.parentNode : Node Read only htmlFormElement.parentElement : Element Read only htmlFormElement.firstChild : Node Read only htmlFormElement.lastChild : Node Read only htmlFormElement.previousSibling : Node Read only htmlFormElement.nextSibling : Node Read only htmlFormElement.firstElementChild : Node Read only htmlFormElement.lastElementChild : Node Read only htmlFormElement.previousElementSibling : Node Read only htmlFormElement.nextElementSibling : Node Read only htmlFormElement.textContent : string htmlFormElement.childNodes : NodeList Read only htmlFormElement.children : HTMLCollection Read only htmlFormElement.ownerDocument Read only htmlFormElement.scrollIntoView() htmlFormElement.scrollIntoViewIfNeeded() htmlFormElement.focus() htmlFormElement.blur() htmlFormElement.getAttribute(name) Param Type name string htmlFormElement.setAttribute(name, value) Param Type name string value string htmlFormElement.removeAttribute(name) Param Type name string htmlFormElement.hasAttribute(name) Param Type name string htmlFormElement.getAttributeNode(name) Param Type name string htmlFormElement.setAttributeNode(newAttr) Param Type newAttr * htmlFormElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlFormElement.click() htmlFormElement.getElementsByClassName(name) Param Type name string htmlFormElement.getElementsByTagName(name) Param Type name string htmlFormElement.querySelector(selector) Param Type selector string htmlFormElement.querySelectorAll(selector) Param Type selector string htmlFormElement.getBoundingClientRect() htmlFormElement.insertAdjacentHTML(position, value) Param Type position value string htmlFormElement.insertAdjacentElement(position, node) Param Type position * node * htmlFormElement.insertAdjacentText(position, text) Param Type position * text * htmlFormElement.hasChildNodes() htmlFormElement.cloneNode(deep) Param Type deep boolean htmlFormElement.appendChild(child) Param Type child Node htmlFormElement.insertBefore(child, before) Param Type child Node before Node htmlFormElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlFormElement.removeChild(child) Param Type child Node htmlFormElement.remove() htmlFormElement.before(...nodes) Param Type ...nodes Array. htmlFormElement.after(...nodes) Param Type ...nodes Array. htmlFormElement.replaceWith(...nodes) Param Type ...nodes Array. htmlFormElement.contains(node) Param Type node Node htmlFormElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlFormElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlFormElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLHeadElement.html":{"url":"reference/uxp/class/HTMLHeadElement.html","title":"Head","keywords":"","body":" HTMLHeadElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLHeadElement HTMLHeadElement new HTMLHeadElement(document, nodeName, namespaceURI) .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLHeadElement(document, nodeName, namespaceURI) Creates an instance of HTMLHeadElement. Param Type document * nodeName * namespaceURI * htmlHeadElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlHeadElement.nodeName : string Read only htmlHeadElement.localName : string Read only htmlHeadElement.tagName : string Read only htmlHeadElement.nodeType : number Read only htmlHeadElement.namespaceURI : string Read only htmlHeadElement.id : string htmlHeadElement.tabIndex : number htmlHeadElement.className : string htmlHeadElement.attributes : NamedNodeMap Read only htmlHeadElement.style : Style Read only htmlHeadElement.clientLeft : number Read only htmlHeadElement.clientTop : number Read only htmlHeadElement.clientWidth : number Read only htmlHeadElement.clientHeight : number Read only htmlHeadElement.height : string or Number The height of the element htmlHeadElement.width : string or Number The width of the element htmlHeadElement.offsetParent : Element Read only htmlHeadElement.offsetLeft : number Read only htmlHeadElement.offsetTop : number Read only htmlHeadElement.offsetWidth : number Read only htmlHeadElement.offsetHeight : number Read only htmlHeadElement.scrollLeft : number htmlHeadElement.scrollTop : number htmlHeadElement.scrollWidth : number Read only htmlHeadElement.scrollHeight : number Read only htmlHeadElement.uxpContainer : UXPContainer Read only htmlHeadElement.disabled : boolean htmlHeadElement.innerHTML : string htmlHeadElement.outerHTML : string htmlHeadElement.contentEditable Read only htmlHeadElement.isConnected : boolean Read only htmlHeadElement.parentNode : Node Read only htmlHeadElement.parentElement : Element Read only htmlHeadElement.firstChild : Node Read only htmlHeadElement.lastChild : Node Read only htmlHeadElement.previousSibling : Node Read only htmlHeadElement.nextSibling : Node Read only htmlHeadElement.firstElementChild : Node Read only htmlHeadElement.lastElementChild : Node Read only htmlHeadElement.previousElementSibling : Node Read only htmlHeadElement.nextElementSibling : Node Read only htmlHeadElement.textContent : string htmlHeadElement.childNodes : NodeList Read only htmlHeadElement.children : HTMLCollection Read only htmlHeadElement.ownerDocument Read only htmlHeadElement.scrollIntoView() htmlHeadElement.scrollIntoViewIfNeeded() htmlHeadElement.focus() htmlHeadElement.blur() htmlHeadElement.getAttribute(name) Param Type name string htmlHeadElement.setAttribute(name, value) Param Type name string value string htmlHeadElement.removeAttribute(name) Param Type name string htmlHeadElement.hasAttribute(name) Param Type name string htmlHeadElement.getAttributeNode(name) Param Type name string htmlHeadElement.setAttributeNode(newAttr) Param Type newAttr * htmlHeadElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlHeadElement.click() htmlHeadElement.getElementsByClassName(name) Param Type name string htmlHeadElement.getElementsByTagName(name) Param Type name string htmlHeadElement.querySelector(selector) Param Type selector string htmlHeadElement.querySelectorAll(selector) Param Type selector string htmlHeadElement.getBoundingClientRect() htmlHeadElement.insertAdjacentHTML(position, value) Param Type position value string htmlHeadElement.insertAdjacentElement(position, node) Param Type position * node * htmlHeadElement.insertAdjacentText(position, text) Param Type position * text * htmlHeadElement.hasChildNodes() htmlHeadElement.cloneNode(deep) Param Type deep boolean htmlHeadElement.appendChild(child) Param Type child Node htmlHeadElement.insertBefore(child, before) Param Type child Node before Node htmlHeadElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlHeadElement.removeChild(child) Param Type child Node htmlHeadElement.remove() htmlHeadElement.before(...nodes) Param Type ...nodes Array. htmlHeadElement.after(...nodes) Param Type ...nodes Array. htmlHeadElement.replaceWith(...nodes) Param Type ...nodes Array. htmlHeadElement.contains(node) Param Type node Node htmlHeadElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlHeadElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlHeadElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLHtmlElement.html":{"url":"reference/uxp/class/HTMLHtmlElement.html","title":"Html","keywords":"","body":" HTMLHtmlElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLHtmlElement HTMLHtmlElement new HTMLHtmlElement(document, nodeName, namespaceURI) .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLHtmlElement(document, nodeName, namespaceURI) Creates an instance of HTMLHtmlElement. Param Type document * nodeName * namespaceURI * htmlHtmlElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlHtmlElement.nodeName : string Read only htmlHtmlElement.localName : string Read only htmlHtmlElement.tagName : string Read only htmlHtmlElement.nodeType : number Read only htmlHtmlElement.namespaceURI : string Read only htmlHtmlElement.id : string htmlHtmlElement.tabIndex : number htmlHtmlElement.className : string htmlHtmlElement.attributes : NamedNodeMap Read only htmlHtmlElement.style : Style Read only htmlHtmlElement.clientLeft : number Read only htmlHtmlElement.clientTop : number Read only htmlHtmlElement.clientWidth : number Read only htmlHtmlElement.clientHeight : number Read only htmlHtmlElement.height : string or Number The height of the element htmlHtmlElement.width : string or Number The width of the element htmlHtmlElement.offsetParent : Element Read only htmlHtmlElement.offsetLeft : number Read only htmlHtmlElement.offsetTop : number Read only htmlHtmlElement.offsetWidth : number Read only htmlHtmlElement.offsetHeight : number Read only htmlHtmlElement.scrollLeft : number htmlHtmlElement.scrollTop : number htmlHtmlElement.scrollWidth : number Read only htmlHtmlElement.scrollHeight : number Read only htmlHtmlElement.uxpContainer : UXPContainer Overrides: uxpContainer Read only htmlHtmlElement.disabled : boolean htmlHtmlElement.innerHTML : string htmlHtmlElement.outerHTML : string htmlHtmlElement.contentEditable Read only htmlHtmlElement.isConnected : boolean Read only htmlHtmlElement.parentNode : Node Read only htmlHtmlElement.parentElement : Element Read only htmlHtmlElement.firstChild : Node Read only htmlHtmlElement.lastChild : Node Read only htmlHtmlElement.previousSibling : Node Read only htmlHtmlElement.nextSibling : Node Read only htmlHtmlElement.firstElementChild : Node Read only htmlHtmlElement.lastElementChild : Node Read only htmlHtmlElement.previousElementSibling : Node Read only htmlHtmlElement.nextElementSibling : Node Read only htmlHtmlElement.textContent : string htmlHtmlElement.childNodes : NodeList Read only htmlHtmlElement.children : HTMLCollection Read only htmlHtmlElement.ownerDocument Read only htmlHtmlElement.scrollIntoView() htmlHtmlElement.scrollIntoViewIfNeeded() htmlHtmlElement.focus() htmlHtmlElement.blur() htmlHtmlElement.getAttribute(name) Param Type name string htmlHtmlElement.setAttribute(name, value) Param Type name string value string htmlHtmlElement.removeAttribute(name) Param Type name string htmlHtmlElement.hasAttribute(name) Param Type name string htmlHtmlElement.getAttributeNode(name) Param Type name string htmlHtmlElement.setAttributeNode(newAttr) Param Type newAttr * htmlHtmlElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlHtmlElement.click() htmlHtmlElement.getElementsByClassName(name) Param Type name string htmlHtmlElement.getElementsByTagName(name) Param Type name string htmlHtmlElement.querySelector(selector) Param Type selector string htmlHtmlElement.querySelectorAll(selector) Param Type selector string htmlHtmlElement.getBoundingClientRect() htmlHtmlElement.insertAdjacentHTML(position, value) Param Type position value string htmlHtmlElement.insertAdjacentElement(position, node) Param Type position * node * htmlHtmlElement.insertAdjacentText(position, text) Param Type position * text * htmlHtmlElement.hasChildNodes() htmlHtmlElement.cloneNode(deep) Param Type deep boolean htmlHtmlElement.appendChild(child) Param Type child Node htmlHtmlElement.insertBefore(child, before) Param Type child Node before Node htmlHtmlElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlHtmlElement.removeChild(child) Param Type child Node htmlHtmlElement.remove() htmlHtmlElement.before(...nodes) Param Type ...nodes Array. htmlHtmlElement.after(...nodes) Param Type ...nodes Array. htmlHtmlElement.replaceWith(...nodes) Param Type ...nodes Array. htmlHtmlElement.contains(node) Param Type node Node htmlHtmlElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlHtmlElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlHtmlElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLImageElement.html":{"url":"reference/uxp/class/HTMLImageElement.html","title":"Image","keywords":"","body":" HTMLImageElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement HTMLImageElement new HTMLImageElement(document, nodeName, namespaceURI) .src : string or File .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLImageElement(document, nodeName, namespaceURI) Creates an instance of HTMLImageElement. Param Type document * nodeName * namespaceURI * htmlImageElement.src : string or File The source of the image htmlImageElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlImageElement.nodeName : string Read only htmlImageElement.localName : string Read only htmlImageElement.tagName : string Read only htmlImageElement.nodeType : number Read only htmlImageElement.namespaceURI : string Read only htmlImageElement.id : string htmlImageElement.tabIndex : number htmlImageElement.className : string htmlImageElement.attributes : NamedNodeMap Read only htmlImageElement.style : Style Read only htmlImageElement.clientLeft : number Read only htmlImageElement.clientTop : number Read only htmlImageElement.clientWidth : number Read only htmlImageElement.clientHeight : number Read only htmlImageElement.height : string or Number The height of the element htmlImageElement.width : string or Number The width of the element htmlImageElement.offsetParent : Element Read only htmlImageElement.offsetLeft : number Read only htmlImageElement.offsetTop : number Read only htmlImageElement.offsetWidth : number Read only htmlImageElement.offsetHeight : number Read only htmlImageElement.scrollLeft : number htmlImageElement.scrollTop : number htmlImageElement.scrollWidth : number Read only htmlImageElement.scrollHeight : number Read only htmlImageElement.uxpContainer : UXPContainer Read only htmlImageElement.disabled : boolean htmlImageElement.innerHTML : string htmlImageElement.outerHTML : string htmlImageElement.contentEditable Read only htmlImageElement.isConnected : boolean Read only htmlImageElement.parentNode : Node Read only htmlImageElement.parentElement : Element Read only htmlImageElement.firstChild : Node Read only htmlImageElement.lastChild : Node Read only htmlImageElement.previousSibling : Node Read only htmlImageElement.nextSibling : Node Read only htmlImageElement.firstElementChild : Node Read only htmlImageElement.lastElementChild : Node Read only htmlImageElement.previousElementSibling : Node Read only htmlImageElement.nextElementSibling : Node Read only htmlImageElement.textContent : string htmlImageElement.childNodes : NodeList Read only htmlImageElement.children : HTMLCollection Read only htmlImageElement.ownerDocument Read only htmlImageElement.scrollIntoView() htmlImageElement.scrollIntoViewIfNeeded() htmlImageElement.focus() htmlImageElement.blur() htmlImageElement.getAttribute(name) Param Type name string htmlImageElement.setAttribute(name, value) Param Type name string value string htmlImageElement.removeAttribute(name) Param Type name string htmlImageElement.hasAttribute(name) Param Type name string htmlImageElement.getAttributeNode(name) Param Type name string htmlImageElement.setAttributeNode(newAttr) Param Type newAttr * htmlImageElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlImageElement.click() htmlImageElement.getElementsByClassName(name) Param Type name string htmlImageElement.getElementsByTagName(name) Param Type name string htmlImageElement.querySelector(selector) Param Type selector string htmlImageElement.querySelectorAll(selector) Param Type selector string htmlImageElement.getBoundingClientRect() htmlImageElement.insertAdjacentHTML(position, value) Param Type position value string htmlImageElement.insertAdjacentElement(position, node) Param Type position * node * htmlImageElement.insertAdjacentText(position, text) Param Type position * text * htmlImageElement.hasChildNodes() htmlImageElement.cloneNode(deep) Param Type deep boolean htmlImageElement.appendChild(child) Param Type child Node htmlImageElement.insertBefore(child, before) Param Type child Node before Node htmlImageElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlImageElement.removeChild(child) Param Type child Node htmlImageElement.remove() htmlImageElement.before(...nodes) Param Type ...nodes Array. htmlImageElement.after(...nodes) Param Type ...nodes Array. htmlImageElement.replaceWith(...nodes) Param Type ...nodes Array. htmlImageElement.contains(node) Param Type node Node htmlImageElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlImageElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlImageElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLInputElement.html":{"url":"reference/uxp/class/HTMLInputElement.html","title":"Input","keywords":"","body":" HTMLInputElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLInputElement HTMLInputElement new HTMLInputElement(document, nodeName, namespaceURI) instance .value : * .defaultValue : string .checked : boolean .indeterminate : boolean .autofocus : boolean .name : string .type : string .placeholder : string .readOnly : boolean .min : string .max : string .step : string .uxpVariant : string .uxpQuiet : string .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) static .HTMLTextAreaElement#defaultValue : string new HTMLInputElement(document, nodeName, namespaceURI) Creates an instance of HTMLInputElement. Param Type document * nodeName * namespaceURI * htmlInputElement.value : * Returns the value of the input element. htmlInputElement.defaultValue : string The defaultValue for the input element (if applicable to the input element's type) htmlInputElement.checked : boolean Indicates if the checkbox is checked. htmlInputElement.indeterminate : boolean Indicates if the element is indeterminate htmlInputElement.autofocus : boolean Indicates if the element will focus automatically when it is loaded in a form. htmlInputElement.name : string Specifies the name of this input element. htmlInputElement.type : string Specifies the type of input control htmlInputElement.placeholder : string The placeholder for the input element (if applicable to the input element's type) htmlInputElement.readOnly : boolean Determines if the element's content is read only. htmlInputElement.min : string Minimum value allowed (used for input type=\"range\") htmlInputElement.max : string Maximum value allowed (used for input type=\"range\") htmlInputElement.step : string the size of each movement of the slder control (used for input type=\"range\") htmlInputElement.uxpVariant : string Controls the type of native widget. htmlInputElement.uxpQuiet : string Determines if a control is rendered in \"quiet\" mode htmlInputElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlInputElement.nodeName : string Read only htmlInputElement.localName : string Read only htmlInputElement.tagName : string Read only htmlInputElement.nodeType : number Read only htmlInputElement.namespaceURI : string Read only htmlInputElement.id : string htmlInputElement.tabIndex : number htmlInputElement.className : string htmlInputElement.attributes : NamedNodeMap Read only htmlInputElement.style : Style Read only htmlInputElement.clientLeft : number Read only htmlInputElement.clientTop : number Read only htmlInputElement.clientWidth : number Read only htmlInputElement.clientHeight : number Read only htmlInputElement.height : string or Number The height of the element htmlInputElement.width : string or Number The width of the element htmlInputElement.offsetParent : Element Read only htmlInputElement.offsetLeft : number Read only htmlInputElement.offsetTop : number Read only htmlInputElement.offsetWidth : number Read only htmlInputElement.offsetHeight : number Read only htmlInputElement.scrollLeft : number htmlInputElement.scrollTop : number htmlInputElement.scrollWidth : number Read only htmlInputElement.scrollHeight : number Read only htmlInputElement.uxpContainer : UXPContainer Read only htmlInputElement.disabled : boolean htmlInputElement.innerHTML : string htmlInputElement.outerHTML : string htmlInputElement.contentEditable Read only htmlInputElement.isConnected : boolean Read only htmlInputElement.parentNode : Node Read only htmlInputElement.parentElement : Element Read only htmlInputElement.firstChild : Node Read only htmlInputElement.lastChild : Node Read only htmlInputElement.previousSibling : Node Read only htmlInputElement.nextSibling : Node Read only htmlInputElement.firstElementChild : Node Read only htmlInputElement.lastElementChild : Node Read only htmlInputElement.previousElementSibling : Node Read only htmlInputElement.nextElementSibling : Node Read only htmlInputElement.textContent : string htmlInputElement.childNodes : NodeList Read only htmlInputElement.children : HTMLCollection Read only htmlInputElement.ownerDocument Read only htmlInputElement.scrollIntoView() htmlInputElement.scrollIntoViewIfNeeded() htmlInputElement.focus() htmlInputElement.blur() htmlInputElement.getAttribute(name) Param Type name string htmlInputElement.setAttribute(name, value) Param Type name string value string htmlInputElement.removeAttribute(name) Param Type name string htmlInputElement.hasAttribute(name) Param Type name string htmlInputElement.getAttributeNode(name) Param Type name string htmlInputElement.setAttributeNode(newAttr) Param Type newAttr * htmlInputElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlInputElement.click() htmlInputElement.getElementsByClassName(name) Param Type name string htmlInputElement.getElementsByTagName(name) Param Type name string htmlInputElement.querySelector(selector) Param Type selector string htmlInputElement.querySelectorAll(selector) Param Type selector string htmlInputElement.getBoundingClientRect() htmlInputElement.insertAdjacentHTML(position, value) Param Type position value string htmlInputElement.insertAdjacentElement(position, node) Param Type position * node * htmlInputElement.insertAdjacentText(position, text) Param Type position * text * htmlInputElement.hasChildNodes() htmlInputElement.cloneNode(deep) Param Type deep boolean htmlInputElement.appendChild(child) Param Type child Node htmlInputElement.insertBefore(child, before) Param Type child Node before Node htmlInputElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlInputElement.removeChild(child) Param Type child Node htmlInputElement.remove() htmlInputElement.before(...nodes) Param Type ...nodes Array. htmlInputElement.after(...nodes) Param Type ...nodes Array. htmlInputElement.replaceWith(...nodes) Param Type ...nodes Array. htmlInputElement.contains(node) Param Type node Node htmlInputElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlInputElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlInputElement.dispatchEvent(event) Param Type event * HTMLInputElement.HTMLTextAreaElement#defaultValue : string The defaultValue for the textarea element "},"reference/uxp/class/HTMLLabelElement.html":{"url":"reference/uxp/class/HTMLLabelElement.html","title":"Label","keywords":"","body":" HTMLLabelElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLabelElement HTMLLabelElement new HTMLLabelElement(document, nodeName, namespaceURI) .control : HTMLElement .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLLabelElement(document, nodeName, namespaceURI) Creates an instance of HTMLLabelElement. Param Type document * nodeName * namespaceURI * htmlLabelElement.control : HTMLElement Read only htmlLabelElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlLabelElement.nodeName : string Read only htmlLabelElement.localName : string Read only htmlLabelElement.tagName : string Read only htmlLabelElement.nodeType : number Read only htmlLabelElement.namespaceURI : string Read only htmlLabelElement.id : string htmlLabelElement.tabIndex : number htmlLabelElement.className : string htmlLabelElement.attributes : NamedNodeMap Read only htmlLabelElement.style : Style Read only htmlLabelElement.clientLeft : number Read only htmlLabelElement.clientTop : number Read only htmlLabelElement.clientWidth : number Read only htmlLabelElement.clientHeight : number Read only htmlLabelElement.height : string or Number The height of the element htmlLabelElement.width : string or Number The width of the element htmlLabelElement.offsetParent : Element Read only htmlLabelElement.offsetLeft : number Read only htmlLabelElement.offsetTop : number Read only htmlLabelElement.offsetWidth : number Read only htmlLabelElement.offsetHeight : number Read only htmlLabelElement.scrollLeft : number htmlLabelElement.scrollTop : number htmlLabelElement.scrollWidth : number Read only htmlLabelElement.scrollHeight : number Read only htmlLabelElement.uxpContainer : UXPContainer Read only htmlLabelElement.disabled : boolean htmlLabelElement.innerHTML : string htmlLabelElement.outerHTML : string htmlLabelElement.contentEditable Read only htmlLabelElement.isConnected : boolean Read only htmlLabelElement.parentNode : Node Read only htmlLabelElement.parentElement : Element Read only htmlLabelElement.firstChild : Node Read only htmlLabelElement.lastChild : Node Read only htmlLabelElement.previousSibling : Node Read only htmlLabelElement.nextSibling : Node Read only htmlLabelElement.firstElementChild : Node Read only htmlLabelElement.lastElementChild : Node Read only htmlLabelElement.previousElementSibling : Node Read only htmlLabelElement.nextElementSibling : Node Read only htmlLabelElement.textContent : string htmlLabelElement.childNodes : NodeList Read only htmlLabelElement.children : HTMLCollection Read only htmlLabelElement.ownerDocument Read only htmlLabelElement.scrollIntoView() htmlLabelElement.scrollIntoViewIfNeeded() htmlLabelElement.focus() htmlLabelElement.blur() htmlLabelElement.getAttribute(name) Param Type name string htmlLabelElement.setAttribute(name, value) Param Type name string value string htmlLabelElement.removeAttribute(name) Param Type name string htmlLabelElement.hasAttribute(name) Param Type name string htmlLabelElement.getAttributeNode(name) Param Type name string htmlLabelElement.setAttributeNode(newAttr) Param Type newAttr * htmlLabelElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlLabelElement.click() htmlLabelElement.getElementsByClassName(name) Param Type name string htmlLabelElement.getElementsByTagName(name) Param Type name string htmlLabelElement.querySelector(selector) Param Type selector string htmlLabelElement.querySelectorAll(selector) Param Type selector string htmlLabelElement.getBoundingClientRect() htmlLabelElement.insertAdjacentHTML(position, value) Param Type position value string htmlLabelElement.insertAdjacentElement(position, node) Param Type position * node * htmlLabelElement.insertAdjacentText(position, text) Param Type position * text * htmlLabelElement.hasChildNodes() htmlLabelElement.cloneNode(deep) Param Type deep boolean htmlLabelElement.appendChild(child) Param Type child Node htmlLabelElement.insertBefore(child, before) Param Type child Node before Node htmlLabelElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlLabelElement.removeChild(child) Param Type child Node htmlLabelElement.remove() htmlLabelElement.before(...nodes) Param Type ...nodes Array. htmlLabelElement.after(...nodes) Param Type ...nodes Array. htmlLabelElement.replaceWith(...nodes) Param Type ...nodes Array. htmlLabelElement.contains(node) Param Type node Node htmlLabelElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlLabelElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlLabelElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLLinkElement.html":{"url":"reference/uxp/class/HTMLLinkElement.html","title":"Link","keywords":"","body":" HTMLLinkElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLLinkElement HTMLLinkElement new HTMLLinkElement(document, nodeName, namespaceURI) .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLLinkElement(document, nodeName, namespaceURI) Creates an instance of HTMLLinkElement. Param Type document * nodeName * namespaceURI * htmlLinkElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlLinkElement.nodeName : string Read only htmlLinkElement.localName : string Read only htmlLinkElement.tagName : string Read only htmlLinkElement.nodeType : number Read only htmlLinkElement.namespaceURI : string Read only htmlLinkElement.id : string htmlLinkElement.tabIndex : number htmlLinkElement.className : string htmlLinkElement.attributes : NamedNodeMap Read only htmlLinkElement.style : Style Read only htmlLinkElement.clientLeft : number Read only htmlLinkElement.clientTop : number Read only htmlLinkElement.clientWidth : number Read only htmlLinkElement.clientHeight : number Read only htmlLinkElement.height : string or Number The height of the element htmlLinkElement.width : string or Number The width of the element htmlLinkElement.offsetParent : Element Read only htmlLinkElement.offsetLeft : number Read only htmlLinkElement.offsetTop : number Read only htmlLinkElement.offsetWidth : number Read only htmlLinkElement.offsetHeight : number Read only htmlLinkElement.scrollLeft : number htmlLinkElement.scrollTop : number htmlLinkElement.scrollWidth : number Read only htmlLinkElement.scrollHeight : number Read only htmlLinkElement.uxpContainer : UXPContainer Read only htmlLinkElement.disabled : boolean htmlLinkElement.innerHTML : string htmlLinkElement.outerHTML : string htmlLinkElement.contentEditable Read only htmlLinkElement.isConnected : boolean Read only htmlLinkElement.parentNode : Node Read only htmlLinkElement.parentElement : Element Read only htmlLinkElement.firstChild : Node Read only htmlLinkElement.lastChild : Node Read only htmlLinkElement.previousSibling : Node Read only htmlLinkElement.nextSibling : Node Read only htmlLinkElement.firstElementChild : Node Read only htmlLinkElement.lastElementChild : Node Read only htmlLinkElement.previousElementSibling : Node Read only htmlLinkElement.nextElementSibling : Node Read only htmlLinkElement.textContent : string htmlLinkElement.childNodes : NodeList Read only htmlLinkElement.children : HTMLCollection Read only htmlLinkElement.ownerDocument Read only htmlLinkElement.scrollIntoView() htmlLinkElement.scrollIntoViewIfNeeded() htmlLinkElement.focus() htmlLinkElement.blur() htmlLinkElement.getAttribute(name) Param Type name string htmlLinkElement.setAttribute(name, value) Param Type name string value string htmlLinkElement.removeAttribute(name) Param Type name string htmlLinkElement.hasAttribute(name) Param Type name string htmlLinkElement.getAttributeNode(name) Param Type name string htmlLinkElement.setAttributeNode(newAttr) Param Type newAttr * htmlLinkElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlLinkElement.click() htmlLinkElement.getElementsByClassName(name) Param Type name string htmlLinkElement.getElementsByTagName(name) Param Type name string htmlLinkElement.querySelector(selector) Param Type selector string htmlLinkElement.querySelectorAll(selector) Param Type selector string htmlLinkElement.getBoundingClientRect() htmlLinkElement.insertAdjacentHTML(position, value) Param Type position value string htmlLinkElement.insertAdjacentElement(position, node) Param Type position * node * htmlLinkElement.insertAdjacentText(position, text) Param Type position * text * htmlLinkElement.hasChildNodes() htmlLinkElement.cloneNode(deep) Param Type deep boolean htmlLinkElement.appendChild(child) Param Type child Node htmlLinkElement.insertBefore(child, before) Param Type child Node before Node htmlLinkElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlLinkElement.removeChild(child) Param Type child Node htmlLinkElement.remove() htmlLinkElement.before(...nodes) Param Type ...nodes Array. htmlLinkElement.after(...nodes) Param Type ...nodes Array. htmlLinkElement.replaceWith(...nodes) Param Type ...nodes Array. htmlLinkElement.contains(node) Param Type node Node htmlLinkElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlLinkElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlLinkElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLMenuElement.html":{"url":"reference/uxp/class/HTMLMenuElement.html","title":"Menu","keywords":"","body":" HTMLMenuElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLMenuElement HTMLMenuElement new HTMLMenuElement(document, nodeName, namespaceURI) .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .popupAt(x, y) .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLMenuElement(document, nodeName, namespaceURI) Creates an instance of HTMLMenuElement. Param Type document * nodeName * namespaceURI * htmlMenuElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlMenuElement.nodeName : string Read only htmlMenuElement.localName : string Read only htmlMenuElement.tagName : string Read only htmlMenuElement.nodeType : number Read only htmlMenuElement.namespaceURI : string Read only htmlMenuElement.id : string htmlMenuElement.tabIndex : number htmlMenuElement.className : string htmlMenuElement.attributes : NamedNodeMap Read only htmlMenuElement.style : Style Read only htmlMenuElement.clientLeft : number Read only htmlMenuElement.clientTop : number Read only htmlMenuElement.clientWidth : number Read only htmlMenuElement.clientHeight : number Read only htmlMenuElement.height : string or Number The height of the element htmlMenuElement.width : string or Number The width of the element htmlMenuElement.offsetParent : Element Read only htmlMenuElement.offsetLeft : number Read only htmlMenuElement.offsetTop : number Read only htmlMenuElement.offsetWidth : number Read only htmlMenuElement.offsetHeight : number Read only htmlMenuElement.scrollLeft : number htmlMenuElement.scrollTop : number htmlMenuElement.scrollWidth : number Read only htmlMenuElement.scrollHeight : number Read only htmlMenuElement.uxpContainer : UXPContainer Read only htmlMenuElement.disabled : boolean htmlMenuElement.innerHTML : string htmlMenuElement.outerHTML : string htmlMenuElement.contentEditable Read only htmlMenuElement.isConnected : boolean Read only htmlMenuElement.parentNode : Node Read only htmlMenuElement.parentElement : Element Read only htmlMenuElement.firstChild : Node Read only htmlMenuElement.lastChild : Node Read only htmlMenuElement.previousSibling : Node Read only htmlMenuElement.nextSibling : Node Read only htmlMenuElement.firstElementChild : Node Read only htmlMenuElement.lastElementChild : Node Read only htmlMenuElement.previousElementSibling : Node Read only htmlMenuElement.nextElementSibling : Node Read only htmlMenuElement.textContent : string htmlMenuElement.childNodes : NodeList Read only htmlMenuElement.children : HTMLCollection Read only htmlMenuElement.ownerDocument Read only htmlMenuElement.popupAt(x, y) Render the menu at the x,y coordinates Param Type x number y number htmlMenuElement.scrollIntoView() htmlMenuElement.scrollIntoViewIfNeeded() htmlMenuElement.focus() htmlMenuElement.blur() htmlMenuElement.getAttribute(name) Param Type name string htmlMenuElement.setAttribute(name, value) Param Type name string value string htmlMenuElement.removeAttribute(name) Param Type name string htmlMenuElement.hasAttribute(name) Param Type name string htmlMenuElement.getAttributeNode(name) Param Type name string htmlMenuElement.setAttributeNode(newAttr) Param Type newAttr * htmlMenuElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlMenuElement.click() htmlMenuElement.getElementsByClassName(name) Param Type name string htmlMenuElement.getElementsByTagName(name) Param Type name string htmlMenuElement.querySelector(selector) Param Type selector string htmlMenuElement.querySelectorAll(selector) Param Type selector string htmlMenuElement.getBoundingClientRect() htmlMenuElement.insertAdjacentHTML(position, value) Param Type position value string htmlMenuElement.insertAdjacentElement(position, node) Param Type position * node * htmlMenuElement.insertAdjacentText(position, text) Param Type position * text * htmlMenuElement.hasChildNodes() htmlMenuElement.cloneNode(deep) Param Type deep boolean htmlMenuElement.appendChild(child) Param Type child Node htmlMenuElement.insertBefore(child, before) Param Type child Node before Node htmlMenuElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlMenuElement.removeChild(child) Param Type child Node htmlMenuElement.remove() htmlMenuElement.before(...nodes) Param Type ...nodes Array. htmlMenuElement.after(...nodes) Param Type ...nodes Array. htmlMenuElement.replaceWith(...nodes) Param Type ...nodes Array. htmlMenuElement.contains(node) Param Type node Node htmlMenuElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlMenuElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlMenuElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLOptionElement.html":{"url":"reference/uxp/class/HTMLOptionElement.html","title":"Option","keywords":"","body":" HTMLOptionElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLOptionElement HTMLOptionElement new HTMLOptionElement(document, nodeName, namespaceURI) .value : string .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLOptionElement(document, nodeName, namespaceURI) Creates an instance of HTMLOptionElement. Param Type document * nodeName * namespaceURI * htmlOptionElement.value : string htmlOptionElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlOptionElement.nodeName : string Read only htmlOptionElement.localName : string Read only htmlOptionElement.tagName : string Read only htmlOptionElement.nodeType : number Read only htmlOptionElement.namespaceURI : string Read only htmlOptionElement.id : string htmlOptionElement.tabIndex : number htmlOptionElement.className : string htmlOptionElement.attributes : NamedNodeMap Read only htmlOptionElement.style : Style Read only htmlOptionElement.clientLeft : number Read only htmlOptionElement.clientTop : number Read only htmlOptionElement.clientWidth : number Read only htmlOptionElement.clientHeight : number Read only htmlOptionElement.height : string or Number The height of the element htmlOptionElement.width : string or Number The width of the element htmlOptionElement.offsetParent : Element Read only htmlOptionElement.offsetLeft : number Read only htmlOptionElement.offsetTop : number Read only htmlOptionElement.offsetWidth : number Read only htmlOptionElement.offsetHeight : number Read only htmlOptionElement.scrollLeft : number htmlOptionElement.scrollTop : number htmlOptionElement.scrollWidth : number Read only htmlOptionElement.scrollHeight : number Read only htmlOptionElement.uxpContainer : UXPContainer Read only htmlOptionElement.disabled : boolean htmlOptionElement.innerHTML : string htmlOptionElement.outerHTML : string htmlOptionElement.contentEditable Read only htmlOptionElement.isConnected : boolean Read only htmlOptionElement.parentNode : Node Read only htmlOptionElement.parentElement : Element Read only htmlOptionElement.firstChild : Node Read only htmlOptionElement.lastChild : Node Read only htmlOptionElement.previousSibling : Node Read only htmlOptionElement.nextSibling : Node Read only htmlOptionElement.firstElementChild : Node Read only htmlOptionElement.lastElementChild : Node Read only htmlOptionElement.previousElementSibling : Node Read only htmlOptionElement.nextElementSibling : Node Read only htmlOptionElement.textContent : string htmlOptionElement.childNodes : NodeList Read only htmlOptionElement.children : HTMLCollection Read only htmlOptionElement.ownerDocument Read only htmlOptionElement.scrollIntoView() htmlOptionElement.scrollIntoViewIfNeeded() htmlOptionElement.focus() htmlOptionElement.blur() htmlOptionElement.getAttribute(name) Param Type name string htmlOptionElement.setAttribute(name, value) Param Type name string value string htmlOptionElement.removeAttribute(name) Param Type name string htmlOptionElement.hasAttribute(name) Param Type name string htmlOptionElement.getAttributeNode(name) Param Type name string htmlOptionElement.setAttributeNode(newAttr) Param Type newAttr * htmlOptionElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlOptionElement.click() htmlOptionElement.getElementsByClassName(name) Param Type name string htmlOptionElement.getElementsByTagName(name) Param Type name string htmlOptionElement.querySelector(selector) Param Type selector string htmlOptionElement.querySelectorAll(selector) Param Type selector string htmlOptionElement.getBoundingClientRect() htmlOptionElement.insertAdjacentHTML(position, value) Param Type position value string htmlOptionElement.insertAdjacentElement(position, node) Param Type position * node * htmlOptionElement.insertAdjacentText(position, text) Param Type position * text * htmlOptionElement.hasChildNodes() htmlOptionElement.cloneNode(deep) Param Type deep boolean htmlOptionElement.appendChild(child) Param Type child Node htmlOptionElement.insertBefore(child, before) Param Type child Node before Node htmlOptionElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlOptionElement.removeChild(child) Param Type child Node htmlOptionElement.remove() htmlOptionElement.before(...nodes) Param Type ...nodes Array. htmlOptionElement.after(...nodes) Param Type ...nodes Array. htmlOptionElement.replaceWith(...nodes) Param Type ...nodes Array. htmlOptionElement.contains(node) Param Type node Node htmlOptionElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlOptionElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlOptionElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLScriptElement.html":{"url":"reference/uxp/class/HTMLScriptElement.html","title":"Script","keywords":"","body":" HTMLScriptElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement HTMLScriptElement new HTMLScriptElement(document, nodeName, namespaceURI) .type : string .src : string .charset : string .text : string .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLScriptElement(document, nodeName, namespaceURI) Creates an instance of HTMLScriptElement. Param Type document * nodeName * namespaceURI * htmlScriptElement.type : string htmlScriptElement.src : string htmlScriptElement.charset : string htmlScriptElement.text : string htmlScriptElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlScriptElement.nodeName : string Read only htmlScriptElement.localName : string Read only htmlScriptElement.tagName : string Read only htmlScriptElement.nodeType : number Read only htmlScriptElement.namespaceURI : string Read only htmlScriptElement.id : string htmlScriptElement.tabIndex : number htmlScriptElement.className : string htmlScriptElement.attributes : NamedNodeMap Read only htmlScriptElement.style : Style Read only htmlScriptElement.clientLeft : number Read only htmlScriptElement.clientTop : number Read only htmlScriptElement.clientWidth : number Read only htmlScriptElement.clientHeight : number Read only htmlScriptElement.height : string or Number The height of the element htmlScriptElement.width : string or Number The width of the element htmlScriptElement.offsetParent : Element Read only htmlScriptElement.offsetLeft : number Read only htmlScriptElement.offsetTop : number Read only htmlScriptElement.offsetWidth : number Read only htmlScriptElement.offsetHeight : number Read only htmlScriptElement.scrollLeft : number htmlScriptElement.scrollTop : number htmlScriptElement.scrollWidth : number Read only htmlScriptElement.scrollHeight : number Read only htmlScriptElement.uxpContainer : UXPContainer Read only htmlScriptElement.disabled : boolean htmlScriptElement.innerHTML : string htmlScriptElement.outerHTML : string htmlScriptElement.contentEditable Read only htmlScriptElement.isConnected : boolean Read only htmlScriptElement.parentNode : Node Read only htmlScriptElement.parentElement : Element Read only htmlScriptElement.firstChild : Node Read only htmlScriptElement.lastChild : Node Read only htmlScriptElement.previousSibling : Node Read only htmlScriptElement.nextSibling : Node Read only htmlScriptElement.firstElementChild : Node Read only htmlScriptElement.lastElementChild : Node Read only htmlScriptElement.previousElementSibling : Node Read only htmlScriptElement.nextElementSibling : Node Read only htmlScriptElement.textContent : string Overrides: textContent htmlScriptElement.childNodes : NodeList Read only htmlScriptElement.children : HTMLCollection Read only htmlScriptElement.ownerDocument Read only htmlScriptElement.scrollIntoView() htmlScriptElement.scrollIntoViewIfNeeded() htmlScriptElement.focus() htmlScriptElement.blur() htmlScriptElement.getAttribute(name) Param Type name string htmlScriptElement.setAttribute(name, value) Param Type name string value string htmlScriptElement.removeAttribute(name) Param Type name string htmlScriptElement.hasAttribute(name) Param Type name string htmlScriptElement.getAttributeNode(name) Param Type name string htmlScriptElement.setAttributeNode(newAttr) Param Type newAttr * htmlScriptElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlScriptElement.click() htmlScriptElement.getElementsByClassName(name) Param Type name string htmlScriptElement.getElementsByTagName(name) Param Type name string htmlScriptElement.querySelector(selector) Param Type selector string htmlScriptElement.querySelectorAll(selector) Param Type selector string htmlScriptElement.getBoundingClientRect() htmlScriptElement.insertAdjacentHTML(position, value) Param Type position value string htmlScriptElement.insertAdjacentElement(position, node) Param Type position * node * htmlScriptElement.insertAdjacentText(position, text) Param Type position * text * htmlScriptElement.hasChildNodes() htmlScriptElement.cloneNode(deep) Param Type deep boolean htmlScriptElement.appendChild(child) Param Type child Node htmlScriptElement.insertBefore(child, before) Param Type child Node before Node htmlScriptElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlScriptElement.removeChild(child) Param Type child Node htmlScriptElement.remove() htmlScriptElement.before(...nodes) Param Type ...nodes Array. htmlScriptElement.after(...nodes) Param Type ...nodes Array. htmlScriptElement.replaceWith(...nodes) Param Type ...nodes Array. htmlScriptElement.contains(node) Param Type node Node htmlScriptElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlScriptElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlScriptElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLSelectElement.html":{"url":"reference/uxp/class/HTMLSelectElement.html","title":"Select","keywords":"","body":" HTMLSelectElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLScriptElement HTMLSelectElement new HTMLSelectElement(document, nodeName, namespaceURI) .value : string .selectedIndex : number .selectedOptions : Array. .uxpVariant : string .uxpQuiet : string .options : NodeList .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLSelectElement(document, nodeName, namespaceURI) Creates an instance of HTMLSelectElement. Param Type document * nodeName * namespaceURI * htmlSelectElement.value : string htmlSelectElement.selectedIndex : number htmlSelectElement.selectedOptions : Array. htmlSelectElement.uxpVariant : string Variant htmlSelectElement.uxpQuiet : string Determines if control renders quietly htmlSelectElement.options : NodeList Read only htmlSelectElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlSelectElement.nodeName : string Read only htmlSelectElement.localName : string Read only htmlSelectElement.tagName : string Read only htmlSelectElement.nodeType : number Read only htmlSelectElement.namespaceURI : string Read only htmlSelectElement.id : string htmlSelectElement.tabIndex : number htmlSelectElement.className : string htmlSelectElement.attributes : NamedNodeMap Read only htmlSelectElement.style : Style Read only htmlSelectElement.clientLeft : number Read only htmlSelectElement.clientTop : number Read only htmlSelectElement.clientWidth : number Read only htmlSelectElement.clientHeight : number Read only htmlSelectElement.height : string or Number The height of the element htmlSelectElement.width : string or Number The width of the element htmlSelectElement.offsetParent : Element Read only htmlSelectElement.offsetLeft : number Read only htmlSelectElement.offsetTop : number Read only htmlSelectElement.offsetWidth : number Read only htmlSelectElement.offsetHeight : number Read only htmlSelectElement.scrollLeft : number htmlSelectElement.scrollTop : number htmlSelectElement.scrollWidth : number Read only htmlSelectElement.scrollHeight : number Read only htmlSelectElement.uxpContainer : UXPContainer Read only htmlSelectElement.disabled : boolean htmlSelectElement.innerHTML : string htmlSelectElement.outerHTML : string htmlSelectElement.contentEditable Read only htmlSelectElement.isConnected : boolean Read only htmlSelectElement.parentNode : Node Read only htmlSelectElement.parentElement : Element Read only htmlSelectElement.firstChild : Node Read only htmlSelectElement.lastChild : Node Read only htmlSelectElement.previousSibling : Node Read only htmlSelectElement.nextSibling : Node Read only htmlSelectElement.firstElementChild : Node Read only htmlSelectElement.lastElementChild : Node Read only htmlSelectElement.previousElementSibling : Node Read only htmlSelectElement.nextElementSibling : Node Read only htmlSelectElement.textContent : string htmlSelectElement.childNodes : NodeList Read only htmlSelectElement.children : HTMLCollection Read only htmlSelectElement.ownerDocument Read only htmlSelectElement.scrollIntoView() htmlSelectElement.scrollIntoViewIfNeeded() htmlSelectElement.focus() htmlSelectElement.blur() htmlSelectElement.getAttribute(name) Param Type name string htmlSelectElement.setAttribute(name, value) Param Type name string value string htmlSelectElement.removeAttribute(name) Param Type name string htmlSelectElement.hasAttribute(name) Param Type name string htmlSelectElement.getAttributeNode(name) Param Type name string htmlSelectElement.setAttributeNode(newAttr) Param Type newAttr * htmlSelectElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlSelectElement.click() htmlSelectElement.getElementsByClassName(name) Param Type name string htmlSelectElement.getElementsByTagName(name) Param Type name string htmlSelectElement.querySelector(selector) Param Type selector string htmlSelectElement.querySelectorAll(selector) Param Type selector string htmlSelectElement.getBoundingClientRect() htmlSelectElement.insertAdjacentHTML(position, value) Param Type position value string htmlSelectElement.insertAdjacentElement(position, node) Param Type position * node * htmlSelectElement.insertAdjacentText(position, text) Param Type position * text * htmlSelectElement.hasChildNodes() htmlSelectElement.cloneNode(deep) Param Type deep boolean htmlSelectElement.appendChild(child) Param Type child Node htmlSelectElement.insertBefore(child, before) Param Type child Node before Node htmlSelectElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlSelectElement.removeChild(child) Param Type child Node htmlSelectElement.remove() htmlSelectElement.before(...nodes) Param Type ...nodes Array. htmlSelectElement.after(...nodes) Param Type ...nodes Array. htmlSelectElement.replaceWith(...nodes) Param Type ...nodes Array. htmlSelectElement.contains(node) Param Type node Node htmlSelectElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlSelectElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlSelectElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLStyleElement.html":{"url":"reference/uxp/class/HTMLStyleElement.html","title":"Style","keywords":"","body":" HTMLStyleElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLStyleElement HTMLStyleElement new HTMLStyleElement(document, nodeName, namespaceURI) .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLStyleElement(document, nodeName, namespaceURI) Creates an instance of HTMLStyleElement. Param Type document * nodeName * namespaceURI * htmlStyleElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlStyleElement.nodeName : string Read only htmlStyleElement.localName : string Read only htmlStyleElement.tagName : string Read only htmlStyleElement.nodeType : number Read only htmlStyleElement.namespaceURI : string Read only htmlStyleElement.id : string htmlStyleElement.tabIndex : number htmlStyleElement.className : string htmlStyleElement.attributes : NamedNodeMap Read only htmlStyleElement.style : Style Read only htmlStyleElement.clientLeft : number Read only htmlStyleElement.clientTop : number Read only htmlStyleElement.clientWidth : number Read only htmlStyleElement.clientHeight : number Read only htmlStyleElement.height : string or Number The height of the element htmlStyleElement.width : string or Number The width of the element htmlStyleElement.offsetParent : Element Read only htmlStyleElement.offsetLeft : number Read only htmlStyleElement.offsetTop : number Read only htmlStyleElement.offsetWidth : number Read only htmlStyleElement.offsetHeight : number Read only htmlStyleElement.scrollLeft : number htmlStyleElement.scrollTop : number htmlStyleElement.scrollWidth : number Read only htmlStyleElement.scrollHeight : number Read only htmlStyleElement.uxpContainer : UXPContainer Read only htmlStyleElement.disabled : boolean htmlStyleElement.innerHTML : string htmlStyleElement.outerHTML : string htmlStyleElement.contentEditable Read only htmlStyleElement.isConnected : boolean Read only htmlStyleElement.parentNode : Node Read only htmlStyleElement.parentElement : Element Read only htmlStyleElement.firstChild : Node Read only htmlStyleElement.lastChild : Node Read only htmlStyleElement.previousSibling : Node Read only htmlStyleElement.nextSibling : Node Read only htmlStyleElement.firstElementChild : Node Read only htmlStyleElement.lastElementChild : Node Read only htmlStyleElement.previousElementSibling : Node Read only htmlStyleElement.nextElementSibling : Node Read only htmlStyleElement.textContent : string htmlStyleElement.childNodes : NodeList Read only htmlStyleElement.children : HTMLCollection Read only htmlStyleElement.ownerDocument Read only htmlStyleElement.scrollIntoView() htmlStyleElement.scrollIntoViewIfNeeded() htmlStyleElement.focus() htmlStyleElement.blur() htmlStyleElement.getAttribute(name) Param Type name string htmlStyleElement.setAttribute(name, value) Param Type name string value string htmlStyleElement.removeAttribute(name) Param Type name string htmlStyleElement.hasAttribute(name) Param Type name string htmlStyleElement.getAttributeNode(name) Param Type name string htmlStyleElement.setAttributeNode(newAttr) Param Type newAttr * htmlStyleElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlStyleElement.click() htmlStyleElement.getElementsByClassName(name) Param Type name string htmlStyleElement.getElementsByTagName(name) Param Type name string htmlStyleElement.querySelector(selector) Param Type selector string htmlStyleElement.querySelectorAll(selector) Param Type selector string htmlStyleElement.getBoundingClientRect() htmlStyleElement.insertAdjacentHTML(position, value) Param Type position value string htmlStyleElement.insertAdjacentElement(position, node) Param Type position * node * htmlStyleElement.insertAdjacentText(position, text) Param Type position * text * htmlStyleElement.hasChildNodes() htmlStyleElement.cloneNode(deep) Param Type deep boolean htmlStyleElement.appendChild(child) Param Type child Node htmlStyleElement.insertBefore(child, before) Param Type child Node before Node htmlStyleElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlStyleElement.removeChild(child) Param Type child Node htmlStyleElement.remove() htmlStyleElement.before(...nodes) Param Type ...nodes Array. htmlStyleElement.after(...nodes) Param Type ...nodes Array. htmlStyleElement.replaceWith(...nodes) Param Type ...nodes Array. htmlStyleElement.contains(node) Param Type node Node htmlStyleElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlStyleElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlStyleElement.dispatchEvent(event) Param Type event * "},"reference/uxp/class/HTMLTextAreaElement.html":{"url":"reference/uxp/class/HTMLTextAreaElement.html","title":"TextArea","keywords":"","body":" HTMLTextAreaElement Extends: HTMLElement See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLTextAreaElement HTMLTextAreaElement new HTMLTextAreaElement(document, nodeName, namespaceURI) .value : string .placeholder : string .readOnly : boolean .dataset .nodeName : string .localName : string .tagName : string .nodeType : number .namespaceURI : string .id : string .tabIndex : number .className : string .attributes : NamedNodeMap .style : Style .clientLeft : number .clientTop : number .clientWidth : number .clientHeight : number .height : string or Number .width : string or Number .offsetParent : Element .offsetLeft : number .offsetTop : number .offsetWidth : number .offsetHeight : number .scrollLeft : number .scrollTop : number .scrollWidth : number .scrollHeight : number .uxpContainer : UXPContainer .disabled : boolean .innerHTML : string .outerHTML : string .contentEditable .isConnected : boolean .parentNode : Node .parentElement : Element .firstChild : Node .lastChild : Node .previousSibling : Node .nextSibling : Node .firstElementChild : Node .lastElementChild : Node .previousElementSibling : Node .nextElementSibling : Node .textContent : string .childNodes : NodeList .children : HTMLCollection .ownerDocument .scrollIntoView() .scrollIntoViewIfNeeded() .focus() .blur() .getAttribute(name) .setAttribute(name, value) .removeAttribute(name) .hasAttribute(name) .getAttributeNode(name) .setAttributeNode(newAttr) .removeAttributeNode(oldAttr) .click() .getElementsByClassName(name) .getElementsByTagName(name) .querySelector(selector) .querySelectorAll(selector) .getBoundingClientRect() .insertAdjacentHTML(position, value) .insertAdjacentElement(position, node) .insertAdjacentText(position, text) .hasChildNodes() .cloneNode(deep) .appendChild(child) .insertBefore(child, before) .replaceChild(newChild, oldChild) .removeChild(child) .remove() .before(...nodes) .after(...nodes) .replaceWith(...nodes) .contains(node) .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) new HTMLTextAreaElement(document, nodeName, namespaceURI) Creates an instance of HTMLTextAreaElement. Param Type document * nodeName * namespaceURI * htmlTextAreaElement.value : string htmlTextAreaElement.placeholder : string htmlTextAreaElement.readOnly : boolean htmlTextAreaElement.dataset Access to all the custom data attributes (data-*) set. See: https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset htmlTextAreaElement.nodeName : string Read only htmlTextAreaElement.localName : string Read only htmlTextAreaElement.tagName : string Read only htmlTextAreaElement.nodeType : number Read only htmlTextAreaElement.namespaceURI : string Read only htmlTextAreaElement.id : string htmlTextAreaElement.tabIndex : number htmlTextAreaElement.className : string htmlTextAreaElement.attributes : NamedNodeMap Read only htmlTextAreaElement.style : Style Read only htmlTextAreaElement.clientLeft : number Read only htmlTextAreaElement.clientTop : number Read only htmlTextAreaElement.clientWidth : number Read only htmlTextAreaElement.clientHeight : number Read only htmlTextAreaElement.height : string or Number The height of the element htmlTextAreaElement.width : string or Number The width of the element htmlTextAreaElement.offsetParent : Element Read only htmlTextAreaElement.offsetLeft : number Read only htmlTextAreaElement.offsetTop : number Read only htmlTextAreaElement.offsetWidth : number Read only htmlTextAreaElement.offsetHeight : number Read only htmlTextAreaElement.scrollLeft : number htmlTextAreaElement.scrollTop : number htmlTextAreaElement.scrollWidth : number Read only htmlTextAreaElement.scrollHeight : number Read only htmlTextAreaElement.uxpContainer : UXPContainer Read only htmlTextAreaElement.disabled : boolean htmlTextAreaElement.innerHTML : string htmlTextAreaElement.outerHTML : string htmlTextAreaElement.contentEditable Read only htmlTextAreaElement.isConnected : boolean Read only htmlTextAreaElement.parentNode : Node Read only htmlTextAreaElement.parentElement : Element Read only htmlTextAreaElement.firstChild : Node Read only htmlTextAreaElement.lastChild : Node Read only htmlTextAreaElement.previousSibling : Node Read only htmlTextAreaElement.nextSibling : Node Read only htmlTextAreaElement.firstElementChild : Node Read only htmlTextAreaElement.lastElementChild : Node Read only htmlTextAreaElement.previousElementSibling : Node Read only htmlTextAreaElement.nextElementSibling : Node Read only htmlTextAreaElement.textContent : string htmlTextAreaElement.childNodes : NodeList Read only htmlTextAreaElement.children : HTMLCollection Read only htmlTextAreaElement.ownerDocument Read only htmlTextAreaElement.scrollIntoView() htmlTextAreaElement.scrollIntoViewIfNeeded() htmlTextAreaElement.focus() htmlTextAreaElement.blur() htmlTextAreaElement.getAttribute(name) Param Type name string htmlTextAreaElement.setAttribute(name, value) Param Type name string value string htmlTextAreaElement.removeAttribute(name) Param Type name string htmlTextAreaElement.hasAttribute(name) Param Type name string htmlTextAreaElement.getAttributeNode(name) Param Type name string htmlTextAreaElement.setAttributeNode(newAttr) Param Type newAttr * htmlTextAreaElement.removeAttributeNode(oldAttr) Param Type oldAttr * htmlTextAreaElement.click() htmlTextAreaElement.getElementsByClassName(name) Param Type name string htmlTextAreaElement.getElementsByTagName(name) Param Type name string htmlTextAreaElement.querySelector(selector) Param Type selector string htmlTextAreaElement.querySelectorAll(selector) Param Type selector string htmlTextAreaElement.getBoundingClientRect() htmlTextAreaElement.insertAdjacentHTML(position, value) Param Type position value string htmlTextAreaElement.insertAdjacentElement(position, node) Param Type position * node * htmlTextAreaElement.insertAdjacentText(position, text) Param Type position * text * htmlTextAreaElement.hasChildNodes() htmlTextAreaElement.cloneNode(deep) Param Type deep boolean htmlTextAreaElement.appendChild(child) Param Type child Node htmlTextAreaElement.insertBefore(child, before) Param Type child Node before Node htmlTextAreaElement.replaceChild(newChild, oldChild) Param Type newChild Node oldChild Node htmlTextAreaElement.removeChild(child) Param Type child Node htmlTextAreaElement.remove() htmlTextAreaElement.before(...nodes) Param Type ...nodes Array. htmlTextAreaElement.after(...nodes) Param Type ...nodes Array. htmlTextAreaElement.replaceWith(...nodes) Param Type ...nodes Array. htmlTextAreaElement.contains(node) Param Type node Node htmlTextAreaElement.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlTextAreaElement.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false htmlTextAreaElement.dispatchEvent(event) Param Type event * "},"reference/uxp/events-index.html":{"url":"reference/uxp/events-index.html","title":"Events","keywords":"","body":"Events Adobe XD supports a subset of HTML events. Event MDN Link blur MDN docs change MDN docs click MDN docs close MDN docs focus MDN docs input MDN docs keydown MDN docs load MDN docs message MDN docs pointerEnter MDN docs pointerMove MDN docs pointerLeave MDN docs progress MDN docs resize MDN docs The following event classes are supported by XD: BaseUIEvent CloseEvent Event EventTarget FocusEvent GestureEvent KeyboardEvent MessageEvent PointerEvent ProgressEvent blur Dispatched whenever the focus leaves the currently focused control. This can be useful if you want to validate the contents of a field immediately after entry. element.addEventListener(\"blur\", evt => { if (Number.isNaN(Number(evt.target.value))) { evt.target.value = \"\"; } });     Applies to Focusable controls (input elements, buttons) Since XD 13 change Dispatched after the contents of an input control change. This event only occurs after the last input to the control; so you won't see an event for every key press or mouse move. element.addEventListener(\"change\", evt => { console.log(evt.target.data); });     Applies to Focusable controls (input elements, buttons) Since XD 13 click Dispatched when the user clicks or taps on the element. Subsequent clicks may be ignored if they fall within the \"double click\" time span.     Applies to All elements Since XD 13 close Dispatched when a websocket is closed.     Applies to WebSocket Since XD 13 focus Dispatched whenever a focusable control receives focus.     Applies to All focusable controls (input elements, buttons) Since XD 13 input Dispatched whenever there is input in an input control. This will fire with every change.     Applies to All focusable controls (input elements, buttons) Since XD 13 keydown Dispatched whenever a key is pressed.     Applies to All focusable controls (input elements, buttons) Since XD 13 load Dispatched when the element has loaded.     Applies to Dialogs ( HTMLDialogElement ) Since XD 13 message Dispatched when a websocket receives a message.     Applies to WebSocket Since XD 13 pointerEnter Dispatched when the mouse cursor enters the element's bounds.     Applies to All non-interactive elements. Interactive elements do not support pointer events. Since XD 13 pointerMove Dispatched when the mouse cursor moves within the element's bounds.     Applies to All non-interactive elements. Interactive elements do not support pointer events. Since XD 13 pointerLeave Dispatched when the mouse cursor leaves the element's bounds.     Applies to All non-interactive elements. Interactive elements do not support pointer events. Since XD 13 progress Dispatched whenever there is some progress to report in an XMLHttpRequest transfer.     Applies to XMLHttpRequest Since XD 13 resize Dispatched whenever a dialog is resized. Since dialogs cannot be currently resized, this event only fires once, when the dialog is made visible.     Applies to Dialogs ( HTMLDialogElement ) Since XD 13 "},"reference/uxp/class/BaseUIEvent.html":{"url":"reference/uxp/class/BaseUIEvent.html","title":"BaseUIEvent","keywords":"","body":" BaseUIEvent Extends: Event See: https://developer.mozilla.org/en-US/docs/Web/API/UIEvent BaseUIEvent new BaseUIEvent(type, eventInit) instance .pointerId .width : number .height : number .pressure : number .tangentialPressure : number .tiltX : number .tiltY : number .twist : number .clientX : number .clientY : number .offsetX : number .offsetY : number .pageX : number .pageY : number .screenX : number .screenY : number .movementX : number .movementY : number .button : number .buttons .detail .pointerType .altKey .shiftKey .metaKey .ctrlKey .isPrimary .which .type .isTrusted : boolean .target : Node .currentTarget : Node .bubbles : boolean .cancelable : boolean .eventPhase .defaultPrevented : boolean .returnValue : * .preventDefault() .stopImmediatePropagation() .stopPropagation() static .WheelEvent#deltaMove : number new BaseUIEvent(type, eventInit) Creates an instance of BaseUIEvent. Param Type type * eventInit * baseUIEvent.pointerId Read only baseUIEvent.width : number Read only baseUIEvent.height : number Read only baseUIEvent.pressure : number Read only baseUIEvent.tangentialPressure : number Read only baseUIEvent.tiltX : number Read only baseUIEvent.tiltY : number Read only baseUIEvent.twist : number Read only baseUIEvent.clientX : number Read only baseUIEvent.clientY : number Read only baseUIEvent.offsetX : number Read only baseUIEvent.offsetY : number Read only baseUIEvent.pageX : number Read only baseUIEvent.pageY : number Read only baseUIEvent.screenX : number Read only baseUIEvent.screenY : number Read only baseUIEvent.movementX : number Read only baseUIEvent.movementY : number Read only baseUIEvent.button : number Read only baseUIEvent.buttons Read only baseUIEvent.detail Read only baseUIEvent.pointerType Read only baseUIEvent.altKey Read only baseUIEvent.shiftKey Read only baseUIEvent.metaKey Read only baseUIEvent.ctrlKey Read only baseUIEvent.isPrimary Read only baseUIEvent.which Read only baseUIEvent.type Read only baseUIEvent.isTrusted : boolean Read only baseUIEvent.target : Node Read only baseUIEvent.currentTarget : Node Read only baseUIEvent.bubbles : boolean Read only baseUIEvent.cancelable : boolean Read only baseUIEvent.eventPhase Read only baseUIEvent.defaultPrevented : boolean Read only baseUIEvent.returnValue : * baseUIEvent.preventDefault() baseUIEvent.stopImmediatePropagation() baseUIEvent.stopPropagation() BaseUIEvent.WheelEvent#deltaMove : number Read only "},"reference/uxp/class/CloseEvent.html":{"url":"reference/uxp/class/CloseEvent.html","title":"CloseEvent","keywords":"","body":" CloseEvent Extends: Event See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent CloseEvent new CloseEvent(code, reason, wasClean) .code .reason .wasClean .type .isTrusted : boolean .target : Node .currentTarget : Node .bubbles : boolean .cancelable : boolean .eventPhase .defaultPrevented : boolean .returnValue : * .preventDefault() .stopImmediatePropagation() .stopPropagation() new CloseEvent(code, reason, wasClean) Creates an instance of CloseEvent. Param Type code * reason * wasClean * closeEvent.code Returns: number - returns the close code sent by the server. closeEvent.reason Returns: number - returns the string indicating the reason the server closed the connection.. closeEvent.wasClean Returns: boolean - returns a boolean that inndicates whether or not the connection was cleanly closed. closeEvent.type Read only closeEvent.isTrusted : boolean Read only closeEvent.target : Node Read only closeEvent.currentTarget : Node Read only closeEvent.bubbles : boolean Read only closeEvent.cancelable : boolean Read only closeEvent.eventPhase Read only closeEvent.defaultPrevented : boolean Read only closeEvent.returnValue : * closeEvent.preventDefault() closeEvent.stopImmediatePropagation() closeEvent.stopPropagation() "},"reference/uxp/class/Event.html":{"url":"reference/uxp/class/Event.html","title":"Event","keywords":"","body":" Event See: https://developer.mozilla.org/en-US/docs/Web/API/Event Event new Event(eventType, eventInit) instance .type .isTrusted : boolean .target : Node .currentTarget : Node .bubbles : boolean .cancelable : boolean .eventPhase .defaultPrevented : boolean .returnValue : * .preventDefault() .stopImmediatePropagation() .stopPropagation() static .NONE .CAPTURING_PHASE .AT_TARGET .BUBBLING_PHASE new Event(eventType, eventInit) Creates an instance of Event. Param Type eventType * eventInit * event.type Read only event.isTrusted : boolean Read only event.target : Node Read only event.currentTarget : Node Read only event.bubbles : boolean Read only event.cancelable : boolean Read only event.eventPhase Read only event.defaultPrevented : boolean Read only event.returnValue : * event.preventDefault() event.stopImmediatePropagation() event.stopPropagation() Event.NONE Event.CAPTURING_PHASE Event.AT_TARGET Event.BUBBLING_PHASE "},"reference/uxp/class/EventTarget.html":{"url":"reference/uxp/class/EventTarget.html","title":"EventTarget","keywords":"","body":" EventTarget See: https://developer.mozilla.org/en-US/docs/Web/API/EventTarget EventTarget .addEventListener(eventName, callback, [capture]) .removeEventListener(eventName, callback, [capture]) .dispatchEvent(event) eventTarget.addEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false eventTarget.removeEventListener(eventName, callback, [capture]) Param Type Default eventName * callback * [capture] boolean false eventTarget.dispatchEvent(event) Param Type event * "},"reference/uxp/class/FocusEvent.html":{"url":"reference/uxp/class/FocusEvent.html","title":"FocusEvent","keywords":"","body":" FocusEvent Extends: Event See: https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent FocusEvent new FocusEvent(type, eventInit) .relatedTarget .type .isTrusted : boolean .target : Node .currentTarget : Node .bubbles : boolean .cancelable : boolean .eventPhase .defaultPrevented : boolean .returnValue : * .preventDefault() .stopImmediatePropagation() .stopPropagation() new FocusEvent(type, eventInit) Creates an instance of FocusEvent. Param Type type * eventInit * focusEvent.relatedTarget Read only focusEvent.type Read only focusEvent.isTrusted : boolean Read only focusEvent.target : Node Read only focusEvent.currentTarget : Node Read only focusEvent.bubbles : boolean Read only focusEvent.cancelable : boolean Read only focusEvent.eventPhase Read only focusEvent.defaultPrevented : boolean Read only focusEvent.returnValue : * focusEvent.preventDefault() focusEvent.stopImmediatePropagation() focusEvent.stopPropagation() "},"reference/uxp/class/GestureEvent.html":{"url":"reference/uxp/class/GestureEvent.html","title":"GestureEvent","keywords":"","body":" GestureEvent Extends: BaseUIEvent See: https://developer.mozilla.org/en-US/docs/Web/API/GestureEvent GestureEvent new GestureEvent(type, eventInit) .expansion : number .rotation : number .scale : number .translationX : number .translationY : number .velocityAngular : number .velocityExpansion : number .velocityX : number .velocityY : number .pointerId .width : number .height : number .pressure : number .tangentialPressure : number .tiltX : number .tiltY : number .twist : number .clientX : number .clientY : number .offsetX : number .offsetY : number .pageX : number .pageY : number .screenX : number .screenY : number .movementX : number .movementY : number .button : number .buttons .detail .pointerType .altKey .shiftKey .metaKey .ctrlKey .isPrimary .which .type .isTrusted : boolean .target : Node .currentTarget : Node .bubbles : boolean .cancelable : boolean .eventPhase .defaultPrevented : boolean .returnValue : * .preventDefault() .stopImmediatePropagation() .stopPropagation() new GestureEvent(type, eventInit) Creates an instance of GestureEvent. Param Type type * eventInit * gestureEvent.expansion : number Read only gestureEvent.rotation : number Read only gestureEvent.scale : number Read only gestureEvent.translationX : number Read only gestureEvent.translationY : number Read only gestureEvent.velocityAngular : number Read only gestureEvent.velocityExpansion : number Read only gestureEvent.velocityX : number Read only gestureEvent.velocityY : number Read only gestureEvent.pointerId Read only gestureEvent.width : number Read only gestureEvent.height : number Read only gestureEvent.pressure : number Read only gestureEvent.tangentialPressure : number Read only gestureEvent.tiltX : number Read only gestureEvent.tiltY : number Read only gestureEvent.twist : number Read only gestureEvent.clientX : number Read only gestureEvent.clientY : number Read only gestureEvent.offsetX : number Read only gestureEvent.offsetY : number Read only gestureEvent.pageX : number Read only gestureEvent.pageY : number Read only gestureEvent.screenX : number Read only gestureEvent.screenY : number Read only gestureEvent.movementX : number Read only gestureEvent.movementY : number Read only gestureEvent.button : number Read only gestureEvent.buttons Read only gestureEvent.detail Read only gestureEvent.pointerType Read only gestureEvent.altKey Read only gestureEvent.shiftKey Read only gestureEvent.metaKey Read only gestureEvent.ctrlKey Read only gestureEvent.isPrimary Read only gestureEvent.which Read only gestureEvent.type Read only gestureEvent.isTrusted : boolean Read only gestureEvent.target : Node Read only gestureEvent.currentTarget : Node Read only gestureEvent.bubbles : boolean Read only gestureEvent.cancelable : boolean Read only gestureEvent.eventPhase Read only gestureEvent.defaultPrevented : boolean Read only gestureEvent.returnValue : * gestureEvent.preventDefault() gestureEvent.stopImmediatePropagation() gestureEvent.stopPropagation() "},"reference/uxp/class/KeyboardEvent.html":{"url":"reference/uxp/class/KeyboardEvent.html","title":"KeyboardEvent","keywords":"","body":" KeyboardEvent Extends: Event See: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent KeyboardEvent new KeyboardEvent(type, eventInit) .altKey .ctrlKey .metaKey .shiftKey .code .keyCode .key .location .repeat .type .isTrusted : boolean .target : Node .currentTarget : Node .bubbles : boolean .cancelable : boolean .eventPhase .defaultPrevented : boolean .returnValue : * .getModifierState(keyArgs) .preventDefault() .stopImmediatePropagation() .stopPropagation() new KeyboardEvent(type, eventInit) Creates an instance of KeyboardEvent. Param Type type * eventInit * keyboardEvent.altKey Read only keyboardEvent.ctrlKey Read only keyboardEvent.metaKey Read only keyboardEvent.shiftKey Read only keyboardEvent.code Read only keyboardEvent.keyCode Read only keyboardEvent.key Read only keyboardEvent.location Read only keyboardEvent.repeat Read only keyboardEvent.type Read only keyboardEvent.isTrusted : boolean Read only keyboardEvent.target : Node Read only keyboardEvent.currentTarget : Node Read only keyboardEvent.bubbles : boolean Read only keyboardEvent.cancelable : boolean Read only keyboardEvent.eventPhase Read only keyboardEvent.defaultPrevented : boolean Read only keyboardEvent.returnValue : * keyboardEvent.getModifierState(keyArgs) Param Type keyArgs string keyboardEvent.preventDefault() keyboardEvent.stopImmediatePropagation() keyboardEvent.stopPropagation() "},"reference/uxp/class/MessageEvent.html":{"url":"reference/uxp/class/MessageEvent.html","title":"MessageEvent","keywords":"","body":" MessageEvent Extends: Event See: https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent MessageEvent new MessageEvent(data, origin, source, eventInit) .data .origin .source .type .isTrusted : boolean .target : Node .currentTarget : Node .bubbles : boolean .cancelable : boolean .eventPhase .defaultPrevented : boolean .returnValue : * .preventDefault() .stopImmediatePropagation() .stopPropagation() new MessageEvent(data, origin, source, eventInit) Creates an instance of MessageEvent. Param Type data * origin * source * eventInit * messageEvent.data Returns: string - returns the data sent by the server. messageEvent.origin Returns: string - returns the origin of the message. messageEvent.source Returns: string - returns the string indicating the messageEventSource. messageEvent.type Read only messageEvent.isTrusted : boolean Read only messageEvent.target : Node Read only messageEvent.currentTarget : Node Read only messageEvent.bubbles : boolean Read only messageEvent.cancelable : boolean Read only messageEvent.eventPhase Read only messageEvent.defaultPrevented : boolean Read only messageEvent.returnValue : * messageEvent.preventDefault() messageEvent.stopImmediatePropagation() messageEvent.stopPropagation() "},"reference/uxp/class/PointerEvent.html":{"url":"reference/uxp/class/PointerEvent.html","title":"PointerEvent","keywords":"","body":" PointerEvent Extends: BaseUIEvent See: https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent PointerEvent new PointerEvent(type, eventInit) .pointerId .width : number .height : number .pressure : number .tangentialPressure : number .tiltX : number .tiltY : number .twist : number .clientX : number .clientY : number .offsetX : number .offsetY : number .pageX : number .pageY : number .screenX : number .screenY : number .movementX : number .movementY : number .button : number .buttons .detail .pointerType .altKey .shiftKey .metaKey .ctrlKey .isPrimary .which .type .isTrusted : boolean .target : Node .currentTarget : Node .bubbles : boolean .cancelable : boolean .eventPhase .defaultPrevented : boolean .returnValue : * .preventDefault() .stopImmediatePropagation() .stopPropagation() new PointerEvent(type, eventInit) Creates an instance of PointerEvent. Param Type type * eventInit * pointerEvent.pointerId Read only pointerEvent.width : number Read only pointerEvent.height : number Read only pointerEvent.pressure : number Read only pointerEvent.tangentialPressure : number Read only pointerEvent.tiltX : number Read only pointerEvent.tiltY : number Read only pointerEvent.twist : number Read only pointerEvent.clientX : number Read only pointerEvent.clientY : number Read only pointerEvent.offsetX : number Read only pointerEvent.offsetY : number Read only pointerEvent.pageX : number Read only pointerEvent.pageY : number Read only pointerEvent.screenX : number Read only pointerEvent.screenY : number Read only pointerEvent.movementX : number Read only pointerEvent.movementY : number Read only pointerEvent.button : number Read only pointerEvent.buttons Read only pointerEvent.detail Read only pointerEvent.pointerType Read only pointerEvent.altKey Read only pointerEvent.shiftKey Read only pointerEvent.metaKey Read only pointerEvent.ctrlKey Read only pointerEvent.isPrimary Read only pointerEvent.which Read only pointerEvent.type Read only pointerEvent.isTrusted : boolean Read only pointerEvent.target : Node Read only pointerEvent.currentTarget : Node Read only pointerEvent.bubbles : boolean Read only pointerEvent.cancelable : boolean Read only pointerEvent.eventPhase Read only pointerEvent.defaultPrevented : boolean Read only pointerEvent.returnValue : * pointerEvent.preventDefault() pointerEvent.stopImmediatePropagation() pointerEvent.stopPropagation() "},"reference/uxp/class/ProgressEvent.html":{"url":"reference/uxp/class/ProgressEvent.html","title":"ProgressEvent","keywords":"","body":" ProgressEvent Extends: Event See https://developer.mozilla.org/en-US/docs/Web/API/ProgressEvent https://xhr.spec.whatwg.org/#progressevent ProgressEvent instance .type .isTrusted : boolean .target : Node .currentTarget : Node .bubbles : boolean .cancelable : boolean .eventPhase .defaultPrevented : boolean .returnValue : * .preventDefault() .stopImmediatePropagation() .stopPropagation() static .module.exports new module.exports(typeArg, [eventInit]) .lengthComputable .loaded .total .initEvent(typeArg, bubbles, cancelable) progressEvent.type Read only progressEvent.isTrusted : boolean Read only progressEvent.target : Node Read only progressEvent.currentTarget : Node Read only progressEvent.bubbles : boolean Read only progressEvent.cancelable : boolean Read only progressEvent.eventPhase Read only progressEvent.defaultPrevented : boolean Read only progressEvent.returnValue : * progressEvent.preventDefault() progressEvent.stopImmediatePropagation() progressEvent.stopPropagation() ProgressEvent.module.exports new module.exports(typeArg, [eventInit]) Creates an instance of ProgressEvent. Param Type Default typeArg * [eventInit] * {} ProgressEvent.lengthComputable Read only ProgressEvent.loaded Read only ProgressEvent.total Read only ProgressEvent.initEvent(typeArg, bubbles, cancelable) Param Type typeArg * bubbles * cancelable * "},"reference/xd-index.html":{"url":"reference/xd-index.html","title":"XD specific","keywords":"","body":"XD specifics APIs XD specific APIs enable developers to extend XD specific features. Using these APIs, developers can create plugins that create, read, update, and delete objects inside XD documents. Also, most other features available in XD, such as creating renditions, modifying assets panel, getting prototype data, conducting commands, and others are also available through these APIs. scenegraph application assets clipboard cloud interactions commands viewport "},"reference/scenegraph.html":{"url":"reference/scenegraph.html","title":"scenegraph","keywords":"","body":" scenegraph The scenegraph is a node tree which represents the structure of the XD document. It closely matches the hierarchy seen in the Layers panel inside XD. Some scenenodes may contain children (e.g., a Group or Artboard), while others are leaf nodes (e.g., a Rectangle or Text node). The root of the scenegraph contains all Artboards that exist in the document, as well as all pasteboard content (nodes that are not contained by any artboard). You can modify properties on any scenenodes within the current edit context, and add leaf nodes to the current edit context, but you cannot make structural changes directly to the scenegraph tree. Instead, use commands. Typically, you access scenegraph nodes via the selection argument that is passed to your plugin command, or by traversing the entire document tree using the documentRoot argument that is passed to your plugin command. These objects are also accessible on the scenegraph module for convenience. Example function myCommand(selection) { let node = selection.items[0]; console.log(\"The selected node is a: \" + node.constructor.name); // Print out types of all child nodes (if any) node.children.forEach(function (childNode, i) { console.log(\"Child \" + i + \" is a \" + childNode.constructor.name); }); } To create new scenenodes, load this scenegraph module directly and use the node constructor functions: Example let scenegraph = require(\"scenegraph\"); function myCommand(selection) { let newShape = new scenegraph.Rectangle(); newShape.width = 100; newShape.height = 50; newShape.fill = new Color(\"red\"); selection.insertionParent.addChild(newShape); } Class hierarchy Note: Additional subclasses may be added in the future. Always be sure to have a default case for unknown scenenode classes when traversing the scenegraph. SceneNode GraphicNode Artboard Rectangle Ellipse Polygon Line Path BooleanGroup Text Group SymbolInstance RepeatGrid LinkedGraphic RootNode Typedefs Point : !{x:number, y:number} Bounds : !{x:number, y:number, width:number, height:number} Related classes These classes are not scenenode types, but are used extensively in the scenegraph API: Color - Value object for fill, stroke, and other properties ImageFill - Value object for fill property LinearGradientFill - Value object for fill property Matrix - Value object for transform property Shadow - Value object for shadow property Blur - Value object for blur property Other module members selection : !Selection root : !RootNode getNodeByGUID(guid) ⇒ ?SceneNode scenegraph.selection : !Selection Object representing the current selection state and edit context. Also available as the first argument passed to your plugin command handler function. Kind: static property of scenegraph Read only: true Since: XD 14 scenegraph.root : !RootNode Root node of the current document's scenegraph. Also available as the second argument passed to your plugin command handler function. Kind: static property of scenegraph Read only: true Since: XD 14 scenegraph.getNodeByGUID(guid) Since: XD 28 Returns the scenenode in this document that has the given node GUID. Returns undefined if no such node exists connected to the scenegraph tree (detached/orphan nodes will not be found). This provides a fast way of persistently remembering a node across plugin operations and even across document open/closes. Kind: static method of scenegraph Returns: ?SceneNode Param Type Description guid string SceneNode GUID -- must be all lowercase, as returned by the guid getter. Example let node = scenegraph.selection.items[0]; let guid = node.guid; // ...later on: let sameNode = scenegraph.getNodeByGUID(guid); if (sameNode) { // ^ Always check if node still exists - user may have deleted it console.log(\"Found node again!\", sameNode); } SceneNode Kind: abstract class Base class of all scenegraph nodes. Nodes will always be an instance of some subclass of SceneNode. SceneNode .guid : string .parent : SceneNode .children : !SceneNodeList .isInArtworkTree : boolean .isContainer : boolean .selected : boolean .visible : boolean .opacity : number .blendMode : string .transform : !Matrix .translation : !{x:number, y:number} .rotation : number .globalBounds : !Bounds .localBounds : !Bounds .boundsInParent : !Bounds .topLeftInParent : !Point .localCenterPoint : !Point .globalDrawBounds : !Bounds .name : string .hasDefaultName : boolean .locked : boolean .markedForExport : boolean .fixedWhenScrolling : ?boolean .triggeredInteractions : !Arrray .hasLinkedContent : boolean .pluginData : * .removeFromParent() .moveInParentCoordinates(deltaX, deltaY) .placeInParentCoordinates(registrationPoint, parentPoint) .rotateAround(deltaAngle, rotationCenter) .resize(width, height) sceneNode.guid : string Returns a unique identifier for this node that stays the same when the file is closed & reopened, or if the node is moved to a different part of the document. Cut-Paste will result in a new GUID, however. The GUID is guaranteed unique within the current document, but other documents may contain the same GUID value. For example, if the user makes a copy of an XD file, both files will use the same GUIDs. The GUID of the root node changes if the document is duplicated via Save As. See application.activeDocument.guid for details. Node objects can be destroyed and recreated during operations such as Undo/Redo, so if you need to store a reference to a node even between operations in the same session, it's best to store the GUID and then retrieve the node later via getNodeByGuid(). Kind: instance property of SceneNode Read only: true sceneNode.parent : SceneNode Returns the parent node. Null if this is the root node, or a freshly constructed node which has not been added to a parent yet. Kind: instance property of SceneNode Read only: true sceneNode.children : !SceneNodeList Returns a list of this node's children. List is length 0 if the node has no children. The first child is lowest in the z order. This list is not an Array, so you must use at(i) instead of [i] to access children by index. It has a number of Array-like methods such as forEach() for convenience and improved performance, however. The list is immutable. Use removeFromParent and addChild to add/remove child nodes. Kind: instance property of SceneNode Read only: true Example let node = ...; console.log(\"Node has \" + node.children.length + \" children\"); console.log(\"First child: \" + node.children.at(0)); // do not use `[0]` - it will not work! node.children.forEach(function (childNode, i) { console.log(\"Child \" + i + \" is a \" + childNode.constructor.name); }); sceneNode.isInArtworkTree : boolean True if the node's parent chain connects back to the document root node. Kind: instance property of SceneNode Read only: true sceneNode.isContainer : boolean True if this node is a type that could have children (e.g. an Artboard, Group, Boolean Group, etc.). Kind: instance property of SceneNode Read only: true sceneNode.selected : boolean True if this node is part of the current selection. To get a list of all selected nodes or change which nodes are selected, use selection. Kind: instance property of SceneNode Read only: true See: selection sceneNode.visible : boolean False if this node has been hidden by the user (eyeball toggle in Layers panel). If true, the node may still be invisible for other reasons: a parent or grandparent has visible=false, the node has opacity=0%, the node is clipped by a mask, etc. Kind: instance property of SceneNode sceneNode.opacity : number (0.0 - 1.0) Node's opacity setting. The overall visual opacity seen in the document is determined by combining this value with the opacities of the node's entire parent chain, as well as the opacity settings of its fill/stroke properties if this is a leaf node. Kind: instance property of SceneNode sceneNode.blendMode : string Default: BLEND_MODE_PASSTHROUGH Since: XD 27 Blend mode determines how a node is composited onto the content below it. One of: SceneNode.BLEND_MODE_PASSTHROUGH, BLEND_MODE_NORMAL, BLEND_MODE_MULTIPLY, BLEND_MODE_DARKEN, BLEND_MODE_COLOR_BURN, BLEND_MODE_LIGHTEN, BLEND_MODE_SCREEN, BLEND_MODE_COLOR_DODGE, BLEND_MODE_OVERLAY, BLEND_MODE_SOFT_LIGHT, BLEND_MODE_HARD_LIGHT, BLEND_MODE_DIFFERENCE, BLEND_MODE_EXCLUSION, BLEND_MODE_HUE, BLEND_MODE_SATURATION, BLEND_MODE_COLOR, BLEND_MODE_LUMINOSITY. Note: for leaf nodes (GraphicNode), the XD UI may show leaf nodes as blend mode \"Normal\" even when the underlying value is BLEND_MODE_PASSTHROUGH. This is because \"Pass Through\" and \"Normal\" are essentially equivalent for leaf nodes – they only differ in appearance when a node has children. Example node.blendMode = scenegraph.SceneNode.BLEND_MODE_LUMINOSITY; Kind: instance property of SceneNode sceneNode.transform : !Matrix Affine transform matrix that converts from the node's local coordinate space to its parent's coordinate space. The matrix never has skew or scale components, and if this node is an Artboard the matrix never has rotation either. Rather than reading the raw matrix values directly, it may be easier to use the translation and rotation properties. To move or resize a node, use the translation property or APIs like placeInParentCoordinates() or rotateAround(). Setting the entire transform matrix directly is not allowed. To resize a node, use resize(). For an overview of node transforms & coordinate systems, see Coordinate spaces. This getter returns a fresh Matrix each time, so its fields can be mutated by the caller without interfering with the node's state. Kind: instance property of SceneNode Read only: true See translation rotation moveInParentCoordinates placeInParentCoordinates rotateAround globalBounds localBounds boundsInParent topLeftInParent sceneNode.translation : !{x:number, y:number} The translate component of this node's transform. Since translation is applied after any rotation in the transform Matrix, translation occurs along the parent's X/Y axes, not the node's own local X/Y axes. This is equivalent to the e & f fields in the transform Matrix. For an overview of node positioning & coordinate systems, see Coordinate spaces. Kind: instance property of SceneNode See moveInParentCoordinates placeInParentCoordinates topLeftInParent sceneNode.rotation : number The rotation component of this node's transform, in clockwise degrees. For an overview of node transforms & coordinate systems, see Coordinate spaces. Kind: instance property of SceneNode Read only: true See: rotateAround sceneNode.globalBounds : !Bounds The node's path bounds in document-global coordinate space (represented by a bounding box aligned with global X/Y axes). Path bounds match the selection outline seen in the XD, but exclude some visual parts of the node (outer stroke, drop shadow / blur, etc.). For an overview of node bounding boxes & coordinate systems, see Coordinate spaces. Kind: instance property of SceneNode Read only: true See globalDrawBounds localBounds boundsInParent sceneNode.localBounds : !Bounds The node's path bounds in its own local coordinate space. This coordinate space may be rotated and translated relative to the parent's coordinate space. Path bounds match the selection outline seen in XD, but exclude some visual parts of the node (outerstroke, drop shadow / blur, etc.). The visual top-left of a node's path bounds is located at (localBounds.x, localBounds.y). This value is not necessarily (0,0) in the local coordinate space: for example, a text node's baseline is at y=0 in local coordinates, so the top of the text has a negative y value. For an overview of node bounding boxes & coordinate systems, see Coordinate spaces. Kind: instance property of SceneNode Read only: true See globalBounds boundsInParent sceneNode.boundsInParent : !Bounds The node's path bounds in its parent's coordinate space (represented by a bounding box aligned with the parent's X/Y axes - so if the node has rotation, the top-left of the node is not necessarily located at the top-left of boundsInParent). Path bounds match the selection outline seen in XD, but exclude some visual parts of the node (outer stroke, drop shadow / blur, etc.). For an overview of node bounding boxes & coordinate systems, see Coordinate spaces. Kind: instance property of SceneNode Read only: true See globalBounds localBounds topLeftInParent sceneNode.topLeftInParent : !Point The position of the node's upper-left corner (localBounds.x, localBounds.y) in its parent's coordinate space. If the node is rotated, this is not the same as the top-left corner of boundsInParent. This is a shortcut for node.transform.transformPoint({x: node.localBounds.x, y: node.localBounds.y}) For an overview of node bounding boxes & coordinate systems, see Coordinate spaces. Kind: instance property of SceneNode Read only: true See boundsInParent localBounds sceneNode.localCenterPoint : !Point The position of the node's centerpoint in its own local coordinate space. Useful as an argument to rotateAround. This is a shortcut for {x: localBounds.x + localBounds.width/2, y: localBounds.y + localBounds.height/2}) For an overview of node bounding boxes & coordinate systems, see Coordinate spaces. Kind: instance property of SceneNode Read only: true See: localBounds sceneNode.globalDrawBounds : !Bounds The node's draw bounds in document-global coordinate space. Draw bounds are larger than the selection outline seen in XD, including outer stroke, drop shadow / blur, etc. - every visible pixel of the node is encompassed by these bounds. This matches the image dimensions if the node is exported as a PNG/JPEG bitmap. For an overview of node bounding boxes & coordinate systems, see Coordinate spaces. Kind: instance property of SceneNode Read only: true See globalBounds sceneNode.name : string Node name as seen in the Layers panel. Also used as filename during Export. Kind: instance property of SceneNode sceneNode.hasDefaultName : boolean True if name is a generic, auto-generated string (e.g. \"Rectangle 5\"). False if name has been explicitly set. Kind: instance property of SceneNode Read only: true sceneNode.locked : boolean True if the node is locked, meaning it cannot normally be selected. Kind: instance property of SceneNode sceneNode.markedForExport : boolean True if the node should be included in the output of File > Export > Batch and other bulk-export workflows. Kind: instance property of SceneNode sceneNode.fixedWhenScrolling : ?boolean Since: XD 19 True if the node stays in a fixed position while the Artboard's content is scrolling (when viewed in an interactive prototype). Only applicable for nodes whose immediate parent is an Artboard. For other nodes, this property returns undefined and cannot be set. To determine whether those nodes scroll or remain fixed, walk up the parent chain and check this property on the topmost ancestor in the Artboard. Kind: instance property of SceneNode See: Artboard.viewportHeight sceneNode.triggeredInteractions : !ArrrayInteraction> Since: XD 19 Get all interactions that are triggered by this node in the document's interactive prototype. Each element in the array is an Interaction object which describes a gesture/event plus the action it produces. Note: If this node (or one of its ancestors) has visible = false, tap and drag interactions on it will not be triggered. Currently, this API excludes some types of interactions: keypress/gamepad, scrolling, hover, component state transitions, or non-speech audio playback. Example // Print all the interactions triggered by a node node.triggeredInteractions.forEach(interaction => { console.log(\"Trigger: \" + interaction.trigger.type + \" -> Action: \" + interaction.action.type); }); Kind: instance property of SceneNode Read only: true See: interactions.allInteractions sceneNode.hasLinkedContent : boolean True if the node's appearance comes from a link to an external resource, such as Creative Cloud Libraries or a separate XD document (in the case of a Linked Component instance). Kind: instance property of SceneNode Read only: true sceneNode.pluginData : * Since: XD 14 Metadata specific to your plugin. Must be a value which can be converted to a JSON string, or undefined to clear the stored metadata on this node. Metadata is persisted with the document when it is saved. Duplicating a node (including across documents, via copy-paste) will duplicate the metadata with it. If the node lies within a Component or Repeat Grid, all instances of the node will have identical metadata (changes in one copy will automatically be synced to the other copy). Metadata stored by this plugin cannot be accessed by other plugins - each plugin has its own isolated metadata storage. To store general metadata for the document overall, set pluginData on the root node of the scenegraph. Metadata on the root node can be changed from any edit context. Kind: instance property of SceneNode sceneNode.removeFromParent() Remove this node from its parent, effectively deleting it from the document. Kind: instance method of SceneNode sceneNode.moveInParentCoordinates(deltaX, deltaY) Move the node by the given number of pixels along the parent's X/Y axes (if this node has no rotation, this is identical to moving the node along its own local X/Y axes). This is equivalent to modifying the value returned by 'translation' and then setting it back. For an overview of node positioning & coordinate systems, see Coordinate spaces. Kind: instance method of SceneNode See placeInParentCoordinates translation Param Type deltaX number deltaY number sceneNode.placeInParentCoordinates(registrationPoint, parentPoint) Move the node so the given point in its local coordinates is placed at the given point in its parent's coordinates (taking into account any rotation on this node, etc.). For an overview of node positioning & coordinate systems, see Coordinate spaces. Kind: instance method of SceneNode Param Type Description registrationPoint !Point Point in this node's local coordinate space to align with parentPoint parentPoint !Point Point in this node's parent's coordinate space to move registrationPoint to Example // Place this node's top-left corner at the centerpoint of its parent let parentCenter = node.parent.localCenterPoint; // parent's center in parent's coordinates let nodeBounds = node.localBounds; // node's bounds in its own local coordinates let nodeTopLeft = {x: nodeBounds.x, y: nodeBounds.y}; // node's top left corner in its own local coordinates node.placeInParentCoordinates(nodeTopLeft, parentCenter); sceneNode.rotateAround(deltaAngle, rotationCenter) Rotate the node clockwise by the given number of degrees around the given point in the plugin's local coordinate space. If this node already has nonzero rotation, this operation adds to its existing angle. For an overview of node transforms & coordinate systems, see Coordinate spaces. Kind: instance method of SceneNode See: rotation Param Type Description deltaAngle number In degrees. rotationCenter Point Point to rotate around, in node's local coordinates. Example // Rotate the node 45 degrees clockwise around its centerpoint node.rotateAround(45, node.localCenterPoint); // Ignoring the node's previous angle, set its rotation to exactly 180 degrees let rotationDelta = 180 - node.rotation; node.rotateAround(rotationDelta, node.localCenterPoint); sceneNode.resize(width, height) Attempts to change localBounds.width & height to match the specified sizes. The result is not guaranteed to match your requested size, since some nodes have limits on their ability to resize. Note that resizing is different from simply rescaling the content: Styles like stroke weight and corner radius stay the same size, so the ratio of their size relative to the resized shape will change. If this node is a Group, resizing may invoke XD's Responsive Resize feature, which rearranges items using a fluid layout and may change only the position (not size) of some children. Some content cannot be resized at all, or cannot stretch to change its aspect ratio. Rescaling, by contrast, is the effect seen when you zoom in on the view in XD, or when you export a node at a higher DPI multiplier. Note: Currenty this function does not respect the \"aspect ratio lock\" setting in XD's Properties panel. This may be changed/fixed later. Kind: instance method of SceneNode Param Type width number height number Example // Double the width of this node let originalBounds = node.localBounds; node.resize(originalBounds.width * 2, originalBounds.height); RootNode Kind: class Extends: SceneNode Class representing the root node of the document. All Artboards are children of this node, as well as any pasteboard content that does not lie within an Artboard. Artboards must be grouped contiguously at the bottom of this node's z order. The root node has no visual appearance of its own. RootNode .addChild(node, index) .addChildAfter(node, relativeTo) .addChildBefore(node, relativeTo) .removeAllChildren() Group Kind: class Extends: SceneNode Group nodes represent two types of simple containers in XD: Plain Groups, created by the Object > Group command Masked Groups, created by the Object > Mask With Shape command You can determine whether a group is masked by checking the mask property. Groups and other containers cannot be created directly using scenenode constructors, since you can't add a populated Group to the scenegraph (you can't add subtrees all at once) nor can you add an empty Group and then add children to it (can't add nodes outside the scope of the current edit context). Instead, to create Groups and other nested structures, use commands. In a Mask Group, the mask shape is included in the group's children list, at the top of the z order. It is not visible - only its path outline is used, for clipping the group. Example let commands = require(\"commands\"); // Newly created shape nodes let shape1 = ..., shape2 = ...; // Add both nodes to the current edit context first selection.insertionParent.addChild(shape1); selection.insertionParent.addChild(shape2); // Select both shapes, then run the Group command selection.items = [shape1, shape2]; commands.group(); let group = selection.items[0]; // selection has been set to the new Group node afterward Group .addChild(node, index) .addChildAfter(node, relativeTo) .addChildBefore(node, relativeTo) .removeAllChildren() .mask : ?SceneNode group.addChild(node, index) Adds a child node to this container node. You can only add leaf nodes this way; to create structured subtrees of content, use commands. Kind: instance method of Group and other container nodes Param Type Description node !SceneNode Child to add index ?number Optional: index to insert child at. Child is appended to end of children list (top of z order) otherwise. group.addChildAfter(node, relativeTo) Inserts a child node after the given reference node. Kind: instance method of Group and other container nodes Param Type Description node !SceneNode Child to add relativeTo !SceneNode New child is added immediately after this existing child group.addChildBefore(node, relativeTo) Inserts a child node before the given reference node. Kind: instance method of Group and other container nodes Param Type Description node !SceneNode Child to add relativeTo !SceneNode New child is added immediately before this existing child group.removeAllChildren() Removes all children from this node. Equivalent to calling removeFromParent() on each child in turn, but faster. Kind: instance method of Group and other container nodes group.mask : ?SceneNode The mask shape applied to this group, if any. This object is also present in the group's children list. Though it has no direct visual appearance of its own, the mask affects the entire group's appearance by clipping all its other content. Kind: instance property of Group Read only: true Example let group = ...; console.log(\"Type of group is: \" + (group.mask ? \"Masked Group\" : \"Plain Group\")); To create a Masked Group, use commands.createMaskGroup instead of commands.group. GraphicNode Kind: abstract class Extends: SceneNode Base class for nodes that have a stroke and/or fill. This includes leaf nodes such as Rectangle, as well as BooleanGroup which is a container node. If you create a shape node, it will not be visible unless you explicitly give it either a stroke or a fill. GraphicNode .fill : ?Color or LinearGradientFill or RadialGradientFill or ImageFill .fillEnabled : boolean .stroke : ?Color .strokeEnabled : boolean .strokeWidth : number .strokePosition : string .strokeEndCaps : string .strokeJoins : string .strokeMiterLimit : number .strokeDashArray : !Array .strokeDashOffset : number .shadow : ?Shadow .blur : ?Blur .pathData : string .hasLinkedGraphicFill : boolean graphicNode.fill : ?Color or LinearGradientFill or RadialGradientFill or ImageFill Default: null The fill applied to this shape, if any. If this property is null or fillEnabled is false, no fill is drawn. Freshly created nodes have no fill by default. For Line nodes, fill is ignored. For Text nodes, only solid Color fill values are allowed. For Artboard nodes, image fill values are not allowed. Kind: instance property of GraphicNode Example ellipse.fill = new Color(\"red\"); To modify an existing fill, always be sure to re-invoke the fill setter rather than just changing the fill object's properties inline. See \"Properties with object values\". The RadialGradientFill type is not documented and its API may change. Plugins currently cannot modify or otherwise work with radial gradients. graphicNode.fillEnabled : boolean Default: true If false, the fill is not rendered. The user can toggle this via a checkbox in the Properties panel. Kind: instance property of GraphicNode graphicNode.stroke : ?Color Default: null The stroke color applied to this shape, if any. If this property is null or strokeEnabled is false, no stroke is drawn. Freshly created nodes have no stroke by default. Artboard objects ignore stroke settings. Depending on the strokeWidth and strokePosition, the path outline of a node may need to be positioned on fractional pixels in order for the stroke itself to be crisply aligned to the pixel grid. For example, if a horizontal line uses a 1px center stroke, the line's y should end in .5 to keep the stroke on-pixel. Kind: instance property of GraphicNode Example ellipse.stroke = new Color(\"red\"); To modify an existing stroke, always be sure to re-invoke the stroke setter rather than just changing the Color object's properties inline. See \"Properties with object values\". graphicNode.strokeEnabled : boolean Default: false If false, the stroke is not rendered. The user can toggle this via a checkbox in the Properties panel. Kind: instance property of GraphicNode graphicNode.strokeWidth : number >= 0 Default: 1.0 Thickness in pixels of the stroke. Kind: instance property of GraphicNode graphicNode.strokePosition : string Default: CENTER_STROKE for most shapes, INNER_STROKE for Rectangle, Ellipse & Polygon Position of the stroke relative to the shape's path outline: GraphicNode.INNER_STROKE, OUTER_STROKE, or CENTER_STROKE. Ignored by Text and Line, which always render using CENTER_STROKE. Kind: instance property of GraphicNode graphicNode.strokeEndCaps : string Default: STROKE_CAP_SQUARE For Lines and non-closed Paths, how the dangling ends of the stroke are rendered: GraphicNode.STROKE_CAP_NONE, STROKE_CAP_SQUARE, or STROKE_CAP_ROUND. Kind: instance property of GraphicNode graphicNode.strokeJoins : string Default: STROKE_JOIN_MITER How sharp corners in the shape are rendered: GraphicNode.STROKE_JOIN_BEVEL, STROKE_JOIN_ROUND, or STROKE_JOIN_MITER. Kind: instance property of GraphicNode graphicNode.strokeMiterLimit : number >= 0 Default: 4 Expressed as a multiple of stroke width. Only used when strokeJoins = STROKE_JOIN_MITER. Kind: instance property of GraphicNode graphicNode.strokeDashArray : !Array Default: [] Empty array indicates a solid stroke. If non-empty, values represent the lengths of rendered and blank segments of the stroke's dash pattern, repeated along the length of the stroke. The first value is the length of the first solid segment. If the array is odd length, the items are copied to double the array length. For example, [3] produces the same effect as [3, 3]. The appearance of each segment's start/end follows the strokeEndCaps setting. Kind: instance property of GraphicNode graphicNode.strokeDashOffset : number Default: 0 Ignored unless strokeDashArray is non-empty. Shifts the \"phase\" of the repeating dash pattern along the length of the stroke. Kind: instance property of GraphicNode graphicNode.shadow : ?Shadow Default: null The node's drop shadow, if any. If there is no shadow applied, this property may be null or shadow.visible may be false. To modify an existing shadow, always be sure to re-invoke the shadow setter rather than just changing the Shadow object's properties inline. See \"Properties with object values\". Kind: instance property of GraphicNode graphicNode.blur : ?Blur Default: null The node's object blur or background blur settings, if applicable (a node may not have both types of blur at once). If there is no blur effect applied, this property may be null or blur.visible may be false. To modify an existing blur, always be sure to re-invoke the blur setter rather than just changing the Blur object's properties inline. See \"Properties with object values\". Kind: instance property of GraphicNode graphicNode.pathData : string Returns a representation of the node's outline in SVG syntax. Note that only nodes with strokePosition == GraphicNode.CENTER_STROKE can be faithfully rendered in actual SVG using the exact pathData shown here. Kind: instance property of GraphicNode Read only: true graphicNode.hasLinkedGraphicFill : boolean True if the node has an image fill that comes from a link to an external resource, such as Creative Cloud Libraries. Equivalent to the expression: node.fill && node.fill.linked. Kind: instance property of GraphicNode Read only: true Rectangle Kind: class Extends: GraphicNode Rectangle leaf node shape, with or without rounded corners. Like all shape nodes, has no fill or stroke by default unless you set one. Example let rect = new Rectangle(); rect.width = 100; rect.height = 25; rect.fill = new Color(\"red\"); selection.insertionParent.addChild(rect); selection.items = [rect]; Rectangle .width : number .height : number .cornerRadii : !{topLeft:number, topRight:number, bottomRight:number, bottomLeft:number} .hasRoundedCorners : boolean .setAllCornerRadii(radius) .effectiveCornerRadii : !{topLeft:number, topRight:number, bottomRight:number, bottomLeft:number} rectangle.width : number > 0 Kind: instance property of Rectangle rectangle.height : number > 0 Kind: instance property of Rectangle rectangle.cornerRadii : !{topLeft:number, topRight:number, bottomRight:number, bottomLeft:number} (all numbers >= 0) Default: {topLeft:0, topRight:0, bottomRight:0, bottomLeft:0} The actual corner radius that is rendered is capped based on the size of the rectangle even if the radius value set here is higher (see effectiveCornerRadii. To set all corners to the same value, use setAllCornerRadii. Kind: instance property of Rectangle rectangle.hasRoundedCorners : boolean True if any of the Rectangle's four corners is rounded (corner radius > 0). Kind: instance property of Rectangle Read only: true rectangle.setAllCornerRadii(radius) Set the rounding radius of all four corners of the Rectangle to the same value. The actual corner radius that is rendered is capped based on the size of the rectangle even if the radius value set here is higher (see effectiveCornerRadii. To set the corners to different radius values, use cornerRadii. Kind: instance method of Rectangle Param Type radius number rectangle.effectiveCornerRadii : !{topLeft:number, topRight:number, bottomRight:number, bottomLeft:number} The actual corner radius that is rendered may be capped by the size of the rectangle. Returns the actual radii that are currently in effect, which may be smaller than the cornerRadii values as a result. Kind: instance property of Rectangle Artboard Kind: class Extends: GraphicNode Artboard container node. All Artboards must be children of the root node (they cannot be nested), and they must be placed below all pasteboard content in the z order. Artboards can have a background fill, but the stroke, shadow, and blur settings are all ignored. Artboards cannot be locked or hidden, or have opacity Generally, all nodes that overlap an Artboard are children of that artboard, and nodes that don't overlap any Artboard are children of the root (pasteboard). XD ensures this automatically: if a node is modified in any way that changes whether it overlaps an Artboard, its parent will automatically be changed accordingly after the edit operation finishes. Artboard .width : number .height : number .viewportHeight : ?number .incomingInteractions : !Array }> .isHomeArtboard : boolean .addChild(node, index) .addChildAfter(node, relativeTo) .addChildBefore(node, relativeTo) .removeAllChildren() artboard.width : number > 0 Kind: instance property of Artboard artboard.height : number > 0 For scrollable Artboards, this is the total height encompassing all content - not just the viewport size (i.e. screen height). Kind: instance property of Artboard See: viewportHeight artboard.viewportHeight : ?number If Artboard is scrollable, this is the height of the viewport (e.g. mobile device screen size). Null if Artboard isn't scrollable. Kind: instance property of Artboard See: height artboard.incomingInteractions : !Array }> Since: XD 19 Get all interactions whose destination is this artboard (either navigating the entire view, i.e. a \"goToArtboard\" action, or showing this artboard as an overlay, i.e. an \"overlay\" action). Each element in the array is an Interaction object which describes a gesture/event plus the action it produces. May include interactions that are impossible to trigger because the trigger node (or one of its ancestors) has visible = false. Note: currently, this API excludes any applicable keyboard/gamepad interactions. Kind: instance property of Artboard Read only: true See: SceneNode.triggeredInteractions See: interactions.allInteractions artboard.isHomeArtboard : boolean Since: XD 19 True if this is the starting Artboard seen when the interactive prototype is launched. Kind: instance property of Artboard Read only: true See: interactions.homeArtboard Ellipse Kind: class Extends: GraphicNode Ellipse leaf node shape. Ellipse .radiusX : number .radiusY : number .isCircle : boolean ellipse.radiusX : number Kind: instance property of Ellipse ellipse.radiusY : number Kind: instance property of Ellipse ellipse.isCircle : boolean True if the Ellipse is a circle (i.e., has a 1:1 aspect ratio). Kind: instance property of Ellipse Read only: true Polygon Since: XD 19 Kind: class Extends: GraphicNode Leaf node shape that is either a convex polygon or a star shape. May have rounded corners. The sides are not necessarily all equal in length: this is true only when the Polygon's width and height matches the aspect ratio of a regular (equilateral) polygon with the given number of sides. When unrotated, a non-star Polygon always has its bottommost side as a perfectly horizontal line - with the exception of the 4-sided Polygon, which is a diamond shape instead. Like all shape nodes, has no size, fill, or stroke by default unless you set one. Example // Add a red triangle to the document var polygon = new Polygon(); polygon.cornerCount = 3; polygon.width = 50; polygon.height = 100; polygon.fill = new Color(\"red\"); selection.insertionParent.addChild(polygon); // Add a blue 5-pointed star with rounded corners var polygon = new Polygon(); polygon.cornerCount = 5; polygon.starRatio = 55; polygon.setAllCornerRadii(4); polygon.width = 100; polygon.height = 95; polygon.fill = new Color(\"blue\"); selection.insertionParent.addChild(polygon); Polygon .width : number .height : number .cornerCount : number .cornerRadii : !Array .hasRoundedCorners : boolean .setAllCornerRadii(radius) .starRatio : number polygon.width : number > 0 Kind: instance property of Polygon polygon.height : number > 0 Kind: instance property of Polygon polygon.cornerCount : number (integer >= 3) Default: 3 For a non-star shape, defines the number of corners (vertices), and also therefore number of sides. For a star shape, defines the number of star points – there will be twice as many corners in total (the tips of the points plus all the inside corners between the points). Setting cornerCount on an existing Polygon behaves in one of two different ways: If the shape's aspect ratio gives it equilateral sides, the sides remain equilateral while the size and aspect ratio of the shape are automatically changed as needed. Otherwise, the size and aspect ratio of the shape remain unchanged. This matches how changing the corner count in XD's UI behaves. To change corner count while guaranteeing the shape will not change size, save its original size first, set cornerCount, and then set size back to the saved values. Kind: instance property of Polygon polygon.cornerRadii : !Array List of corner radius for each corner of the polygon. To set corner radius, use setAllCornerRadii(). Kind: instance property of Polygon Read only: true polygon.hasRoundedCorners : boolean True if any of the Polygon's corners is rounded (corner radius > 0). Kind: instance property of Polygon Read only: true polygon.setAllCornerRadii(radius) Set the corner radius of all corners of the Polygon to the same value. Kind: instance method of Polygon Param Type radius number polygon.starRatio : number (1.0 to 100.0) Default: 100 Since: XD 26 Determines how prominent the shape's star points are. The default value of 100 is a normal convex polygon (not a star at all). For a star shape, consider that the outer vertices at the tips of the points all lie on a circle and the inner vertices between the points all lie on a second, smaller circle. The starRatio is the ratio of the smaller circle's diameter to the outer circle's diameter, expressed as a percentage. Kind: instance property of Polygon Line Kind: class Extends: GraphicNode Line leaf node shape. Lines have a stroke but no fill. Line .start : !Point .end : !Point .setStartEnd(startX, startY, endX, endY) line.start : !Point Start point of the Line in local coordinate space. To change the start point, use setStartEnd. Kind: instance property of Line Read only: true line.end : !Point Endpoint of the Line in local coordinate space. To change the endpoint, use setStartEnd. Kind: instance property of Line Read only: true line.setStartEnd(startX, startY, endX, endY) Set the start and end points of the Line in local coordinate space. The values may be normalized by this setter, shifting the node's translation and counter-shifting the start/end points. So the start/end getters may return values different from the values you passed this setter, even though the line's visual bounds and appearance are the same. Kind: instance method of Line Param Type startX number startY number endX number endY number Path Kind: class Extends: GraphicNode Arbitrary vector Path leaf node shape. Paths can be open or closed, and a Path may include multiple disjoint sections (aka a \"compound path\"). Even open Paths may have a fill - the fill is drawn as if the Path were closed with a final \"Z\" segment. The path may not start at (0,0) in local coordinates, for example if it starts with a move (\"M\") segment. Path .pathData : string path.pathData : string Representation of the path outline in SVG syntax. Unlike other node types, pathData is writable here. Syntax is automatically normalized, so the getter may return a slightly different string than what you passed to the setter. Kind: instance property of Path BooleanGroup Kind: class Extends: GraphicNode BooleanGroup container node - although it has fill/stroke/etc. properties like a leaf shape node, it is a container with children. Its visual appearance is determined by generating a path via a nondestructive boolean operation on all its children's paths. It is not currently possible for plugins to create a new BooleanGroup node, aside from using commands.duplicate to clone existing BooleanGroups. BooleanGroup .pathOp : string .addChild(node, index) .addChildAfter(node, relativeTo) .addChildBefore(node, relativeTo) .removeAllChildren() booleanGroup.pathOp : string Which boolean operation is used to generate the path: BooleanGroup.PATH_OP_ADD, PATH_OP_SUBTRACT, PATH_OP_INTERSECT, or PATH_OP_EXCLUDE_OVERLAP. Kind: instance property of BooleanGroup Read only: true Text Kind: class Extends: GraphicNode Text leaf node shape. Text can have a fill and/or stroke, but only a solid-color fill is allowed (gradient or image fill will be rejected). There are two types of Text nodes: Point Text - Expands to fit the full width of the text content. Only uses multiple lines if the text content contains hard line breaks (\"\\n\"). Area Text - Fixed width and height. Text is automatically wrapped (soft line wrapping) to fit the width. If it does not fit the height, any remaining text is clipped. Check whether areaBox is null to determine the type of a Text node. Text bounds and layout work differently depending on the type of text: Point Text - The baseline is at y=0 in the node's local coordinate system. Horizontally, local x=0 is the anchor point that the text grows from / shrinks toward when edited. This anchor depends on the justification: for example, if the text is centered, x=0 is the horizontal centerpoint of the text. The bounding box leaves enough space for descenders, uppercase letters, and accent marks, even if the current string does not contain any of those characters. This makes aligning text based on its bounds behave more consistently. Area Text - The baseline is at a positive y value in local coordinates, and its local (0, 0) is the top left of the areaBox. Text always flows to the right and down from this local origin regardless of justification.   Text .text : string .styleRanges : !Array .fontFamily : string .fontStyle : string .fontSize : number .fill : Color .charSpacing : number .underline : boolean .strikethrough : boolean .textTransform : string .textScript : string .flipY : boolean .textAlign : string .lineSpacing : number .paragraphSpacing : number .areaBox : ?{width:number, height:number} .clippedByArea : boolean text.text : string Default: \" \" (a single space character) The plaintext content of the node, including any hard line breaks but excluding soft line wrap breaks. Setting text does not change styleRanges, so styles aligned with the old text's string indices will continue to be applied to the new string's indices unless you explicitly change styleRanges as well. Kind: instance property of Text text.styleRanges : !ArrayColor, charSpacing:number, underline:boolean, strikethrough:boolean, textTransform:string, textScript:string}> Array of text ranges and their character style settings. Each range covers a set number of characters in the text content. Ranges are contiguous, with each one starting immediately after the previous one. Any characters past the end of the last range use the same style as the last range. When setting styleRanges, any fields missing from a given range default to the existing values from the last range in the old value of styleRanges. The styleRanges getter always returns fully realized range objects with all fields specified. Kind: instance property of Text text.fontFamily : string Since: XD 14 Set the font family across all style ranges, or get the font family of the last style range (font family of all the text if one range covers all the text). Plugins should not assume any particular default value for fontFamily. Kind: instance property of Text text.fontStyle : string Default: non-italic normal weight style Since: XD 14 Set the font style across all style ranges, or get the font style of the last style range (font style of all the text if one range covers all the text). Kind: instance property of Text text.fontSize : number > 0 Since: XD 14 Font size in document pixels. Set the font size across all style ranges, or get the font size of the last style range (font size of all the text if one range covers all the text). Plugins should not assume any particular default value for fontSize. Kind: instance property of Text text.fill : ?Color Default: null Set the text color across all style ranges, or get the color of the last style range (color of all the text if one range covers all the text). Unlike most other nodes, text only allows a solid color fill - gradients and image fills are not supported. Kind: instance property of Text text.charSpacing : number Default: 0 Since: XD 14 Character spacing in increments of 1/1000th of the fontSize, in addition to the font's default character kerning. May be negative. Set the character spacing across all style ranges, or get the character spacing of the last style range (character spacing of all the text if one range covers all the text). Kind: instance property of Text text.underline : boolean Default: false Since: XD 14 Set underline across all style ranges, or get the underline of the last style range (underline of all the text if one range covers all the text). Kind: instance property of Text text.strikethrough : boolean Default: false Since: XD 19 Set strikethrough across all style ranges, or get the strikethrough of the last style range (strikethrough of all the text if one range covers all the text). Kind: instance property of Text text.textTransform : string Default: \"none\" Since: XD 19 Set textTransform (\"none\", \"uppercase\", \"lowercase\", or \"titlecase\") across all style ranges, or get the textTransform of the last style range. Kind: instance property of Text text.textScript : string Default: \"none\" Since: XD 20 Set textScript (\"none\" or \"superscript\" or \"subscript\") across all style ranges, or get the textScript of the last style range. Kind: instance property of Text text.flipY : boolean If true, the text is drawn upside down. Kind: instance property of Text text.textAlign : string Default: ALIGN_LEFT Horizontal alignment: Text.ALIGN_LEFT, ALIGN_CENTER, or ALIGN_RIGHT. This setting affects the layout of multiline text, and for point text it also affects how the text is positioned relative to its anchor point (x=0 in local coordinates) and what direction the text grows when edited by the user. Changing textAlign on existing point text will cause it to shift horizontally. To change textAlign while keeping the text in a fixed position, shift the text horizontally (moving its anchor point) to compensate: Example let originalBounds = textNode.localBounds; textNode.textAlign = newAlignValue; let newBounds = textNode.localBounds; textNode.moveInParentCoordinates(originalBounds.x - newBounds.x, 0); Kind: instance property of Text text.lineSpacing : number > 0, or 0 for default spacing Default: 0 Distance between baselines in multiline text, in document pixels. The special value 0 causes XD to use the default line spacing defined by the font given the current font size & style. This property is not automatically adjusted when fontSize changes, if line spacing is not set to 0, the line spacing will stay fixed while the font size changes, shifting the spacing's proportional relationship to font size. If the value is 0, then the rendered line spacing will change to match the new font size, since 0 means the spacing is dynamically calculated from the current font settings. Kind: instance property of Text text.paragraphSpacing : number >= 0 Default: 0 Since: XD 14 Additional distance between paragraphs, in document pixels, added to the lineSpacing amount (soft line breaks in area text are separated only by lineSpacing, while hard line breaks are separated by lineSpacing + paragraphSpacing). Unlike lineSpacing, 0 is not a special value; it just means no added spacing. Similar to lineSpacing, this property is not automatically adjusted when fontSize changes. The paragraph spacing amount will stay fixed while the font size changes, shifting the spacing's proportional relationship to font size. Kind: instance property of Text text.areaBox : ?{width:number, height:number} Null for point text. For area text, specifies the size of the rectangle within which text is wrapped and clipped. Changing point text to area text or vice versa will change the origin / anchor point of the text, thus changing its localBounds, but it will also automatically change the node's transform so its globalBounds and boundsInParent origins remain unchanged. Changing area text to point text will also automatically insert hard line breaks (\"\\n\") into the text to match the previous line wrapping's appearance exactly. Kind: instance property of Text text.clippedByArea : boolean Always false for point text. For area text, true if the text does not fit in the content box and its bottom is being clipped. Kind: instance property of Text Read only: true SymbolInstance Kind: class Extends: SceneNode Container node representing one instance of a Component (previously known as \"Symbols\" in XD's UI). Changes made to the contents of a SymbolInstance are treated in one of two ways: If isMaster is false: The changes affect only this one instance. This creates an \"override\": changes made to the corresponding part of the master later will no longer get synced to this particular instance. If isMaster is true: The changes are automatically synced to all other other instances of the component - except for instances where the affected nodes have instance-specific overrides. As a result, your plugin's batch of edits may not be applied atomically in some instances. To elaborate: if your plugin command makes edits to more than one property or more than one node as part of a single gesture, and the user invokes your plugin while editing a component master, other instances of the component may receive only a partial application of your plugin's changes. In many cases this will feel like a natural consequence of the overrides the user has created, but if this partial application of your plugin's intended changes feels too confusing in your use case, you may opt to warn users or disable some of your plugin's functionality when selection.editContext is (or is inside of) a component with isMaster true. Note that overrides vary somewhat in granularity. In some but not all cases, overriding one property may also prevent other properties on the same node from receiving future updates from the master instance. It is not currently possible for plugins to create a new component definition or a new SymbolInstance node, aside from using commands.duplicate to clone existing SymbolInstances. SymbolInstance .symbolId : string .isMaster : boolean .addChild(node, index) .addChildAfter(node, relativeTo) .addChildBefore(node, relativeTo) .removeAllChildren() symbolInstance.symbolId : string An identifier unique within this document that is shared by all instances of the same component. Kind: instance property of SymbolInstance Read only: true symbolInstance.isMaster : boolean True if this is the \"master\" instance of the component, which forms the template for all new instances. When the user edits the master, those changes are synced to all other instances of the component (unless blocked by \"overrides\" – see discussion above). Kind: instance property of SymbolInstance Read only: true RepeatGrid Kind: class Extends: SceneNode Repeat Grid container node containing multiple grid cells, each one a child Group. Changes within one cell are automatically synced to all the other cells - with certain exceptions, called \"overrides.\" A Repeat Grid also defines a rectangular clipping mask which determines how may cells are visible (new cells are automatically generated as needed if the Repeat Grid is resized larger). Each grid cell is a Group that is an immediate child of the RepeatGrid. These groups are automatically created and destroyed as needed when the RepeatGrid is resized. It is not currently possible for plugins to create a new RepeatGrid node, aside from using commands.duplicate to clone existing RepeatGrids. RepeatGrid .width : number .height : number .numColumns : number .numRows : number .paddingX : number .paddingY : number .cellSize : !{width: number, height: number} .attachTextDataSeries(textNode, textValues) .attachImageDataSeries(shapeNode, images) .addChild(node, index) .addChildAfter(node, relativeTo) .addChildBefore(node, relativeTo) .removeAllChildren() repeatGrid.width : number Defines size of the RepeatGrid. Cells are created and destroyed as necessary to fill the current size. Cells that only partially fit will be clipped. Kind: instance property of RepeatGrid repeatGrid.height : number Defines size of the RepeatGrid. Cells are created and destroyed as necessary to fill the current size. Cells that only partially fit will be clipped. Kind: instance property of RepeatGrid repeatGrid.numColumns : number Number of grid columns Kind: instance property of RepeatGrid repeatGrid.numRows : number Number of grid rows Kind: instance property of RepeatGrid repeatGrid.paddingX : number Horizontal spacing between grid cells/columns Kind: instance property of RepeatGrid repeatGrid.paddingY : number Vertical spacing between grid cells/rows Kind: instance property of RepeatGrid repeatGrid.cellSize : !{width: number, height: number} The size of each grid cell. The size of each cell's content can vary slightly due to text overrides; the cell size is always set to the width of the widest cell content and the height of the tallest cell content. Kind: instance property of RepeatGrid repeatGrid.attachTextDataSeries(textNode, textValues) Attach a sequence of text values to the instances of a given text node across all the cells of a Repeat Grid. The sequence is repeated as necessary to cover all the grid cells. This is a persistent data binding, so if the Repeat Grid is resized later to increase the number of grid cells, items from this sequence will be used to fill the text values of the new cells. You can call this API from either of two different edit contexts: Edit context where the RepeatGrid node is in scope (where properties of the RepeatGrid node itself could be edited) - e.g. when the RepeatGrid is selected Edit context where textNode is in scope (where properties of the textNode could be edited) - e.g. when textNode is selected or when the user has otherwise drilled down into the grid cell containing it. Kind: instance method of RepeatGrid Param Type Description textNode !Text A Text node exemplar that would be in scope for editing if the current edit context was one of this RepeatGrid's cells. The data series will be bound to this text node and all corresponding copies of it in the other grid cells. textValues !Array Array of one or more strings. Empty strings are ignored. repeatGrid.attachImageDataSeries(shapeNode, images) Attach a sequence of image fills to the instances of a given shape node across all the cells of a Repeat Grid. The sequence is repeated as necessary to cover all the grid cells. This is a persistent data binding, so if the Repeat Grid is resized later to increase the number of grid cells, items from this sequence will be used to set the image fill in the new cells. You can call this API from either of two different edit contexts: Edit context where the RepeatGrid node is in scope (where properties of the RepeatGrid node itself could be edited) - e.g. when the RepeatGrid is selected Edit context where shapeNode is in scope (where properties of the shapeNode could be edited) - e.g. when shapeNode is selected or when the user has otherwise drilled down into the grid cell containing it. Kind: instance method of RepeatGrid Param Type Description shapeNode !GraphicNode A shape node exemplar that would be in scope for editing if the current edit context was one of this RepeatGrid's cells. The image series will be bound to this node and all corresponding copies of it in the other grid cells. Must be a node type that supports image fills (e.g. Rectangle, but not Text or Line). images !Array Array of one or more ImageFills. LinkedGraphic Kind: class Extends: SceneNode Container node whose content is linked to an external resource, such as Creative Cloud Libraries. It cannot be edited except by first ungrouping it, breaking this link. "},"reference/SceneNodeList.html":{"url":"reference/SceneNodeList.html","title":"SceneNodeList","keywords":"","body":" SceneNodeList Represents the children of a scenenode. Typically accessed via the SceneNode.children property. This is not an Array, so you must use at(i) instead of [i] to access children by index. It has a number of Array-like methods such as forEach for convenience, however. For best performance, iterate the list using these methods rather than repeatedly calling at(). Items in this list are ordered from lowest z order to highest. Kind: class Example let node = ...; console.log(\"Node has \" + node.children.length + \" children\"); console.log(\"First child: \" + node.children.at(0)); // do not use `[0]` - it will not work! node.children.forEach(function (childNode, i) { ... }); See: SceneNode.children SceneNodeList .length : number .forEach(callback, thisArg) ⇒ void .forEachRight(callback, thisArg) ⇒ void .filter(callback, thisArg) ⇒ Array. .map(callback, thisArg) ⇒ Array. .some(callback, thisArg) ⇒ boolean .at() ⇒ SceneNode sceneNodeList.length : number Number of children in the list. Kind: instance property of SceneNodeListRead only: true sceneNodeList.forEach(callback, thisArg) ⇒ void Iterate all children in the list. Kind: instance method of SceneNodeList Param Type Description callback !function(!SceneNode, number) Callback, passed each child node and its index. thisArg ?Object Optional value for this when executing the callback. sceneNodeList.forEachRight(callback, thisArg) ⇒ void Iterate all children in the list, in reverse order (highest z order to lowest). Kind: instance method of SceneNodeList Param Type Description callback !function(!SceneNode, number) Callback, passed each child node and its index. thisArg ?Object Optional value for this when executing the callback. sceneNodeList.filter(callback, thisArg) ⇒ Array. Iterates all children and returns an array of just the children that passed the filter function's test. Kind: instance method of SceneNodeList Param Type Description callback !function(!SceneNode, number): boolean Filter function, passed each child node and its index. thisArg ?Object Optional value for this when executing the callback. sceneNodeList.map(callback, thisArg) ⇒ Array. Iterates all children and returns an array of the map function's result value for each child node. Kind: instance method of SceneNodeList Param Type Description callback !function(!SceneNode, number): * Map function, passed each child node and its index. thisArg ?Object Optional value for this when executing the callback. sceneNodeList.some(callback, thisArg) ⇒ boolean Iterates children until the test returns true for at least one child. Kind: instance method of SceneNodeListReturns: boolean - True if the test function returned true for at least one child. Param Type Description callback !function(!SceneNode, number): boolean Test function, passed each child node and its index. thisArg ?Object Optional value for this when executing the callback. sceneNodeList.at() ⇒ SceneNode Note: calling at() repeatedly (e.g. in a for loop) is not as fast as using SceneNodeList's iteration methods such as forEach(), some(), or map(). Kind: instance method of SceneNodeListReturns: ?SceneNode - Child node at the specified index in the list, or null if index is out of bounds. Param Type index number "},"reference/Color.html":{"url":"reference/Color.html","title":"Color","keywords":"","body":" Color Kind: class Color new Color(value, opacity) .a : number .r : number .g : number .b : number .toRgba() ⇒ !{r:number, g:number, b:number, a:number} .toHex(forceSixDigits) ⇒ string .clone() ⇒ !Color new Color(value, opacity) Create a new color instance. Param Type Description value ! string | number | {r:number, g:number, b:number, a:?number}` One of:String in CSS color format (hex, rgb, rgba, hsl, hsla, hsv, hsva, or color name)ARGB numeric value (unsigned 32-bit integer)Object with `r`, `g`, `b`, `a` keys all set to integers from 0 - 255 (if `a` is omitted, 255 is used) opacity ?number Optional, floating-point value from 0 - 1. Use when value parameter doesn't specify an opacity and you don't want the default 1.0 (100%) opacity. color.a : number Integer 0-255. Get/set the alpha channel value. Kind: instance property of Color color.r : number Integer 0-255. Get/set the red channel value. Kind: instance property of Color color.g : number Integer 0-255. Get/set the green channel value. Kind: instance property of Color color.b : number Integer 0-255. Get/set the blue channel value. Kind: instance property of Color color.toRgba() Convert to an object with r, g, b, a keys where r, g, b, a range from 0 - 255. Kind: instance method of ColorReturns: !{r:number, g:number, b:number, a:number} color.toHex(forceSixDigits) ⇒ string Convert to hex string with \"#\" prefix. Ignores the Color's alpha value. Returns a 3-digit string if possible, otherwise returns a 6-digit string. Kind: instance method of ColorReturns: string - Hex color string in the form #123 or #456ABC. Param Type Description forceSixDigits boolean True if you want the result to always have 6 digits. color.clone() ⇒ !Color Returns a clone of the current color object Kind: instance method of Color "},"reference/ImageFill.html":{"url":"reference/ImageFill.html","title":"ImageFill","keywords":"","body":" ImageFill Kind: class ImageFill represents a bitmap (raster) image that can be used as the fill property of any shape node (but not Artboards). The supported image encodings are: PNG, JPEG, and GIF. Example // User picks an image file const storage = require(\"uxp\").storage; const fs = storage.localFileSystem; let imageFile = await fs.getFileForOpening({ types: storage.fileTypes.images }); // Create ImageFill for this image const ImageFill = require(\"scenegraph\").ImageFill; let fill = new ImageFill(imageFile); // Set fill of first selected item selection.items[0].fill = fill; ImageFill new ImageFill(fileOrDataURI) .clone() ⇒ !ImageFill .scaleBehavior : string .naturalWidth : number .naturalHeight : number .mimeType : string .isLinkedContent : boolean ImageFill() Param Type Description fileOrDataURI !uxp.storage.File or string File object pointing to an image file; or a string containing a data: URI with a base-64 encoded image. imageFill.clone() ⇒ !ImageFill Returns a new copy of this ImageFill. Kind: instance method of ImageFill Returns: !ImageFill imageFill.scaleBehavior : string Default: SCALE_COVER How the image is scaled when the aspect ratio of the shape does not match the aspect ratio of the image: ImageFill.SCALE_COVER - The image's aspect ratio is preserved and it is scaled to completely cover the area of the shape. This means on one axis the image's edges line up exactly with the edges of the shape, and on the other axis the image extends beyond the shape's bounds and is cropped. (Similar to object-fit: cover in CSS). ImageFill.SCALE_STRETCH - The image is stretched (distorting its aspect ratio) so its edges line up exactly with the edges of the shape. (Similar to object-fit: fill in CSS). Image size and scaling are also affected by cropping settings, but these are not yet exposed to plugins. Kind: instance property of ImageFill imageFill.naturalWidth : number Pixel dimensions of the underlying bitmap image data. Kind: instance property of ImageFill Read only: true imageFill.naturalHeight : number Pixel dimensions of the underlying bitmap image data. Kind: instance property of ImageFill Read only: true imageFill.mimeType : string Format the image data was originally encoded in, such as image/gif or image/jpeg. Kind: instance property of ImageFill Read only: true imageFill.isLinkedContent : boolean True if the image comes from a link to an external resource, such as Creative Cloud Libraries. Kind: instance property of ImageFill Read only: true "},"reference/LinearGradientFill.html":{"url":"reference/LinearGradientFill.html","title":"LinearGradientFill","keywords":"","body":" LinearGradientFill Kind: class In a linear gradient, colors blend smoothly along a straight line, extending out perpendicularly from that line. The gradient fills the entire area of the shape it is applied to. LinearGradientFill new LinearGradientFill() .clone() ⇒ !LinearGradientFill .colorStops : !Array .startX : number .startY : number .endX : number .endY : number .getEndPoints() ⇒ !Array .setEndPoints(startX, startY, endX, endY) new LinearGradientFill() Create a new LinearGradientFill instance. linearGradientFill.clone() ⇒ !LinearGradientFill Returns a copy of this instance. Kind: instance method of LinearGradientFill linearGradientFill.colorStops : !ArrayColor}> Array of objects representing each color and its position along the gradient line. The position (stop value) is a number 0.0 - 1.0. Kind: instance property of LinearGradientFill linearGradientFill.startX : number X position of the start of the gradient line, as a multiple of the object's bounding box: X=0 indicates the left edge of the bounding box and X=1 indicates the right edge. The gradient line may start or end outside the object's bounding box, so values may be 1. Kind: instance property of LinearGradientFill linearGradientFill.startY : number Y position of the start of the gradient line, as a multiple of the object's bounding box: Y=0 indicates the top edge of the bounding box and Y=1 indicates the bottom edge. The gradient line may start or end outside the object's bounding box, so values may be 1. Kind: instance property of LinearGradientFill linearGradientFill.endX : number X position of the end of the gradient line, as a multiple of the object's bounding box: X=0 indicates the left edge of the bounding box and X=1 indicates the right edge. The gradient line may start or end outside the object's bounding box, so values may be 1. Kind: instance property of LinearGradientFill linearGradientFill.endY : number Y position of the end of the gradient line, as a multiple of the object's bounding box: Y=0 indicates the top edge of the bounding box and Y=1 indicates the bottom edge. The gradient line may start or end outside the object's bounding box, so values may be 1. Kind: instance property of LinearGradientFill linearGradientFill.getEndPoints() ⇒ !Array Returns an array of [startX, startY, endX, endY]. Kind: instance method of LinearGradientFill *linearGradientFill.setEndPoints(startX, startY, endX, endY) Shorthand for setting all four start/endpoint properties. Kind: instance method of LinearGradientFill "},"reference/Matrix.html":{"url":"reference/Matrix.html","title":"Matrix","keywords":"","body":" Matrix Kind: class Matrix new Matrix(a, b, c, d, e, f) .setFrom(otherMatrix) .clone() ⇒ !Matrix .add(a, b, c, d, e, f) ⇒ !Matrix .multLeft(a, b, c, d, e, f) ⇒ !Matrix .invert() ⇒ !Matrix .translate(tx, ty) ⇒ !Matrix .scale(sx, sy, tx, ty) ⇒ !Matrix .rotate(a, x, y) ⇒ !Matrix .x(x, y) ⇒ number .y(x, y) ⇒ number .transformPoint(point) ⇒ !{x:number, y:number} .transformRect(rect) ⇒ !{x:number, y:number, width:number, height:number} .getTranslate() ⇒ !Array. .determinant() ⇒ number .split() ⇒ !{dx:number, dy:number, scaleX:number, scaleY:number, shear:number, rotate:number, isSimple:boolean} .scaleFactors([flipInfo]) ⇒ !{scaleX:number, scaleY:number} .removedScaleMatrix(scaleX, scaleY) ⇒ !Matrix .hasSkew() ⇒ boolean .getRotation() ⇒ number new Matrix(a, b, c, d, e, f) Creates a new transform matrix with the following structure: | a c e | | b d f | | 0 0 1 | Note: XD does not generally allow transform matrices with scale or shear (skew) components - only translate and rotate components are typically permitted. If no arguments, creates a new identity matrix by default. matrix.setFrom(otherMatrix) Copies another matrix's values into this matrix. Kind: instance method of Matrix Param Type Description otherMatrix !Matrix The matrix to copy values from. matrix.clone() Returns a copy of the matrix Kind: instance method of MatrixReturns: !Matrix matrix.add(aOrMatrix, b, c, d, e, f) ⇒ !Matrix Multiplies a passed affine transform to the right: this * M. The result effectively applies the transform of the passed in matrix first, followed by the transform of this matrix second. Modifies this matrix object and also returns it so calls can be chained. Kind: instance method of MatrixReturns: !Matrix - The current matrix after right multiply. Param Type Description aOrMatrix number !Matrix A Matrix or the a component of an affine transform. b ?number The b component of an affine transform. c ?number The c component of an affine transform. d ?number The d component of an affine transform. e ?number The e component of an affine transform. f ?number The f component of an affine transform. matrix.multLeft(aOrMatrix, b, c, d, e, f) ⇒ !Matrix Multiplies a passed affine transform to the left: M * this. The result effectively applies the transform of this matrix first, followed by the transform of the passed in matrix second. Modifies this matrix object and also returns it so calls can be chained. Kind: instance method of MatrixReturns: !Matrix - The current matrix after left multiply. Param Type Description aOrMatrix number !Matrix A Matrix or the a component of an affine transform. b ?number The b component of an affine transform. c ?number The c component of an affine transform. d ?number The d component of an affine transform. e ?number The e component of an affine transform. f ?number The f component of an affine transform. matrix.invert() ⇒ !Matrix Returns an inverted version of the matrix. Returns a brand new matrix - does not modify this matrix object. Kind: instance method of MatrixReturns: !Matrix matrix.translate(tx, ty) ⇒ !Matrix Applies translation before the current transform of this matrix, as if using the add() method. Modifies this matrix object and also returns it so calls can be chained. Kind: instance method of MatrixReturns: !Matrix Param Type Description tx number horizontal offset distance ty number vertical offset distance matrix.scale(sx, sy, cx, cy) ⇒ !Matrix Applies scaling before the current transform of this matrix, as if using the add() method. Modifies this matrix object and also returns it so calls can be chained. Note: scale transforms are not generally permitted in XD. Kind: instance method of MatrixReturns: !Matrix Param Type Description sx number amount to be scaled, with 1 resulting in no change sy ?number amount to scale along the vertical axis. (Otherwise sx applies to both axes.) cx ?number horizontal origin point from which to scale (if unspecified, scales from the local coordinates' origin point) cy ?number vertical origin point from which to scale matrix.rotate(angle, cx, cy) ⇒ !Matrix Applies clockwise rotation before the current transform of this matrix, as if using the add() method. Modifies this matrix object and also returns it so calls can be chained. Kind: instance method of MatrixReturns: !Matrix Param Type Description angle number angle of rotation, in degrees clockwise cx ?number horizontal origin point from which to rotate (if unspecified, scales from the local coordinates' origin point) cy ?number vertical origin point from which to rotate matrix.x(x, y) ⇒ number Returns x coordinate of the given point after transformation described by this matrix. See also Matrix.y and Matrix.transformPoint. Kind: instance method of MatrixReturns: number Param Type x number y number matrix.y(x, y) ⇒ number Returns y coordinate of the given point after transformation described by this matrix. See also Matrix.x and Matrix.transformPoint. Kind: instance method of MatrixReturns: number Param Type x number y number matrix.transformPoint(point) ⇒ !{x:number, y:number} Returns x & y coordinates of the given point after transformation described by this matrix. Kind: instance method of MatrixReturns: !{x:number, y:number} Param Type point !{x:number, y:number} matrix.transformRect(rect) ⇒ !{x:number, y:number, width:number, height:number} Transforms a rectangle using this matrix, returning the axis-aligned bounds of the resulting rectangle. If this matrix has rotation, then the result will have different width & height from the original rectangle, due to axis alignment. See \"Coordinate Spaces\" for some illustrations of this. Kind: instance method of MatrixReturns: !{x:number, y:number, width:number, height:number} Param Type rect !{x:number, y:number, width:number, height:number} matrix.getTranslate() ⇒ !Array. Kind: instance method of MatrixReturns: !Array. - The translation component of this matrix: [tx, ty]. Equals the e and f components of this matrix. matrix.scaleFactors() ⇒ !{scaleX:number, scaleY:number} Split the matrix into scale factors. This method assumes that there is no skew in the matrix. Kind: instance method of MatrixReturns: !{scaleX:number, scaleY:number} matrix.removedScaleMatrix(scaleX, scaleY) ⇒ !Matrix Returns a new matrix that contains only the translate and rotate components of the current matrix, with the given scale factors stripped out. Must be passed the exact scale factors returned by scaleFactors() for this matrix, and this matrix must have no skew/shear component. Returns a brand new matrix - does not modify this matrix object. Kind: instance method of MatrixReturns: !Matrix - The matrix without the passed scaling factors. Param Type Description scaleX number horrizontal scale component to remove scaleY number vertical scale component to remove matrix.hasSkew() ⇒ boolean Kind: instance method of MatrixReturns: boolean - true, if the matrix includes any skew (shear) "},"reference/Shadow.html":{"url":"reference/Shadow.html","title":"Shadow","keywords":"","body":" Shadow Kind: class Shadow new Shadow(x, y, blur, color, visible) .x : number .y : number .blur : number .color : !Color .visible : boolean new Shadow(x, y, blur, color, visible) Creates a drop shadow style object with the given properties. The visible argument is optional and defaults to true. Param Type x number y number blur number color !Color visible ?boolean shadow.x : number X offset of the shadow relative to the shape it is attached to, in global coordinates (i.e. independent of the shape's rotation or any parent's rotation). May be negative. Kind: instance property of Shadow shadow.y : number Y offset of the shadow relative to the shape it is attached to, in global coordinates (i.e. independent of the shape's rotation or any parent's rotation). May be negative. Kind: instance property of Shadow shadow.blur : number >= 0 Kind: instance property of Shadow shadow.color : !Color Kind: instance property of Shadow shadow.visible : boolean If false, the shadow is not rendered. The user can toggle this via a checkbox in the Properties panel. Kind: instance property of Shadow "},"reference/Blur.html":{"url":"reference/Blur.html","title":"Blur","keywords":"","body":" Blur Kind: class Blur new Blur(blurAmount, brightnessAmount, fillOpacity, visible, backgroundEffect) .blurAmount : number .brightnessAmount : number .fillOpacity : number .isBackgroundEffect : boolean .visible : boolean Blur() Creates an object blur or background blur effect object with the given properties. Param Type blurAmount number brightnessAmount number fillOpacity number [visible] boolean [isBackgroundEffect] boolean blur.blurAmount : number 0 - 50 Kind: instance property of Blur blur.brightnessAmount : number -50 - 50 For background blur effects, the amount to increase or decrease the brightness of the background. Ignored for object blur effects. Kind: instance property of Blur blur.fillOpacity : number 0.0 - 1.0 For background blur effects, the a multiplier on the opacity of the object's fill drawn over top of the blurred background. Useful to create a color tint on top of the blurred background. Does not affect stroke opacity. Ignored for object blur effects. Kind: instance property of Blur blur.isBackgroundEffect : boolean If true, renders a background blur effect: all objects beneath the shape are blurred (modulated by brightnessAmount), but the shape itself is still rendered with crisp edges (with its fill modulated by fillOpacity). If false, renders an object blur effect: the shape itself is blurred, and objects beneath it are unaffected. Kind: instance property of Blur blur.visible : boolean If false, the blur effect is not rendered. The user can toggle this via a checkbox in the Properties panel. Kind: instance property of Blur "},"reference/selection.html":{"url":"reference/selection.html","title":"selection","keywords":"","body":" selection The selection object represents the currently selected set of nodes in the UI. You can change the selection to use it as input for commands, or to control what is left selected for the user when your plugin's edit operation completes. Selected items might not all have the same parent node. For example, the selection could be split between two sibling Group nodes, or half the selection could be inside a Group and half inside its parent. Or the selection could be split between multiple different artboards along with items on the pasteboard (immediate children of the root node). Your plugin can only modify nodes in the \"neighborhood\" of the user's selection, a subset of the scenegraph tree called the edit context. You can only set the selection to other nodes within the edit context. The edit context does not update to reflect any changes to the selection until after a plugin operation completes. Other restrictions on selection The selection cannot contain both artboards and non-artboards at the same time. The selection cannot contain both a node and one of its ancestors at the same time. Items that are locked cannot be in the selection. If the user or your plugin attempts to select any locked items, they are automatically filtered into a separate list (itemsIncludingLocked) which is generally only used by the Unlock command. Accessing the selection The current selection state is passed to your command handler function as an argument: function myCommand(selection, documentRoot) { console.log(selection.items.length + \" items are selected\"); } module.exports = { commands: { myCommandId: myCommand } }; You can also access this object from the scenegraph.selection property. Kind: object selection .items : !Array .itemsIncludingLocked : !Array .hasArtwork : boolean .hasArtboards : boolean .insertionParent : !SceneNode .focusedArtboard : ?Artboard .editContext : !SceneNode .isInEditContext(node) ⇒ boolean selection.items : !ArraySceneNode> Array representing the current selection. Empty array if nothing is selected (never null). Items might not all have the same parent node. Never includes locked nodes. Never mixes artboards with other nodes: a selection is either all artboards or all non-artboards. Never includes any ancestors of any other item in the selection. As a convenience, the setter also accepts a single node or null as valid input. However, the getter always returns an array. If the user selects nodes one-by-one, by Shift-clicking, this array lists the nodes in the order they were added to the selection. If the user selected by other means, e.g. dragging a marquee, the order has no meaning. Returns a fresh array each time, so modifying the array returned by the getter does not change the selection – only invoking the 'items' setter changes selection. The selection can only contain items which are in the current edit context. Kind: instance property of selectionExample console.log(\"There are \" + selection.items.length + \" nodes currently selected\"); selection.items = [rectangle, ellipse, path]; // select 3 nodes selection.items = rectangle; // select 1 node (convenience) selection.items = null; // deselect all (convenience) selection.itemsIncludingLocked : !ArraySceneNode> Array representing the current selection plus any locked items that the user has attempted to select. Kind: instance property of selectionRead only: trueExample let numUnlockedSelected = selection.items.length; let numLockedSelected = selection.itemsIncludingLocked.length - numUnlockedSelected; console.log(\"There are \" + numLockedSelected + \" locked nodes 'sort of' currently selected\"); selection.hasArtwork : boolean True if the selection isn’t empty and consists of one or more non-Artboards. Never true at the same time as hasArtboards. Kind: instance property of selectionRead only: true selection.hasArtboards : boolean True if the selection isn’t empty and consists of one or more Artboards. Never true at the same time as hasArtwork. Kind: instance property of selectionRead only: true selection.insertionParent : !SceneNode The preferred parent to insert newly added content into. Takes into account the current edit context as well as the \"focused artboard\" if in the root context. Typically this is the same parent where, for example, XD's shape drawing tools would add items. Selected items are not necessarily all immediate children of the insertionParent. They can be anywhere within the edit context's scope. Kind: instance property of selectionRead only: true selection.focusedArtboard : ?Artboard The artboard the user is currently most focused on (via recent selection or edit operations). May be null, for example if no artboards exist or if the user just deleted an artboard. Kind: instance property of selectionRead only: true selection.editContext : !SceneNode The common ancestor node of all selected items - also the root node of the subtree containing the \"edit context,\" which is the scope in which selection and edit operations must occur for the current plugin command. The scope does not necessarily cover the entire subtree rooted at the editContext root node – it may only cover a subset of this tree. See edit context documentation page for more details. If the user hasn't drilled into any container node, this value is the document root. The value of editContext does not change while your plugin is running. However, the editContext may change after your plugin operation ends: If your plugin changes the value of selection.items to include fewer nodes, the edit context may be narrowed. If your plugin has deleted nodes such that the current container is now empty, the edit context will pop up a level and the now-empty container is automatically cleaned up. Kind: instance property of selectionRead only: true selection.isInEditContext(node) Since: XD 28 Returns true if the node is accessible for editing in the scope of the current edit context. If false, the node cannot be edited given the user's current selection. Nodes that are currently selected are always in the current edit context. Kind: instance method of selectionReturns: boolean Param Type node !SceneNode "},"reference/application.html":{"url":"reference/application.html","title":"application","keywords":"","body":" application The application module exposes APIs for exporting content, initiating edits from panel UI, and getting version / locale info. application .editDocument(options, editFunction) | (editFunction) .createRenditions(renditions) ⇒ Promise .version : string .appLanguage : string .systemLocale : string .activeDocument : !DocumentInfo application.editDocument(options, editFunction) | (editFunction) Call editDocument() from a plugin panel UI event listener to initiate an edit operation batch in order to modify the XD document. This API is irrelevant for plugin menu item commands, which are wrapped in an edit batch automatically. XD calls the editFunction() synchronously (before editDocument() returns). This function is treated the same as a menu command handler: It is passed two arguments, the selection and the root node of the scenegraph It can return a Promise to extend the duration of the edit asynchronously You can only call editDocument() in response to a user action, such as a button \"click\" event or a text input's \"input\" event. This generally means you must call it while a UI event handler is on the call stack. For UI events that often occur in rapid-fire clusters, such as dragging a slider or pressing keys in a text field, XD tries to smartly merge consecutive edits into a single atomic Undo step. See the mergeId option below to customize this behavior. Kind: static method of application Param Type Description options EditSettings= Optional settings object (see below). This argument can be omitted. editFunction !function(!Selection, !RootNode):?Promise Function which will perform your plugin's edits to the scenegraph. Typedef EditSettings Property Type Description editLabel ?string Used as the Undo label in the Edit menu. If unspecified, XD uses the uxp-edit-label attribute on the DOM node which the user interacted with, and if that does not exist then the plugin's name will be used. mergeId ?string If two consecutive edits to the same selection have the same mergeId, they are flattened together into one Undo step. If unspecified, for \"high frequency\" UI events (see above), XD treats the originating DOM node as a unique identifier for merging; for other UI events, merging is disabled. Example let Color = require(\"scenegraph\").Color; let application = require(\"application\"); let panelButton = document.querySelector(\"panel #myButton\"); // When button is clicked, set selected item's fill to solid red panelButton.addEventListener(\"click\", event => { application.editDocument(selection => { selection.items[0].fill = new Color(\"red\"); }); }); For comparison, plugin menu command handlers are effectively run as if they were passed to editDocument() with editLabel set to the menu item's label and mergeId set to null. application.createRenditions(renditions) Generate renditions of nodes in the document in a batch. Overwrites any existing files without warning. A single createRenditions() call can generate any number of renditions, including multiple renditions of the same node (with different output settings) or renditions of multiple different nodes. Only one createRenditions() call can be executing at any given time, so wait for the Promise it returns before calling it again. Kind: static method of applicationReturns: Promise, string> - Promise which is fulfilled with an array of RenditionResults (pointing to the same outputFiles that were originally passed in, or rejected with an error string if one or more renditions failed for any reason. Param Type Description renditions Array List of renditions to generate Typedef RenditionSettings All rendition settings fields are required (for a given rendition type) unless otherwise specified. Property Type Description node !SceneNode Root of scenegraph subtree to render. This may be any node in the scenegraph, regardless of the current edit context. outputFile !uxp.storage.File File to save the rendition to (overwritten without warning if it already exists) type string File type: RenditionType.PNG, JPG, PDF, or SVG scale number (PNG & JPG renditions) DPI multipler in the range [0.1, 100], e.g. 2.0 for @2x DPI. quality number (JPG renditions) Compression quality in the range [1, 100]. background ?Color (PNG & JPEG renditions) Alpha component ignored for JPG. Optional: defaults to transparent for PNG, solid white for JPG. minify boolean (SVG renditions) If true, SVG code is minified. embedImages boolean (SVG renditions) If true, bitmap images are stored as base64 data inside the SVG file. If false, bitmap images are saved as separate files linked from the SVG code. Typedef RenditionResult Property Type Description outputFile !uxp.storage.File File the rendition was written to (equal to outputFile in RenditionSettings) Example // Generate PNG rendition of the selected node let application = require(\"application\"); let fs = require(\"uxp\").storage.localFileSystem; let file = await fs.getFileForSaving(); let shape = selection.items[0]; let renditions = [ { node: shape, outputFile: file, type: application.RenditionType.PNG, scale: 2 } ]; application.createRenditions(renditions).then(function(results) { // ...do something with outputFiles on disk... }); application.version : string Adobe XD version number in the form \"major.minor.patch.build\" Kind: static property of applicationRead only: true Example console.log(\"Version:\", application.version); // e.g. \"13.0.21.3\" application.appLanguage : string Current language the application UI is using. This may not equal the user's OS locale setting: it is the closest locale supported by XD - use this when you want your plugin's UI to be consistent with XD's UI. Specifies language only, with no region info (e.g. \"fr\", not \"fr_FR\"). Kind: static property of applicationRead only: true Example console.log(\"XD locale:\", application.appLanguage); // e.g. \"en\" application.systemLocale : string User's OS-wide locale setting. May not match the XD UI, since XD does not support all world languages. Includes both language and region (e.g. \"fr_CA\" or \"en_US\"). Kind: static property of applicationRead only: true Example console.log(\"OS locale:\", application.systemLocale); // e.g. \"en_US\" application.activeDocument : !DocumentInfo Information about the document which this instance of the plugin is attached to. This does not indicate the frontmost \"active\" document window in the XD application. In XD, each document window loads a separate copy of your plugin. When a given instance of your plugin calls this API, you will always receive information about the document that this instance of the plugin is attached to, even if it's not the active window. Kind: static property of applicationRead only: true Typedef DocumentInfo Property Type Description name string Document name as displayed in the titlebar. For untitled documents, this will be a localized string such as \"Untitled-1.\" guid string Semi-unique document identifier. Duplicating an .xd file on disk will result in two files with the same GUID. Duplicating a document via \"Save As\" will change its GUID; thus two cloud documents will never have the same GUID. The GUID of an Untitled document doesn't change when it is saved for the first time. This returns the same value as scenegraph.root.guid. Example let application = require(\"application\"); let documentInfo = application.activeDocument; console.log(\"Document title: \" + documentInfo.name); console.log(\"Document ID: \" + documentInfo.guid); "},"reference/assets.html":{"url":"reference/assets.html","title":"assets","keywords":"","body":" assets Represents the document styles listed in the Assets panel. Styles can be added and removed manually by the user, so there's no guarantee that these styles are currently used anywhere in the document's content. Since: XD 15 assets .colors .get() ⇒ !Array. .add(colorAssets) ⇒ number .delete(colorAssets) ⇒ number .characterStyles .get() ⇒ !Array. .add(charStyleAssets) ⇒ number .delete(charStyleAssets) ⇒ number .GradientType enum Typedefs: ColorAsset GradientAsset CharacterStyleAsset CharacterStyle Enums GradientType : LINEAR, RADIAL - Type of gradient color element: linear gradient or radial gradient Typedefs Typedef ColorAsset Assets library entry representing a solid color. Property Type Description name ?string Name of the Assets entry, if it is explicitly named. (The UI shows an auto-generated label for any unnamed assets). color !Color Color of the asset Typedef GradientAsset Assets library entry representing a linear or radial gradient. Property Type Description name ?string Name of the Assets entry, if it is explicitly named. (The UI shows an auto-generated label for any unnamed assets). gradientType !GradientType Either GradientType.LINEAR or GradientType.RADIAL colorStops !Array. Array of color stops used in the gradient, where stop >= 0 and colorStops property of a LinearGradientFill object. Typedef CharacterStyleAsset Assets library entry representing a set of text character styles. Property Type Description name ?string Name of the Assets entry, if it is explicitly named. (The UI shows an auto-generated label for any unnamed assets). style !CharacterStyle Object containing the style properties Typedef CharacterStyle Character style properties. See documentation for the Text node type for more details. When creating a new character style, all properties are mandatory except those with default values specified here. When deleting an existing character style, always pass the exact object returned by characterStyles.get() (with all properties fully specified) to avoid any ambiguity. Property Type Description fontFamily !string the font family fontStyle !string the style of the font fontSize !number the size of the font fill !Color the Color of the font fill charSpacing !number the character spacing lineSpacing !number the line spacing underline !boolean whether underline is turned on strikethrough ?boolean (Since: XD 19) Default false; whether strikethrough is turned on textTransform ?string (Since: XD 19) Default \"none\"; one of \"none\", \"uppercase\", \"lowercase\", or \"titlecase\" textScript ?string (Since: XD 20) Default \"none\"; one of \"none\", \"superscript\", or \"subscript\" assets.colors The collection of colors and gradients saved in this document's Assets library. .colors .get() ⇒ !Array. .add(colorAssets) ⇒ number .delete(colorAssets) ⇒ number assets.colors.get() ⇒ !Array. Get a list of all color/gradient assets, in the order they appear in the Assets panel. The list may contain a mix of solid Color assets and/or gradient assets. If there are no color/gradient assets, an empty array is returned. Kind: static method of colors Returns: !Array. Example var assets = require(\"assets\"), allColors = assets.colors.get(); assets.colors.add(colorAssets) ⇒ number Add color/gradient assets to the collection. The list may contain a mix of solid Color assets and/or gradient assets. Items are not added if a duplicate color/gradient already exists in the collection, regardless of its name. Kind: static method of colors Returns: number - number of assets added (may be less than requested if duplicates already exist) Param Type colorAssets ! Color | ColorAsset | LinearGradientFill | RadialGradientFill | GradientAsset | Array. Example var assets = require(\"assets\"), redColor = new Color(\"red\"), blueColor = new Color(\"blue\"), stops = [{ stop: 0, color: redColor }, { stop: 1, color: blueColor }], numAdded = assets.colors.add([ redColor, { name: \"True Blue\", color: blueColor }, { name: \"Red Blue Gradient\", gradientType: assets.GradientType.LINEAR, colorStops: stops } ]); assets.colors.delete(colorAssets) ⇒ number Delete color/gradient assets from the collection. The list may contain a mix of solid Color assets and/or gradient assets. Assets with the same color/gradient are removed even if their names differ. Assets that already don't exist in the collection are silently ignored. Typically you will pass asset objects returned from get() directly to this function. Kind: static method of colors Returns: number - number of assets deleted (may be less than requested if some didn't exist) Param Type colorAssets ! Color | ColorAsset | LinearGradientFill | RadialGradientFill | GradientAsset | Array. Example var assets = require(\"assets\"), numDeleted = assets.colors.delete(new Color(\"red\")); assets.characterStyles The collection of character styles saved in this document's Assets library. .characterStyles .get() ⇒ !Array. .add(charStyleAssets) ⇒ number .delete(charStyleAssets) ⇒ number assets.characterStyles.get() ⇒ !Array. Get a list of all character style assets, in the order they appear in the Assets panel. If there are no character style assets, an empty array is returned. Kind: static method of characterStyles Returns: !Array. Example var assets = require(\"assets\"), allCharacterStyles = assets.characterStyles.get(); assets.characterStyles.add(charStyleAssets) ⇒ number Add one or more character style assets to the collection. Items are not added if a duplicate character style already exists in the collection, regardless of its name. All character style properties must be fully specified (no properties are optional). Kind: static method of characterStyles Returns: number - number of assets added (may be less than requested if duplicates already exist) Param Type charStyleAssets ! CharacterStyleAsset | Array. Example var assets = require(\"assets\"), arialItalic = { fontFamily: \"Arial\", fontStyle: \"Italic\", fontSize: 12, fill: new Color(\"black\"), charSpacing: 0, lineSpacing: 0, underline: false, strikethrough: false, textTransform: \"uppercase\" }, linkTextStyle = { fontFamily: \"Arial\", fontStyle: \"Regular\", fontSize: 12, fill: new Color(\"blue\"), charSpacing: 0, lineSpacing: 0, underline: false // (leaves optional strikethrough, textTransform, & textScript properties at default values) }, numAdded = assets.characterStyles.add([ { style: arialItalic }, // No name provided: uses default name { style: linkTextStyle, name: \"Link Text\" } ]); assets.characterStyles.delete(charStyleAssets) ⇒ number Delete one or more character style assets from the collection. Assets with the same character style are removed even if their names differ. Assets that already don't exist in the collection are silently ignored. All character style properties must be fully specified (no properties are optional). To avoid ambiguity, pass the exact asset objects returned from get() directly to this function. Kind: static method of characterStyles Returns: number - number of assets deleted (may be less than requested if some didn't exist) Param Type charStyleAssets ! CharacterStyleAsset | Array. Example // Delete all character style assets from the assets panel var assets = require(\"assets\"), allCharacterStyles = assets.characterStyles.get(), numDeleted = assets.characterStyles.delete(allCharacterStyles); "},"reference/clipboard.html":{"url":"reference/clipboard.html","title":"clipboard","keywords":"","body":" clipboard This module lets you copy text to the clipboard. It is not yet possible to copy other content types, or to handle paste events. Example // Copy the layer name of the selected item to the clipboard let clipboard = require(\"clipboard\"); clipboard.copyText(selection.items[0].name); clipboard .copyText() clipboard.copyText() Write plain text to the clipboard. Kind: static method of clipboard Param Type Description text string Will be automatically converted to string if a different type is passed "},"reference/cloud.html":{"url":"reference/cloud.html","title":"cloud","keywords":"","body":" cloud The cloud module lets you get information about shared prototypes and design specs. Example // Get prototypes data const cloud = require(\"cloud\"); var sharedArtifacts = cloud.getSharedArtifacts(); var prototypes = sharedArtifacts.filter(artifact => (artifact.type === cloud.ArtifactType.PROTOTYPE)); prototypes.forEach(artifact => { console.log(\"Prototype URL: \", artifact.url); }); Example // Get design specs data const cloud = require(\"cloud\"); var sharedArtifacts = cloud.getSharedArtifacts(); var specs = sharedArtifacts.filter(artifact => (artifact.type === cloud.ArtifactType.SPECS)); specs.forEach(artifact => { console.log(\"Design Spec URL: \", artifact.url); }); Since: XD 14 cloud .getSharedArtifacts() ⇒ !Array. Enums ArtifactType : PROTOTYPE, SPECS - Type of shared artifact: interactive prototype only, or developer-focused specs view (which may also include access to an interactive prototype view) TargetPlatform : WEB, IOS, ANDROID - Target platform for published design specs AccessLevel : LINKABLE, PASSWORD_PROTECTED, INVITE_ONLY - Access level of the shared link: accessible to anyone with the link, anyone with the link + password, or only specific Creative Cloud user accounts cloud.getSharedArtifacts() Get a list of recently shared artifacts generated from this document. Older artifacts may not be included even if the shared links are still live. Shared links that have been deleted from the server (File > Manage Published Links) may still be listed here, as this API only provides a record of recent share actions from XD - not what the links' current status on the server may be. The list may contain a mix of PrototypeArtifact and/or SpecsArtifact, and items are listed in no particular order. If nothing has been shared from this document, an empty array is returned. Kind: static method of cloud Returns: !Array. Typedef BaseSharedArtifact Properties common to both types. Property Type Description type ArtifactType Type of shared artifact url string URL to view in browser name string Name of shared artifact (often, but not always, matches the document name) accessLevel AccessLevel Level of access protection allowComments boolean True if stakeholders can post comments on this artifact Typedef PrototypeArtifact Interactive prototype view generated via \"Share for Review.\" Property Type Description embedURL string URL for embedding a view of the prototype inside an iframe (compact view with minimal surrounding UI) embedWidth number iframe width needed to display embedURL. May include room for navigation UI in addition to the prototype's content itself. embedHeight number iframe height needed to display embedURL. May include room for navigation UI in addition to the prototype's content itself. fullscreenInPage boolean True if prototype defaults to a view that fills the entire page, with no surrounding UI visible for navigation, commenting, etc. hotspotHints boolean True if clicking in non-interactive parts of the prototype flashes visual hints indicating the interactive spots Typedef SpecsArtifact Developer-oriented specs view generated via \"Share for Development.\" This may also allow viewing the document as an interactive prototype, with default settings (fullscreenInPage: false and hotspotHints: true). Property Type Description targetPlatform PlatformType Target platform. Determines which information and measurement units are shown by default. "},"reference/interactions.html":{"url":"reference/interactions.html","title":"interactions","keywords":"","body":" interactions The interactions module and related APIs provide read only information about the document's interactive prototype mode, including: The blue \"wires\" seen in XD's prototyping UI, known as \"interactions,\" which specify gestures/events which trigger actions to occur in the prototype. Accessible as a single consolidated global listing via this module's allInteractions API, or you can access information from specific nodes in the scenegraph via SceneNode.triggeredInteractions and Artboard.incomingInteractions. Which artboard the prototype experience begins on: homeArtboard. Properties that affect Artboard scrolling behavior: Artboard viewportHeight and node fixedWhenScrolling. Interactions are a fast-changing area in XD. APIs here have a higher likelihood of becoming deprecated, or lagging behind new XD features, than other parts of XD's plugin APIs. Since: XD 19+ (some APIs added later) Example // Get all interactions in the entire document (grouped by triggering node) var allInteractions = require(\"interactions\").allInteractions; // Get interactions triggered by the selected node var nodeInteractions = selection.items[0].triggeredInteractions; // Get all interactions leading to a particular artboard var artboard = ... var interactionsToArtboard = artboard.incomingInteractions; // Print out details of one particular interaction var interaction = ... console.log(\"Trigger: \" + interaction.trigger.type + \" -> Action: \" + interaction.action.type); See Interaction documentation below for an example of what an Interaction object looks like. interactions .homeArtboard : ?Artboard .allInteractions : !Array}> Typedefs: Interaction Trigger Action Transition Typedefs Typedef Interaction An interaction consists of a Trigger + Action pair and is attached to a single, specific scenenode. Property Type Description trigger !Trigger User gesture or other event which will trigger the action. action !Action Action that occurs. Example: { trigger: { type: \"tap\" }, action: { type: \"goToArtboard\", destination: /* Artboard node */, preserveScrollPosition: false, transition: { type: \"dissolve\", duration: 0.4, easing: \"ease-out\" } } } Note: Interaction objects are not plain JSON – they may reference scenenodes (as seen above) and other strongly-typed objects. Typedef Trigger Event which triggers an interaction. Property Type Description type string One of the trigger types listed below. Note: Additional trigger types may be added in the future. Always be sure to have a default case for unknown triggers when working with Interaction objects. \"tap\" When the user clicks or taps on a scenenode. \"drag\" When the user drags or swipes a scenenode. Can only trigger a goToArtboard action with the autoAnimate transition style. \"time\" Once a set amount of time elapses (this trigger type only exists on Artboard nodes). Additional Trigger properties: Property Type Description delay number Delay time in ms. \"voice\" When the user speaks a specific voice command. Additional Trigger properties: Property Type Description speechCommand string Phrase the user speaks to trigger this command. Typedef Action Action performed when the trigger occurs. Property Type Description type string One of the action types listed below. Note: Additional action types may be added in the future. Always be sure to have a default case for unknown actions when working with Interaction objects. \"goToArtboard\" Navigate the entire screen to view a different artboard. Additional Action properties: Property Type Description destination !Artboard Artboard to navigate to. transition !Transition Animation style with which the view transitions from the old Artboard to the new one. preserveScrollPosition boolean If both Artboards are taller than the viewport, attempts to keep the user's current scroll position the same as in the outgoing artboard. \"overlay\" Displays a second artboard overlaid on top of the current one. Additional Action properties: Property Type Description overlay !Artboard Artboard to show on top. transition !Transition Animation style in which the second Artboard transitions into view. Only certain transition types are allowed for overlays. overlayTopLeft !{x:number, y:number} Position of the overlay Artboard, in the current/base Artboard's coordinate space. \"goBack\" Reverse the last \"goToArtboard\" or \"overlay\" action, replaying in reverse whatever transition it used. \"speak\" Speak with audio output to the user. Additional Action properties: Property Type Description speechOutput string Phrase to speak to the user. locale string Locale determines the pronounciation and accent of the digital voice. Includes both language and region (e.g. \"en-us\"). voice string \"Persona\" of the digital voice to use. Available personas vary by locale. Typedef Transition Animation style with which \"goToArtboard\" and \"overlay\" actions transition from/to Artboards. Property Type Description type string One of: \"autoAnimate\", \"dissolve\", \"push\", \"slide\", \"none\" fromSide string (If type = \"push\" or \"slide\"). One of: \"L\", \"R\", \"T\", \"B\" duration number Length of animation in seconds. easing string One of: \"linear\", \"ease-in\", \"ease-out\", \"ease-in-out\", \"wind-up\", \"bounce\", \"snap\" interactions.homeArtboard : ?Artboard The starting Artboard seen when the interactive prototype is launched. Kind: static property of interactions Read only: true See: Artboard.isHomeArtboard interactions.allInteractions : !ArrayInteraction>}> Returns a collection of all interactions across the entire document, grouped by triggering scenenode. Each entry in this array specifies a triggerNode and the result of getting triggerNode.triggeredInteractions. May include interactions that are impossible to trigger because the trigger node (or one of its ancestors) has visible = false. Currently, this API excludes some types of interactions: keypress/gamepad, scrolling, hover, component state transitions, or non-speech audio playback. Kind: static property of interactions Read only: true "},"reference/commands.html":{"url":"reference/commands.html","title":"commands","keywords":"","body":" commands You can make structural changes to the scenegraph, and perform other complex operations, by programmatically invoking the same commands as XD users have access to in the UI. Because structural changes have many nuanced rules and behaviors in XD, these calls function more like automating the UI than like low-level APIs. For example, these methods do not take arguments. Instead, set the selection to the objects you want the command to target, then invoke the command. Commands may also change the selection when run - for example, group() selects the newly created Group node. Example let commands = require(\"commands\"); selection.items = [shape1, shape2, maskShape]; commands.createMaskGroup(); console.log(selection.items); // [Group] commands .group() .ungroup() .createMaskGroup() .convertToPath() .duplicate() .bringToFront() .bringForward() .sendToBack() .sendBackward() .alignLeft() .alignRight() .alignHorizontalCenter() .alignTop() .alignBottom() .alignVerticalCenter() .distributeHorizontal() .distributeVertical() .alignToPixelGrid() commands.group() Wraps the selected objects in a Group, leaving the Group selected afterward. Equivalent to Object > Group in the UI. Kind: static method of commands Example let shape1 = new Rectangle(); // ...configure Rectangle size & appearance... let label = new Text(); // ...configure Text content & appearance... // Add both nodes to the current edit context first selection.insertionParent.addChild(shape1); selection.insertionParent.addChild(label); // Select both shapes, then run the group() command selection.items = [shape1, label]; commands.group(); let group = selection.items[0]; // the new Group node is what's selected afterward commands.ungroup() Ungroups any of the selected objects that are ungroupable containers (Group, SymbolInstance, RepeatGrid, etc.). Equivalent to Object > Ungroup. Kind: static method of commands commands.createMaskGroup() Creates a masked Group from the selected objects, using the object that is highest in the z order as the mask shape. The mask shape must be a leaf node or Boolean Group. Equivalent to Object > Mask With Shape. Kind: static method of commands Example let shape1 = new Rectangle(), shape2 = new Ellipse(); // ...configure shapes' size & appearance... let maskShape = new Ellipse(); // ...configure mask shape's size... // Create a Masked Group: add all nodes to the current edit context, select them, then run the createMaskGroup() command selection.insertionParent.addChild(shape1); selection.insertionParent.addChild(shape2); selection.insertionParent.addChild(maskShape); // added last: topmost in z order selection.items = [shape1, shape2, maskShape]; // order of selection array does not matter commands.createMaskGroup(); let maskedGroup = selection.items[0]; commands.convertToPath() Converts each selected object to a Path with the exact same visual appearance. Only applies to leaf nodes and Boolean Groups. Equivalent to Object > Path > Convert to Path. Kind: static method of commands commands.duplicate() Duplicates all selected objects, leaving the duplicates selected afterward. If the objects are artboards, the duplicates are positioned to not overlap any more artboards, and are placed at the top of the artboard z order. If normal objects, each duplicate is in the exact same position as the original, and just above it in the z order (duplicates of a multiple selection will not be contiguous in the z order if the originals were not). Interactions triggered from the selected objects are only duplicated if the user is currently in the Prototype workspace. Equivalent to Edit > Duplicate. Kind: static method of commands commands.bringToFront() Brings selected objects to the front of the z order. Equivalent to Object > Arrange > Bring to Front. Kind: static method of commands commands.bringForward() Brings each selected object one step closer to the front of the z order. Equivalent to Object > Arrange > Bring Forward. Kind: static method of commands commands.sendToBack() Sends selected objects to the back of the z order. Equivalent to Object > Arrange > Send to Back. Kind: static method of commands commands.sendBackward() Sends each selected object one step closer to the back of the z order. Equivalent to Object > Arrange > Send Backward. Kind: static method of commands commands.alignLeft() Aligns all selected objects flush left. Equivalent to Object > Align > Left. Kind: static method of commands commands.alignRight() Aligns all selected objects flush right. Equivalent to Object > Align > Right. Kind: static method of commands commands.alignHorizontalCenter() Aligns all selected objects along their horizontal centerlines. Equivalent to Object > Align > Center (Horizontally). Kind: static method of commands commands.alignTop() Aligns all selected objects flush top. Equivalent to Object > Align > Top. Kind: static method of commands commands.alignBottom() Aligns all selected objects flush bottom. Equivalent to Object > Align > Bottom. Kind: static method of commands commands.alignVerticalCenter() Aligns all selected objects along their vertical centerlines. Equivalent to Object > Align > Center (Vertically). Kind: static method of commands commands.distributeHorizontal() Distributes all selected objects evenly along the X axis. Equivalent to Object > Distribute > Horizontally. Kind: static method of commands commands.distributeVertical() Distributes all selected objects evenly along the Y axis. Equivalent to Object > Distribute > Vertically. Kind: static method of commands commands.alignToPixelGrid() Shifts all selected objects and their content so they align crisply with the pixel grid. Equivalent to Object > Align to Pixel Grid. Kind: static method of commands "},"reference/viewport.html":{"url":"reference/viewport.html","title":"viewport","keywords":"","body":" viewport The viewport module represents the current UI view of the XD document's content. Example // Pan viewport to bring the region x:100, y:200, width:50, height:50 into view viewport.scrollIntoView(100, 200, 50, 50); // Pan view to the first selected object if (selection.items.length > 0) { viewport.scrollIntoView(selection.items[0]); } // Pan view to center the location x:100, y:200 viewport.scrollToCenter(100, 200); // Zoom & pan to show entire region x:100, y:200, width:50, height:50 viewport.zoomToRect(100, 200, 50, 50); console.log(\"Viewport at:\", viewport.bounds); // e.g. \"{ x:100, y:50, width:1400, height:900 }\" console.log(\"Zoom:\", viewport.zoomFactor); // e.g. \"0.66\" Since: XD 14 viewport .scrollIntoView(node) | (x, y, width, height) .scrollToCenter(x, y) .zoomToRect(node) | (x, y, width, height) .bounds : !{x:number, y:number, width:number, height:number} .zoomFactor : number viewport.scrollIntoView(node) | (x, y, width, height) Smoothly pan the viewport to bring the entire given region into view. If the region is already fully in view, does nothing. If the given region is too large to fit entirely in view, it is simply centered (zoom remains unchanged). The region can be defined by passing a SceneNode, or by explicitly specifying a rectangle in global coordinates. Kind: static method of viewport viewport.scrollIntoView(node) : Param Type node !SceneNode viewport.scrollIntoView(x, y, width, height) : Param Type x number y number width number height number viewport.scrollToCenter(x, y) Smoothly pan the viewport to center on a specific point in the document's global coordinates. Even if the point is already in view, the view pans until it is centered. Kind: static method of viewport Param Type x number y number viewport.zoomToRect(node) | (x, y, width, height) Zoom & pan the view as needed so the given region fills the viewport (with some padding). If the region is large, zooms out as needed so it fits entirely in view. If the region is smaller, zooms in so the region fills the entire viewport - may zoom in past 100% to achieve this. The region can be defined by passing a SceneNode, or by explicitly specifying a rectangle in global coordinates. Kind: static method of viewport viewport.zoomToRect(node) : Param Type node !SceneNode viewport.zoomToRect(x, y, width, height) : Param Type x number y number width number height number viewport.bounds : !{x:number, y:number, width:number, height:number} The current viewport bounds expressed in global coordinates. Kind: static property of viewport Read only: true viewport.zoomFactor : number The current viewport zoom factor (where 1.0 = 100% zoom, 0.5 = 50% zoom, etc.). Kind: static property of viewport Read only: true "},"reference/how-to-read.html":{"url":"reference/how-to-read.html","title":"How to read this reference","keywords":"","body":"How to read the reference documentation Please take a moment to familiarize yourself with the types of symbols you'll see throughout the technical documentation. Type Annotations This shorthand is used to indicate the types of arguments, return values, and object properties. Annotation Meaning [day] The parameter is optional. If it is not supplied, it will be undefined. [day=\"Monday\"] The parameter is optional, but will be supplied a default value if not provided. ?Array Type can be an Array OR null. !Array Type must be an Array; cannot be null. Primitive types (string, number, boolean) imply ! unless explicitly denoted otherwise with ?. string|number Type can be either string or number. {foo:number, bar:string} Type is an object with two properties: foo, which is type number; and bar, which is type string. string[] Type is an array of strings. Array Type is an array of strings. Promise Type is a Promise that is asynchronously fulfilled with a string. * Can be any type. NOTE: In this early stage, * is sometimes used as a placeholder for incomplete documentation. "},"known-issues.html":{"url":"known-issues.html","title":"Known issues","keywords":"","body":"XD Plugin API Known Issues General Issues Icons may be blurry or missing in the plugin panel if you don't include the full set of sizes (24px, 48px, 96px, 144px, 192px) in your plugin bundle and manifest. Developer/Side-loading Specific Plugin menus and handlers may not be in-sync across documents during development If someone modifies a plugin's files on disk while XD is running, and then opens more windows in XD, any windows that were open before reflect the old version of the plugin while windows that were opened later reflect the new version of the plugin. The menu bar will always reflect the old version of the plugin regardless of which window is current. Plugin Management If Plugin Manager is open when you invoke Reload Plugins, it will not reflect any changes to the manifest (plugin name, description, icon) until you close & reopen it. Scenegraph It is possible to set nodes to 0 width or 0 height. Scenenode setters block negative size values but allow 0 size, even though in many cases it is equally nonsensical. We do block 0 size in the UI. In the past, XD's renderer would fail asserts (possibly even crash) with 0-size objects. I couldn't repro that any more, but unless we're covering it well as an officially supported case, it could easily regress again. There are some other minor bugs though, e.g. sharing fails if you have any 0-width/height artboards and bitmap export fails if any of the top-level items you're trying to export are 0-width/height. Longer plugin command names may be truncated in the menu on Windows Workaround: keep your plugin command names short! Some types of interactions are not visible to plugins yet: keypress/gamepad, scrolling, hover, component state transitions, or non-speech audio playback. Assets Panel Plugins can modify the Assets panel contents while running in the background. Do not rely on this - in a future release, it will be blocked. Only make modifications to the document (including Assets panel) while the plugin is running a user-invoked command. User Interface When the mouse cursor is changed, it may not revert back to its original state in UWP. It is not possible to trigger the emoji selector in a text field on macOS. Many SVGs are known to render in odd ways in the UI. These issues will be addressed in the future, but we would love to hear your reports of any SVGs that don't work, and how you fixed it. When tabbing in a scroll view, the scroll view is not automatically scrolled to ensure the target control is in view (macOS Only). When using , be sure to include a name attribute. If you forget, you'll get different behavior on macOS and Windows 10. On macOS, radio buttons will not be exclusive to each other just because they are in the same container, whereas on Windows 10, radio buttons will be exclusive within the same container. As such, you should always use name to determine radio button exclusivity. Emojis are rendered in the font color on Windows 10, instead of using the emoji's colors. When a control in a panel is disabled and enabled, it is no longer reachable via TAB. This may also impact controls added after a panel is shown for the first time. HTML Elements tags must have a value attribute, or referencing the select's value property will return undefined. does not show the value as selected. Instead, get a reference to the element and call setAttribute(\"value\", …) or use the selected attribute on the option tags. If you don’t specify a width for your form, block elements inside may not take up the entire width. Workaround: always set a width for your form elements. forms only support method=\"dialog\". They do not submit to a URL automatically. It is not currently possible to specify the tab order. The size of a cannot be set with rows or cols. Use CSS styles height and width respectively. HTML5 input validation is not supported. Images that fail to load will not render any “broken icon” image in place. Input elements do not accept defaultValue. tags do not support disabled attributes. is not supported. Wrap around the control instead. is not supported. is not supported. Using unitless values in width and height attributes are not supported in UXP 3.1. Use px, or CSS styles. uses inline-flex layout semantics in UXP 3.1 mode, with flex-wrap: wrap enabled. If you need to prevent wrapping, use flex-wrap: nowrap on these elements. Note that the default layout behavior is now horizontal not vertical. Layout When rendering text on a screen that is not HiDPI, descenders may be clipped when using overflow: hidden. The workaround is to add a little bit of padding to the bottom of the element. When rendering inline elements in plugins with a host.minVersion of 21 or better, spaces between elements may be ignored. This is most obvious when using constructs like Click this link: link. Currently UXP will ignore the space between the b tag and the anchor, resulting in the following visual rendering: Click this link:link instead of Click this link: link. This will be addressed in the next release. To work around this issue, include a space inside one of the tags, like so: Click this link: link When rendering inline text that wraps, borders, outlines, and backgrounds only apply to the first line. You should place borders, outlines, and backgrounds on elements with block layout semantics. Mixing inline text with UI controls is unlikely to result in a pleasant appearance. vertical-align is not yet supported, which makes it difficult to properly align widgets and labels. As such, you should use flex or inline-flex when using UI elements. CSS It is not currently possible to assign multiple border colors to a container. Do not use position: fixed in panels for now; a future update will change its behavior. :active is not currently supported. baseline alignment is not currently supported. The font shorthand CSS rule is not supported. text-transform is not supported In order to clip an image (say, with border-radius: 10px), you must also specify overflow: hidden. CSS transitions and animations are not supported. A solid outline will not render unless a color is also provided. When using outline: solid, be sure to supply an outline color as well. Font sizes do not adjust to dynamic units like vh. As such, if you use font-size: 1vh, and the viewport changes size, the font size will not adjust. Setting a border-color to unset may not reset the color to its initial value. Borders and backgrounds are not drawn correctly when coupled with object-fit. The bottom border may not always render with the same width as the other borders. Underlines may render very thin. calc only works for length properties. Using calc for a color will not work. If you need to override an anchor link color, use a[href] as the selector to override it. DOM When a dialog is closed, it is not removed from the DOM. This is per spec. If you want the dialog to be removed from the DOM, you must call HTMLDialogElement#remove explicitly. When applying HTML using innerHTML, event handlers and scripts are not parsed. This is by design. Events Interactive elements do not support Pointer% events keypress and keyup are not currently supported on macOS. Drag & Drop drag and dragexit are not supported, although other HTML5 drag/drop events do work. Images and text are not implicitly draggable, unlike in HTML. You must provide a dragstart handler that calls event.dataTransfer.setData(). Dragging files or other content onto your plugin UI from an outside source is not supported. Network I/O On macOS, it is not possible to use self-signed certificates with secure Websockets. Websockets do not support extensions. XHR can only send binary content using an ArrayBuffer – Blob is not supported. XHR does not support cookies. responseURL is not supported on XHR File I/O Blob is not supported. Use ArrayBuffer instead. Debugging XD may be unstable while debugging a plugin. Don't debug when you have important XD documents open. Debugging on Windows requires some extra steps run with admin rights – see tutorial for details. Elements tab: If you leave CDT on the Elements tab, XD will crash the next time you open it. If this happens, keep CDT open after XD crashes and switch to a different tab. Then close CDT, restart XD, and begin debugging again. The CSS pane on the right is missing some data and cannot be used to edit CSS. Selecting/hovering elements does not highlight the corresponding region in the XD UI. The \"Select an element\" button does nothing. Error messages are often missing from the Console view. Use the Plugins > Development > Developer Console view in XD to be sure you are not missing any important information. Other DevTools features such as the Network or Profiling tabs are not supported and may behave erratically if you attempt to use them. XD will be partially frozen while paused on a JS breakpoint. Don't try to interact with XD while paused. You may see a blank white panel to the left of the DevTools UI. Ignore this, as it does nothing. If debugging exposes any private fields and methods, do not attempt to use them. Plugins referring to private APIs will be rejected or removed from XD's plugin listing. "},"changes.html":{"url":"changes.html","title":"Change log","keywords":"","body":"Change Log XD Release 28.0.12 (March 2020) XD 28 is a minor update for plugin developers: SceneNode.BLEND_MODE_* constants for use with the SceneNode.blendMode property (which was introduced in XD 27). Quickly look up a scenenode by its GUID with scenegraph.getNodeByGUID(). Easily check if a scenenode is currently in scope for editing with isInEditContext(). Known Issues XD 28 introduces two new types of interaction actions: audio-file playback, and \"scroll to\" actions. Interactions using these features are not visible to plugins yet (speech playback interactions are exposed though). See the interactions API documentation for a complete list of which interaction types are & aren't exposed to plugins at this time. Read more about XD 28 new features for end users on the Adobe blog. XD Release 27.0.12 (February 2020) XD 27 is a minor update for plugin developers, with one new added API: Get and set SceneNode.blendMode Read more about XD 27 new features for end users on the Adobe blog. XD Release 26.0.12 (January 2020) Drag & drop UXP now supports the HTML5 Drag & Drop specification for some specific use cases: Drag & drop within your plugin's UI On the drag source in your UI, set the draggable attribute and define a dragstart event handler that stores whatever data you want via dataTransfer.setData(). On the drop target in your UI, defined dragenter, dragover, and drop event handlers that react appropriately. Drag from plugin panel UI into XD document Only bitmap images, SVG content, or text can be dropped into the document. Provide the mimetype text/uri-list and populate it only with local file paths (see File.nativePath) and/or data: image URIs. This will behave exactly the same as if the user had dropped files onto XD – dropping an image onto a shape will use it as a mask, dropping multiline text onto a Repeat Grid text node will populate each grid cell with each line from the text content, etc. It is not yet supported to drag content onto your plugin from an outside source (e.g. dropping files on your plugin UI, or dragging images from another app into your plugin UI). For more, see this sample plugin code. Debugging with Chrome DevTools (beta) You can now use the Chrome DevTools UI (CDT) to debug your JS code – and to a limited extent, inspect your UI DOM structure. Read the updated debugging tutorial for details. What works: Set breakpoints, pause & stop through code, inspect the values of variables View objects and run code in the Console view View and edit the \"HTML\" DOM structure of your plugin's UXP UI Important caveats: XD may be unstable while debugging a plugin. Don't debug when you have important XD documents open. If you leave CDT on the Elements view, XD will crash the next time you open it. If this happens, keep CDT open after XD crashes and switch to a different tab. Then close CDT, restart XD, and begin debugging again. Debugging on Windows requires some extra steps run with admin rights – see tutorial for details. Many features in the Elements tab do not work. You can view DOM structure, and view limited CSS information but not edit CSS rules. The \"Select an element\" button does nothing. Error messages are often missing from the Console view. Use the Plugins > Development > Developer Console view in XD to be sure you are not missing any important information. Other DevTools features such as the Network or Profiling tabs are not supported and may behave erratically if you attempt to use them. XD will be partially frozen while paused on a JS breakpoint. Don't try to interact with XD while paused. You may see a blank white panel to the left of the DevTools UI. Ignore this, as it does nothing. Other API updates Polygon scenenodes can now take on a star shape - see Polygon.starRatio XD Release 25.1.12 (December 2019) XD 25 is a minor bug-fix release with no new features for end users. But it adds two small improvements for plugins: New application.activeDocument API providing information about the document. Fixed bug where scenegraph.root.guid did not return a valid guid; it now returns the same value as application.activeDocument.guid. XD Release 24.0.22 (November 2019) New XD Features Read more about XD's biggest release of the year here. Live Co-editing beta Plugin edit operations (editDocument() or menu commands) are still fully atomic. Outside those blocks, edits from a remote user can come in at any time, just like edits from the local user could. Edits made by remote users will trigger a plugin panel's update() method, just the same as edits made by the local user. If a plugin edit conflicts with a remote user's edit that started slightly sooner, the plugin edit will get cleanly reverted (in favor of the other user's edit) after the plugin operation has fully completed. Remote updates are paused in a known-good document state while a plugin edit is in progress (including the lifespan of any modal dialogs), so the scenegraph state won't change while your code is in the middle of processing it. Similarly, updates made by the plugin are sent atomically to remote users once the entire plugin edit operation has finished. Component states & interactions For each Component instance, only the currently active state is visible in the scenegraph hierarchy. Content in other, non-visible states is not accessible to plugins yet. Hover and state-change interactions are not exposed to plugins yet, but will be in the future. If your plugin is reading interactions/prototyping data, be sure to always have a default case if your code encounters unexpected types. Reminder: a single scenenode can return multiple interactions from node.triggeredInteractions. This was possible before in some cases, but is allowed in more cases now (for example, one node can have a click/tap trigger, a drag trigger, and a hover trigger). New Plugin Manager UI Users can rate plugins on a 5-star rating scale. Users can sort by popularity or rating, filter by category, and easily share deep links to a specific plugin. Each plugin listing now displays one or more screenshots (see \"New plugin listing process\" below for how to add these). If you have a plugin in development and an installed plugin with the same id, Plugin Manager now shows both for clarity. You can still only enable one of them at a time, though. Sharing enhancements The cloud.getSharedArtifacts() API may now return an arbitrary number of shared links, and there may be more than one link of the same type (e.g. multiple specs links). The distinction between link types has blurred a bit: links that are ArtifactType.SPECS may also include access to an interactive prototype view, just like links of type ArtifactType.PROTOTYPE. Smaller fixes and improvements Fixed issue where shell.openExternal() was allowing plugins to launch non-Web URL protocols in a way that only worked on Mac. Full cross-platform support for doing this will be added in the future. CSS / DOM event improvements in UXP plugin UI – including support for text input color, img srcset, and online/offline events. Read more. Fixed text descender clipping in plugin UI on Mac. Plugin panels now include the plugin's icons in the panel header, next to your plugin's name. Known Issues Live Co-editing is still a beta feature. Performance and reliability will not be comparable to other aspects of XD yet. Plugins that edit a large number of objects at once may not work reliably when using Live Co-editing. If the user makes multiple consecutive edits using a plugin, some of the edits may get erroneously reverted when using Live Co-editing. Plugin dialog boxes that a user leaves open for a long time may not work correctly when using Live Co-editing. Users may be unable to undo edits made by a plugin when using Live Co-editing. Hover and state-transition interactions are not returned to plugins yet when requesting the list of interactions on a scenenode or the entire document. XD Release 23.1.32 (October 2019) New plugin listing process Information shown in the plugin listing has moved out of manifest.json and is instead provided online when you submit a plugin to the listing. Submitting a plugin also now requires at least one screenshot image. Icons seen in the Plugin Manager list must be provided online during submission, but icons seen in the Plugins side panel must still be part of the plugin package folder. As of XD 23, the Plugin Manager UI ignores description, author, links, etc. in manifest.json. Submitting to the public listing is now the only way to display this info in Plugin Manager. See updated manifest documentation. As of September 24, submitting a new or updated plugin to the public listing requires supplying all these details via the developer submission portal online. See How to submit to Plugin Manager. Smaller fixes and improvements Clarified that editDocument() does not support the mergeId option for UI events that are not \"high frequency.\" Can preventDefault() on Esc or Enter in text fields to prevent the default action of sending focus back to the canvas. Fixed bug with setting opacity of BooleanGroup nodes. Plugin Manager UI shows plugins that were disabled because they're incompatible with the current version of XD, with tooltip explaining why. Several fixes to UI layout & CSS handling – details here. XD Release 22.0.12 (August 2019) After a stabilization period, plugins using panel UI are now published in the Plugin Manager listing! Fixes and improvements Fixed bugs related to editDocument() usage (also fixed in XD 21.1.12). PUT/POST requests on Windows were including an unwanted Transfer-Encoding header, which interfered with uploading data to services like Amazon S3 (e.g. giving you errors related to Content-Length). Plugins can now copy text to the clipboard in response to a panel UI DOM event without needing to call editDocument(). XD Release 21.0.12 (July 2019) XD 21 adds major updates: the ability to show panel UI, and the much-improved UXP 3 CSS & layout engine. The new layout engine likely constitutes a breaking change for any plugin with UI – read below for details. Also note that this release has an issue where transactions being wrapped by editDocument is not enforced. This will be fixed in an upcoming patch version, so you will want to continue wrapping scenegraph changes from panels in editDocument so that your plugin isn't broken when we release the fix. Plugin Panel UI Plugins can now display UI persistently in a side panel. More information: How to define a panel Panel overview / reference Panel Quick Start tutorial Migrating from dialogs to panels A new default stylesheet is provided for plugin UI that renders inside a plugin. This means that UI that renders in one manner in a modal dialog may not render in the same exact manner in a panel. UXP 3 HTML/CSS changes In order to gain access to most of these features, your plugin must opt-in to the UXP 3.1 layout engine by changing the minVersion in your manifest.json: \"host\": { \"minVersion\": \"21.0\" } NOTE: Without this change, your plugin will run in backwards-compatibility mode. Layout engine Inline layout – You now have the ability to write code like This is a link and have the link render inline with the rest of the text Layout now defaults to inline (no longer flexbox) – This may break existing plugin UI code: now span elements will render with inline, buttons will render as inline-block, etc. overflow defaults to visible (no longer hidden), per the web specification – This may break existing plugin UI code. object-fit – to control the size of images z-index Improvements to position, including correct absolute semantics. WARNING: Technically position: fixed is supported. However, you should not use it in your plugin panels because there are some bugs that will be fixed in a future update that will break if your plugin uses position: fixed. SVG UI elements New UI controls Radio buttons – Progress bars & spinners – CSS improvements linear-gradient() outline More units! – UXP now understands rem, em, px, pt, vh, vw, cm, in, etc. NOTE: UXP will now start ignoring values (other than 0) that don't specify any units, which can break older plugin UI code. CSS Variables – easily apply themes and other layout to your plugin. More pseudo-selectors – :lang and :focus calc() – For example, width: calc(100% - 9px). Note that you can mix units, just like you can on the web. Inheritance – The CSS parser now understands initial, unset, and inherit. You can also use !important to override styles (although you should use this as a last resort). Default styles are now easier to override as the specificity in the default stylesheet has been reduced. Keyboard focus – Setting tab-index to 0 will now cause any element to be focusable. You can not yet control the tab order. Known Issues See the Known Issues page for a comprehensive list of existing known issues. XD Release 20.0.12 (June 2019) UI Changes \"Launchpad\" UI and menu structure changes – XD 20 introduces a new, easier way for users to run plugins – the \"launchpad\" sidebar menu: This panel lists all installed plugins, with quick access to all the same commands as the Plugins menu. In addition, XD now arranges plugin menu items more cleanly: Multiple menu items are automatically grouped together into a submenu named after the plugin. There's no longer any need to manually specify submenus. If your plugin only has a single menu item, it'll still be available directly at the top level of the Plugins menu. However, top level menu items always use the name of the plugin. If your plugin's single menu item had a different label specified, it will be ignored. API Improvements Text scenenode super/subscript – Work with Text nodes and style assets using the new textScript feature. Known Issues No new known issues. See the Known Issues page for a comprehensive list of existing known issues. XD Release 19.0.12 (May 2019) New API Features Read prototyping interactions – Read-only access to the interactivity settings in the document (e.g. the blue \"wires\" seen in XD's prototyping UI). New Polygon node type Breaking Changes Components & Design Systems – Symbols are now called Components in XD's UI, and they support resizing and complex overrides. One important consequence of this is that sometimes only a subset of your plugin's changes will be applied to the scenegraph. When the user is editing the \"master\" copy of the Component, each individual scenegraph change (e.g. changing a single property on a single node) is automatically synced to other instances of the Component only if a given instance doesn't already have an override of the same property (or a related property). As a result, your plugin's intended changes may only be partially (non-atomically) applied in some Component instances: if your plugin command makes, say, 5 changes to the scenegraph, in some instances only, say, 3 of those changes will actually be applied. In many cases, this partial application of your plugin's changes will feel natural to users as an expected consequence of the overrides they have authored. However, you can also choose to mitigate potential confusion by warning users or disabling some editing features while the user is editing a Component \"master\" by checking isMaster on selection.editContext and its parent chain. There is currently no way to force all changes made by your plugin command to be applied atomically (i.e. all or nothing). Fixes and improvements Additional Text scenenode styles – Work with Text nodes and style assets using the new strikethrough and text transform features. User-facing plugin features Plugin listing: View popular & Editor's Choice plugins – Use the dropdown at the top of the plugin listing to view the top 10 most popular plugins or the latest featured plugins selected by our review team. Known Issues No new known issues. See the Known Issues page for a comprehensive list of existing known issues. XD Release 18.0.12 (April 2019) New API Features Text field controls: – displays search icon – restricted to numeric characters, and Up/Down arrow keys automatically change the value CSS improvements: Inline style attributes now work when used with innerHTML and friends. Pseudo-class :focus Pseudo-class :lang() Send FormData with XHR – This provides an easy way to post data to an endpoint expecting multipart/form-data. (But uploading binary files with Blob is not supported yet – use ArrayBuffer). requestAnimationFrame() for UI – Complimenting the earlier addition of setTimeout() APIs, this new global API makes it easier to use certain UI libraries such as \"react-virtualized\" with fewer polyfills. These APIs do not allow plugins to control animations in the XD document – plugins can still only modify the document as part of an atomic operation while the UI is blocked. But this API does allow for simple animations in your plugin's dialog UI (e.g. a progress indicator). Breaking Changes develop folder location change (Mac only) – The \"Adobe XD CC\" folder was renamed to just \"Adobe XD.\" The contents of the develop folder will automatically be moved to the new location the first time you launch XD 18. Checkboxes with React – Checkboxes now correctly trigger change events in React. The previously recommended workaround (using ref to manually assign an event handler) will now cause your change handler to get invoked twice. Advance warning: In the near future XD's scenegraph will add at least one new subclass of GraphicNode (i.e. a new leaf node shape type). Always be sure to have a default case for unknown scenenode types/classes when traversing the scenegraph. Fixes and improvements UI control / DOM API fixes: It is now possible to set a checkbox to checked by using . tags do now support selected attributes, but do not support disabled attributes. Accepting text in Japanese IME by presing Enter no longer triggers the default button in a dialog. Fixed an issue where sometimes the image size is 0 in a plugin. Corrected spacing of text using lineHeight property. Fixed handling selected attribute of option to set default option. parentNode on document now returns null instead of undefined Fixed forEach for NodeList . Node previousSibling and nextSibling when not set should return null and not undefined. Fixed for DOMTokenList item and contains method bugs. Fix checkbox issues when using a label. Network API fixes: XMLHttpRequest throws error with request status 500 for NSURLConnection error codes. File API fixes: Misleading error message when getEntry() fails. Corrected the behavior of types argument in getFileForSaving API. User-facing plugin features Plugin listing displays new fields – The summary, languages, and website fields that were recently added to the manifest are now displayed in the Discover/Manage Plugins UI. Known Issues No new known issues. See the Known Issues page for a comprehensive list of existing known issues. XD Release 17.0.12 (March 2019) New API Features Select & edit across groups: Users can now select multiple items that are in different containers at the same time. This has several effects on plugins: Do not assume all selected items have the same parent node. Previously, this was already true in certain special cases – for example, users could select items that are the immediate children of several different artboards. Now, it can happen in far more cases, so plugins must take extra care to avoid any assumptions about node parents. Wider \"edit scope\" surrounding the selection. Previously, plugins could edit the selected nodes and all their siblings (with a slightly broader scope as a special case in the \"root edit context\"). Now, plugins can edit any nodes in the subtree of the common ancestor of all the selected nodes, if those nodes are connected to the common ancestor through a parent chain consisting entirely of plain Groups (or Artboards). See the edit context documentation for details and examples. Plugins still cannot edit globally across the entire document at once, even though in very simple testing it may _appear that this works. Non-Group containers act as blockades that the edit scope cannot cross - if the selection is outside such a container, you cannot edit inside it; and if the selection is inside such a container, you cannot edit outside it. Additional manifest fields required for publishing: As of March 5, submitting a new or updated plugin for the in-app plugins listing requires providing new summary, author, and languages fields, as well as several additional icon sizes. See manifest documentation. Breaking Changes No breaking changes. Fixes and improvements No other API changes. User-facing plugin features Plugin update notifications: Users see an in-app notification when any installed plugins have a newer version available in the plugins listing. Known Issues No new known issues. See the Known Issues page for a comprehensive list of existing known issues. XD Release 16.0.12 (February 2019) New API Features setTimeout() & friends: setTimeout(), setInterval(), setImmediate(), and the corresponding clear*() methods are now available as global APIs. These APIs do not allow plugins to control animations in the XD document – plugins can still only modify the document as part of an atomic operation while the UI is blocked. But timeout APIs do allow for simple animations in your plugin's dialog UI (e.g. a progress indicator), \"debouncing\" user input, etc. – and they help support web frameworks like React with fewer polyfills needed. Breaking Changes No breaking changes. Fixes and improvements No other API changes. Known Issues No new known issues. See the Known Issues page for a comprehensive list of existing known issues. XD Release 15.0.12 (January 2019) New API Features Assets panel colors & text styles: Get/add/remove any colors, gradients, and text styles saved in the Assets panel. Deep link to plugin listings: Link from web sites, social media, etc. directly to your plugin listing in XD's UI so users can easily install the plugin. Breaking Changes No breaking changes. Fixes and improvements No other API changes. User-facing plugin features Disable plugins: Temporarily disable a plugin without uninstalling it or erasing its data. Choose Plugins > Manage Plugins, then click the \"...\" menu for a specific plugin and choose Disable. A disabled plugin does not appear anywhere in the XD UI other than the Manage Plugins view, and none of its code is loaded or run. Force stop: If a plugin operation is blocking XD for more than one second with no UI shown, the user sees a spinner with the option to force-stop the plugin. This does not stop the plugin's code from running, but it reverts any partially-completed changes to the document and revokes the plugin from being the foreground operation (unblocking the XD UI and blocking the plugin from making document changes until it's invoked again by the user). If the plugin does eventually reawaken and try to continue running code from earlier, any attempts to modify the document will throw an error. Known Issues New: Plugins can modify the Assets panel contents while running in the background. Do not rely on this - in a future release, it will be blocked. See the Known Issues page for a comprehensive list of existing known issues. XD Release 14.0.42 (December 2018) New API Features Document & node metadata: Store plugin-specific info on individual scenegraph nodes or in the document in general. Viewport: Pan and zoom the view of the document, and get information about the current viewport bounds. Text: Get/set paragraph spacing; create/modify area text; more easily work with uniform-styled text via convenience getter/setter APIs for character attributes. Published links: Get latest links for prototypes & design specs that have been shared from the current document. Breaking Changes Plugins can only write to the clipboard or modify the selection while actively running a menu command (same as the rules for making scenegraph changes). Fixes and improvements For convenience, the arguments passed to plugin commands are now also available as scenegraph.selection and scenegraph.root. Exporting renditions to a folder created by your plugin now works reliably on Windows if the folder name contains spaces or other special characters. Rectangle.cornerRadii now returns correct values if the corners are not all the same radius. User-facing plugin features \"Discover Plugins\" listing improvements: Sort by plugin name, in addition to the default of sorting by release date. Searching the plugin listing now searches the description field in addition to just the plugin title. Safe mode: To temporarily disable all plugins for troubleshooting purposes, launch XD while holding down Shift. Re-launching XD will re-enable all plugins. Uninstalling a plugin now clears its data/settings folder. Users are now prompted to confirm before uninstalling. Known Issues No new known issues. See the Known Issues page for a comprehensive list of existing known issues. XD Release 13.0.12 (October 2018) First release of Adobe XD featuring a public API for in-app plugins! "},"GLOSSARY.html":{"url":"GLOSSARY.html","title":"Glossary","keywords":"","body":"Glossary Welcome to the glossary! This is a list of terms to make sure we're all talking about the same thing. Glossary terms are highlighted throughout the documentation like this: JavaScript. To see the definition, just hover your mouse over the word, or click on the word to jump back to this glossary page. Application An XD-specific namespace that provides access to various methods that aren't specific to the XD document. Read more. Base64 A representation of binary data that can be transferred safely over the internet. Clipboard A temporary storage location that the user can utilize to save or retrieve text or other snippets on command. Adobe XD provides an API for accessing the clipboard. Class A template (of sorts) used to instantiate objects. An instance has the same instance methods and properties as specified in the class. CSS Short for Cascading Style Sheets. Adobe XD supports a subset of CSS. Developer Console Displays logs and errors generated by your plugin, helping you debug your code. DOM Short for Document Object Model. Generally refers to the HTML5 DOM. ECMAScript See JavaScript. ES5 An older version of JavaScript from 2009. ES6 A modern version of JavaScript. See ES2015. ES2015 A modern version of JavaScript, previously named ES6. Destructive Action An action, which when taken, is destructive to the user's open document or their files. Such an action may be undoable, but this is not always the case. Dialog Represents a user interface concept whereby a sheet or window is displayed and asks the user for more information (hence the word \"dialog\" – the user and computer are dialoguing together). Dismissive Button A dismissive button will close a dialog. Whether an action continues after the dismissal of the dialog depends upon which button is clicked. \"OK\", \"Cancel\", \"Yes\", \"Don't Save\", \"Delete\" can all be dismissive buttons. Edit Context Represents the context within which a plugin or user is allowed to make edits to the user's scenegraph. Read more. GUID A globally unique identifier. HTML Short for hypertext markup language. XD Supports a subset of HTML. HTML5 The modern version of HTML. ImageFill Used to fill a SceneNode with bitmap data. Read more Instance An instance of a class. May also refer to instance properties or methods. JavaScript JavaScript is a common programming language that is used in many various contexts, including the web and on servers. Adobe XD uses JavaScript to help leverage the existing skills of the entire JavaScript ecosystem. JSON Short for JavaScript Object Notation. Manifest A manifest is used to declare various facts about a plugin. For example, a manifest includes the plugin's name, a unique ID, and what functions correspond with what menu items. Read more. Node A tree node. Depending on context, this node may refer to a HTML5 DOM Node or an XD Scenegraph node. React Also known as ReactJS. A declarative, component-based JavaScript library for building user interfaces. Learn more about React. SceneNode A SceneNode represents a node within the user's scenegraph. Scenegraph A scenegraph represents the user's document. It is so called because it is a tree (a kind of graph) of nodes that, when taken together, represents the entire \"scene\" of the document. Adobe XD provides an API for manipulating the scenegraph. Learn more about the scenegraph. SceneNodeList A list of scene nodes. Read more Static A static method or property. These exist at the class level, and not on instantiated objects. UXP Short for Unified Extensibility Platform. Adobe XD uses UXP for some of its extensibility APIs. XHR Short for XMLHttpRequest. XMLHttpRequest An network I/O API that can be used to request information from local and remote endpoints. See documentation. WebSocket A network I/O API that enables real-time communication with local and remote endpoints. See documentation. Widget Any interactive control or rendition provided by the user interface. For example, a clickable \"button\" is a widget. "},"migrations.html":{"url":"migrations.html","title":"Migrations","keywords":"","body":"Migrations As we introduce new features to the platform, we'll include documentation on migrating from one feature to another. This information is fairly time-bound, and as such, the information in this section may frequently change. "},"migrations/uxp-2-to-3.html":{"url":"migrations/uxp-2-to-3.html","title":"UXP 2 to 3","keywords":"","body":"UXP 2 to 3 XD 20 and below utilized UXP version 2. In XD 21, we're shipping a new version: UXP 3.1. This version is a huge release, and comes with lots of new features of which you'll want to take advantage. Because the new features in UXP 3.1 are so large, we also introduced a backwards-compatibility mode. All plugins use backwards-compatibility mode by default, unless the plugin explicitly opts into UXP 3 by updating its declared minVersion. This helps to ensure that most plugins won't suddenly change their appearance and have broken layouts. All plugins with a host.minVersion less than 21 use the UXP backwards compatibility mode. Plugins must explicitly opt-in to using the new layout features in UXP 3.1 by setting a host.minVersion of 21. Several features in UXP 3.1 are unavailable to plugins running in backwards-compatibility mode, and backwards-compatibility mode will not last forever. As such, you'll want to migrate your plugins to UXP 3.1 as soon as possible. Layout Engine Improvements UXP 3.1's layout engine has been improved to make it more compliant with existing web standards. Inline Layout In previous versions of XD (20 and below), all elements rendered using either block or flex layout semantics. In UXP 3.1, we now support inline layout semantics, including inline-block. This means, for example, that you can now easily place inline links or apply different styles within the same paragraph whereas it was difficult to impossible to do so before XD 21. For example: For more information about Adobe, visit Adobe's website. Insignificant Whitespace Furthermore, whitespace between elements is no longer considered significant. In previous versions of XD, it was possible to space elements out by adding additional whitespace. In UXP 3.1, you can only do this if you set the white-space CSS property to allow it. The whitespace is no longer significant But this whitespace is significant. There is a known issue in XD 21 (UXP 3.1) where white-space between inline elements is also ignored. This means that Hello World renders without the space separating \"Hello\" and \"World\". This will be fixed in a future release. SPANs are no longer leaf elements One other important result of this change is the fact that elements can contain additional elements. For example: This SPAN contains another span! z-index support You can also now change an element's stacking order by setting z-index. .menu { z-index: 99; } object-fit support UXP 3.1 also provides the ability to use the object-fit property to better control the layout of your elements. You can use contain and cover values to control if a replaced element should fit within its container or expand to fill it completely (both maintaining the aspect ratio). You can also use scale-down, none, and fill. For more information, see https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit. The examples in the MDN documentation will work in UXP 3.1. Borders and backgrounds may not be drawn as expected with object-fit. SVGs may also not be drawn correctly. CSS Parsing Improvements Along with the layout engine improvements, UXP 3.1 also delivers several key improvements to the CSS parser, bringing the parsing on par with the existing CSS standards. While UXP 3.1 does not implement the entire CSS spec, the parsing engine itself now more closely matches the specification. Improving the CSS parser also enabled UXP 3.1 to support CSS variables, additional units, calc, limited Media Queries, !important, and more. CSS Variables CSS Variables make it simple to modularize your CSS styles. For example, you could easily create multiple themes using CSS Variables. By changing the variable definition, the styles which rely on the variable are updated automatically. .dark { --text-color: white; --background-color: black; } .light { --text-color: black; --background-color: white; } .themed { color: var(--text-color); background-color: var(--background-color); } Hello There In the above example, \"Hello\" will be rendered with black text on a white background, and \"There\" will be rendered with white text on a black background. Additional Unit Support In versions of XD 20 and below, the only supported units were px and %. Unitless values were interpreted as px. In XD 21 and above, many of the CSS units are now supported. As such, unitless values are no longer supported (unless otherwise provided for by the CSS specification). You can now use em, rem, vh, vw, cm, in, etc., in addition to px and %. If you use vh with respect to font sizes, the font size will not update when the viewport height is changed. Calculation Support With the addition of additional unit support, UXP 3.1 also provides the calc function, which also works with mixed units. Now you can write an expression like width: calc(50% - 10px). calc only works for length values. It does not work for colors. Media Query Support UXP 3.1 offers limited support for media queries – namely queries around the width and height of the viewport. @media screen and (max-width: 260px) { input[type=range] { display: none; } } The above CSS will hide sliders whenever the plugin's viewport width is less than 260px. Versions of XD 20 and below would apply the styles in a media query, regardless of whether the condition was met. If you used media queries in your CSS, you may need to double check your code to ensure that your plugin renders as expected under UXP 3.1. Additional Property Values The improved CSS Parser also brings the ability to use unset, initial, inherit, and !important in your CSS and have them behave as per the specification. Previously these values were not supported. This means, that if you really need to, you can override styles, like so: .caption { color: blue !important; } Setting a border color to unset is not likely to result in the expected output. Linear Gradient Support The CSS parser now understands the Linear Gradient syntax. For example: body { background: linear-gradient(33deg, yellow, purple); } Multi-color stops are not supported. Other miscellaneous features Outline support: You can assign an outline to your elements with the outline rule. New pseudo-selectors: :lang and :focus are now available. Tab index, v1: Setting tab-index to 0 will now cause any element to be focusable. You can not yet control the tab order. Improved default for overflow: overflow now defaults to visible, not hidden, as per the web specification. Initial SVG support. Only simple SVGs are supported; complex SVGs may render in unexpected ways. Backwards Compatibility Mode When in backwards compatibility mode, UXP and XD will attempt to render it in a manner similar to XD 20 and below. This is not a perfect emulation of previous versions of UXP, but should work for most plugins in most cases. Backward-compatibility mode will not last forever. As such, developers are encouraged to look at their plugin with backward compatibility mode turned off so that they can start to plan for the fixes that will be needed. We don't have a firm timeline on how long backward compatibility mode will be supported, but developers should start taking advantage of the new layout engine as soon as they can feasibly do so. When in this mode (which is enabled by default unless your manifest specifies your plugin supports XD 21 as a minimum), the following rules are in place: Inline layout is ignored (display: inline[-block] is disabled). display is a valid property on elements (instead of style.display). When using position: absolute, and no coordinates are specified, 0x0 is assumed. z-index is ignored. Whitespace is treated as significant Unit-less height and width styling is supported UXP 2 semantics for auto margins. Unsupported backwards compatibility Semantics in UXP 2 for rendering border radii with percentages is not per web spec. UXP 3.1 renders border radii correctly. This will not be fixed as part of backwards compatibility. The difference is small and does not affect layout (just how round a corner is). Considerations when migrating Migrating from UXP 2 to 3 is not typically difficult. There are some considerations, however, of which you need to be aware. Font Rendering Changes UXP 3.1 introduces uses lower-level font rendering, and this can cause slight differences in layout. Depending on the constraints of your user interface, this may be enough to cause elements to render on more lines or wider than expected. Layout Changes The change from block to inline layout semantics can cause significant UI changes. If you used flex layout to render your plugin UI, you may not notice any difference when using UXP 3.1. However, if your code relied on block being the default layout mode, you may find that your layout no longer acts as expected. You can explicitly assign display: block to the offending elements, or rework your UI to work with inline layout. SPANs are no longer leaf elements As mentioned above, elements can now contain other elements. If your code included elements within s, you may find that your UI renders with unexpected styling. Media Queries UXP 2.x would always apply a media query, even if the condition wasn't met. UXP 3.1 will only apply a media query if the condition is met. Unitless Values UXP 2.x would parse unitless values as px unless the specification indicated otherwise. UXP 3.1 will treat these as invalid styles, which may cause your UI to render in odd ways. To fix, ensure you always use the correct units. Default Stylesheet Changes The default stylesheet in UXP 3 is different from that provided by UXP 2 and backwards-compatibility mode. This means that your plugin may take on a radically different appearance when not running in backwards-compatibility mode. Most of the differences in the default stylesheet are due to the presence of the panel insertion point for your plugins. Modal dialogs styling is generally the same. However, there are a few differences that might cause changes in your layout: is now rendered using display: inline-flex by default. This means form elements without a row or column class will render with the label to the left of the element instead of the label above the element. will also wrap if the width of the parent is too narrow. If you want to restrict this wrapping, you can apply flex-wrap: nowrap to the element. In the future, will more closely match the web standard. no longer needs the row class to lay out horizontally. Styles are applied with less specificity. This means it is easier to override the styling of an , for example. One place this may cause issues is that anchor colors are applied to anchors only with href attributes. If you need to override this color, use a[href] as the selector. Quick Feature Summary New Feature UXP 2.x UXP 3.1 (w/o backwards-compatibility) Inline Layout Unsupported Enabled white-space pre-wrap normal Leaf elements Can contain other elements z-index Unsupported Supported object-fit Unsupported Supported CSS Variables Unsupported Supported Units px, % The rest! calc Unsupported Supported (for lengths) Media Queries Unsupported Supported (for viewport) unset Unsupported Supported initial Unsupported Supported inherit Unsupported Supported !important Unsupported Supported Linear Gradients Unsupported Supported outline Unsupported Supported :lang, :focus Unsupported Supported tab-index Unsupported Partially supported overflow hidden visible "},"migrations/how-to-migrate-from-modal-to-panel.html":{"url":"migrations/how-to-migrate-from-modal-to-panel.html","title":"Porting Modals to Panels","keywords":"","body":"How to migrate from modal to panel Are you interested in converting your plugin's modal dialog box UI into a panel UI? Keep in mind that not every modal dialog flow is a good fit for this change. If you are curious about what differences exist, take a look at the docs for each UI entrypoint: Modal dialogs Panels If you determine your modal-based plugin would be even better as a panel, read on! Prerequisites Basic knowledge of HTML, CSS, and JavaScript Modal Quick Start Tutorial Panel Quick Start Tutorial Debugging Tutorial Sample code The complete example can be found in our Samples repository. Development Steps We are going to take a look at a sample plugin that lets users increase the width and height of the selected rectangle by inputting pixel values in the UI. As you can imagine, this process would be more efficient for the user if the plugin provided UI in a panel. Let's see what this plugin will look like before and after: As a modal As a panel Now, let's go through the steps of converting a modal plugin to a panel-based plugin. 1. Open your modal plugin code Note that your plugin structure does not change. Just like with modal plugins, the minimum required files for your panel plugin to work are main.js and manifest.json. You might have more files than this, depending on how you have structured your plugin. 2. Change uiEntryPoints and host.minVersion of your manifest.json Let's take a look at both cases. Modal: \"host\": { \"app\": \"XD\", \"minVersion\": \"15.0\" }, \"uiEntryPoints\": [ { \"type\": \"menu\", \"label\": \"Enlarge a Rectangle\", \"commandId\": \"enlargeRectangle\" } ] Panel: \"host\": { \"app\": \"XD\", \"minVersion\": \"21.0\" }, \"uiEntryPoints\": [ { \"type\": \"panel\", \"label\": \"Enlarge a Rectangle\", \"panelId\": \"enlargeRectangle\" } ] As you can see, host.minVersion is changed to 21.0 since 21.0 is the earliest version of XD that supports panels. Also, uiEntryPoints needs to be updated as well. The type key should be changed to panel and commandId key needs to be changed to panelId. 3. Understand the new structure of main.js A modal-dialog command needs one function to be exported: function enlargeRectangle() { // your code here } module.exports = { commands: { enlargeRectangle } }; Plugin panel UI, on the other hand, requires you to export an object with one required lifecycle method named show, and with optional lifecycle methods name hide and update: function show(event) { // your code here } function hide(event) { // your code here } function update(selection) { // your code here } module.exports = { panels: { enlargeRectangle: { show, hide, update } } }; Review the specifics of these panel lifecycle methods in the panel-object API reference before moving on. 3. Review your modal main.js code Let's first look at the main.js file of your original modal-dialog plugin: const { selection } = require(\"scenegraph\"); // [1] let dialog; function enlargeRectangle() { // [2] const html = ` .break { flex-wrap: wrap; } label.row > span { color: #8E8E8E; width: 20px; text-align: right; font-size: 9px; } label.row input { flex: 1 1 auto; } form { width:90%; margin: -20px; padding: 0px; } ↕︎ ↔︎ Apply `; function increaseRectangleSize() { // [3] const height = Number(document.querySelector(\"#txtV\").value); // [4] const width = Number(document.querySelector(\"#txtH\").value); const selectedRectangle = selection.items[0]; // [5] selectedRectangle.width += width; // [6] selectedRectangle.height += height; } if (!dialog) { let dialog = document.createElement(\"dialog\"); // [7] dialog.innerHTML = html; // [8] document.appendChild(dialog); // [9] document.querySelector(\"form\").addEventListener(\"submit\", increaseRectangleSize); // [10] } return dialog.showModal(); // [11] } module.exports = { // [12] commands: { enlargeRectangle } }; This code does the following: Gets reference to the selection. Creates a const called html and stores your UI markup, including elements for style, form, and so on. The form tag contains a div which includes two text input fields and a footer which has a button for users to click on. The p tag contains warning text which is used to warn users when they select a non-rectangle node inside the active XD document. Creates a nested function called increaseRectangleSize. Gets user input value from the \"height\" and \"width\" input elements. Gets the first currently selected node. (Some UI logic will be added later to ensure this is a rectangle.) Modifies the width and height of the selected rectangle. Creates a dialog element. Attaches the HTML created in step #1. Attaches the dialog element created in step #8 to the DOM. Adds a submit listener for the form element, attaching the increaseRectangleSize function created in step #2. Returns a JavaScript Promise which will resolve when the dialog is dismissed by the user. Exports the main function. 4. Modify the main.js file Let's start modifying code in the main.js file. Warn the user about invalid selections Your HTML markup does not have to change, but let's add a p tag to show a warning message if the user has selected a node that's not a rectangle: This plugin requires you to select a rectangle in the document. Please select a rectangle. Unlike modal UI, panel UI can stay open and persistent, optionally updating in real time based on a user's selection. Request to make changes to the scenegraph Unlike menu commands, which have just a single entry point the user can trigger to run the command, panel plugins have many different ways that the user can interact with their DOM elements to trigger an action. As a result, your panel UI event handlers must call special function when you want to make changes to the XD document. Any part of your panel that makes changes to the scenegraph needs to be wrapped in an application.editDocument call: const { editDocument } = require(\"application\"); editDocument({ editLabel: \"Increase rectangle size\" }, function(selection) { const selectedRectangle = selection.items[0]; selectedRectangle.width += width; selectedRectangle.height += height; }); Make a panel element Now, instead of creating a dialog, let's create a panel element, insert the HTML, and add an event listener with the increaseRectangleSize function attached. You can replace these lines of code: let dialog = document.createElement(\"dialog\"); dialog.innerHTML = html; document.appendChild(dialog); document.querySelector(\"form\").addEventListener(\"submit\", increaseRectangleSize); return dialog.showModal(); ... with this: let panelContainer = document.createElement(\"panel\"); panelContainer.innerHTML = html; panelContainer.querySelector(\"form\").addEventListener(\"submit\", increaseRectangleSize); event.node.appendChild(panelContainer); If you're wondering where the event object in that last line came from, we'll have a look at that in the next section. Your show lifecycle method: bring it all together All of the main.js code we've modified so far will be the content of your show lifecycle method that runs when the plugin opens. Note that the show and hide lifecycle methods for panel-based plugins receive an event argument. The event.node property is the DOM element where you can attach your panel UI for display in the application. Here is our complete show method for this plugin: let panel; function show(event) { const html = ` label.row > span { color: #8E8E8E; width: 20px; text-align: right; font-size: 9px; } label.row input { flex: 1 1 auto; } .show { display: block; } .hide { display: none; } ↕︎ ↔︎ Apply This plugin requires you to select a rectangle in the document. Please select a rectangle. `; function increaseRectangleSize() { const { editDocument } = require(\"application\"); const height = Number(document.querySelector(\"#txtV\").value); const width = Number(document.querySelector(\"#txtH\").value); editDocument({ editLabel: \"Increase rectangle size\" }, function(selection) { const selectedRectangle = selection.items[0]; selectedRectangle.width += width; selectedRectangle.height += height; }); } if (!panel) { panel = document.createElement(\"div\"); panel.innerHTML = HTML; panel.querySelector(\"form\").addEventListener(\"submit\", increaseRectangleSize); event.node.appendChild(panel); } } Your hide lifecycle method: tidying up Next, let's add the optional hide lifecycle method, which runs when the panel UI becomes invisible: function hide(event) { // This function triggers when the panel is hidden by user } Your update lifecycle method: staying aware as the user works The update function is another optional lifecycle method that allows your plugin to dynamically respond to the user's selection changes. We'll break this code down below: function update(selection) { // [1] const { Rectangle } = require(\"scenegraph\"); // [2] const form = document.querySelector(\"form\"); // [3] const warning = document.querySelector(\"#warning\"); // [4] if (!selection || !(selection.items[0] instanceof Rectangle)) { // [5] form.className = \"hide\"; warning.className = \"show\"; } else { form.className = \"show\"; warning.className = \"hide\"; } } This code does the following: Uses the selection argument. update provides two arguments, selection and root. This example only uses selection. Gets reference to the Rectangle object imported from the scenegraph module. Gets reference to the form element in your HTML. Gets reference to the p element with the warning message. Checks if the user has selected anything and if the selection is a rectangle. If this validation passes, the form appears and the warning message is not shown. If not, the warning message is shown to the user and the form disappears. Next Steps Now you have successfully converted your modal plugin to a panel plugin! Ready to explore further? Take a look at our other resources: Tutorials Sample code repos "},"design/":{"url":"design/","title":"Design","keywords":"","body":"Designing a plugin experience These guidelines will help you define the best user experience for your plugin. Based on your users workflow and the plugin action, different UX and UI patterns should be considered as you create a plugin. Plugins can interact with the user at different levels, for example, some plugins will have quick actions which in some use cases won’t render UI, and some will include multiple actions that need UI. Plugins in XD Learn more about the types of Adobe XD plugins you can build. Plugins Panel Modal Dialog Non-Blocking UI - this surface is best used when the user should have access to the canvas while using the plugin. Blocking UI - this surface is best used when the plugin needs to run an action and the user shouldn’t modify or change selection of objects on the canvas. UX Patterns User Experience patterns will provide guidence on how to interact with your plugin users within XD, this will highlight UX requirements and best practices. View UX Patterns User Interface UI Resources will have information on UI components, examples and a sticker sheet you can use to build your plugin View User Interface "},"design/ux-patterns/":{"url":"design/ux-patterns/","title":"UX Patterns","keywords":"","body":"UX Patterns UX Patterns will include UX requirements and/or UX best practices these will ensure your plugin follows XD user experience patterns. Panel UX Modal UX Onboarding Navigation Messaging Branding Documentation UX Requirements Requirements highlight key XD patterns all plugins need to follow to get approved by Adobe. Best practices Best practices provide recommendations on plugin usability and behavior, user feedback, privacy, and interface guidelines. "},"design/ux-patterns/panel-ux.html":{"url":"design/ux-patterns/panel-ux.html","title":"Panel UX","keywords":"","body":"Panel UX This section has recommendations when using a Plugins Panel - Non-Blocking UI. If the user needs to have access to the canvas then the plugin panel would be the best option, since it’s contextual to the users selection and allows the user to modify items on their canvas while interacting with the plugin UI. Overview Plugin Launch Pad and UI Contextual Feedback Adaptive layout Overview MacOS example Specs Plugin icon (your app icon)The plugin panel UI will include a plugin icon at the top of the panel next to the plugin name. PaddingThe panel will have padding built-in (ex: MacOS panel will have a 12px padding). Additional padding shouldn’t be added. UX Requirements NavigationIf the user is drilling down multiple panels, then provide a way for them to navigate back Login and LogoutIf the user has to login then provide a way for them to log out through the plugin UI RefreshIf the plugin needs to refresh for the user to see new information then provide a way for the user to refresh/sync through the plugin UI Plugin launch pad and UI Launch Pad - built-in Panel UI Contextual Feedback Selection based actions Don’t Don’t block all of the UI. If the plugin has other plugin actions that are not dependent on a selection, then users should be able to interact with those actions. Do Only disable the actions that are not available, so the user can still interact with other parts of the UI. Add a selection prompt in the UI to let the user know what they need to select to start using your plugin. This also allows users to see and understand the UI before they start using the plugin. Object selected Reflect the actions available based on the selection. If cancelling can happen when user changes selection then limit the number of cancel actions on the panel. Use cases where the user needs to input a lot of data than allow for a cancel action in the panel UI. In some use cases let the user know what has been selected by rendering a preview or if they have multiple items selected let them know in the panel UI. Importing object on the canvas Provide the user with feedback when the plugin has rendered a new object on the canvas. When dropping in multiple items into the canvas then let the user know where the items have been placed. Avoid dropping an artboard on top of other artboards. UX feedback examples Move viewport to object on the canvas Select the new object Running an action and providing feedback If the plugin is running an action, then let the user know by providing UI elements such as a progress indicator. This can also be a great opportunity to brand your empty states. Adaptive Layouts Since the user can resize the panel, content should adjust to accommodate for scrolling, responsiveness and footer actions. Scrolling Responsiveness Footer "},"design/ux-patterns/modal-ux.html":{"url":"design/ux-patterns/modal-ux.html","title":"Modal UX","keywords":"","body":"Modal UX This section will have recommendations when using a Modal Dialog - Blocking UI. If the plugin needs to run an action before the user starts a new action then the modal would be recommended for that use case. Overview Modal Dialog UI Dialog Buttons and Key Commands Overview MacOS example Specs PaddingThe modal will have padding built-in (ex: MacOS modal will have a 40px padding). Additional padding shouldn’t be added. Configurable contentThis is what the user can interact with before executing the plugin action. UX Requirements HeaderHave a clear header for the dialog. e.g. “name of plugin”, “description of workflow” Dialog ButtonsInclude a modal dismissal button to allow the user to cancel/close the modal and a call to action button (blue) to highlight the primary action. Best Practices Plugin Icon.You can include a plugin icon to let the user know they are interacting with your plugin in the modal dialog Modal Dialog UI Modal dialog plugin UI Step process three buttons Step process loader Dialog buttons and key commands Buttons Use cases. Call to actionThe call to action button communicates strong emphasis and is reserved for encouraging critical actions. There should only be one visible call to action button per section. PrimaryThe primary button is used for medium emphasis. It should be used in place of a call to action button when the action requires less prominence, or if there are multiple primary actions of the same importance on the page. It can be displayed either in standard style (visible stroke) or in quiet style. SecondaryThe secondary button is for low emphasis. It is meant to be paired with other button types to surface less prominent actions, and should never be the sole button in a group. It can be displayed either in standard style (visible stroke) or in quiet style. NegativeThe negative button is for high emphasis on negative or destructive actions. It should be used sparingly. It can be displayed either in standard style (visible stroke) or in quiet style. Best practice Button Group OverflowWhen horizontal space is limited, button groups stack vertically. They should appear in ascending order based on importance, with the most critical action at the bottom. Use 2 button styles maximumThe top-level action within a button group should be a call to action, primary, or negative button. The subsequent buttons should always be secondary buttons of the same style (standard or quiet). Don’t combine more than 2 button styles in a button group. Button labels Button labels should be clear about the intention of the action. Button text should be 1 to 2 words and consider the number of characters. Key Commands Esc keyDismisses the dialog. This is equivalent to choosing “Cancel”. Enter keyExecutes the primary button action. "},"design/ux-patterns/onboarding.html":{"url":"design/ux-patterns/onboarding.html","title":"Onboarding","keywords":"","body":"Onboarding These are guidelines and best practices on how to guide your users as they interact with your plugin. Providing users with examples on how to use the plugin can help your user get the most out of the plugin. This is helpful when the user is interacting with the plugin for the first time. Best practices ContentProvide examples or tutorials on how to use your plugin, this can be done by using visual or gifs. A. Plugin InteractionHighlight key interactions to make sure users can get the plugin to work. B. Login experienceThey need to log in or sign up for a service to use your plugin, guide them through the sign-up process. C. AuthenticationIf the plugin needs an API key or other account information, provide clear instructions on how they can get that information or provide a link. D. HelpProvide access to the help external link or documentation in the main navigation of your plugin or in error modal dialogs to allow them to troubleshoot. "},"design/ux-patterns/navigation.html":{"url":"design/ux-patterns/navigation.html","title":"Navigation","keywords":"","body":"Navigation These guidelines provide clarity on the different entry points a plugin can have. An entry point is how users access your plugin, users can access a plugin through the menu bar or a keyboard shortcut. Entry points Menu architecture - Top menu and Submenu items Keyboard shortcuts Entry Points Menu bar Plugin Launch pad Menu architecture - Top menu and Submenu items UX Requirements Plugin actionsExecutes a plugin action or open modal. Best practices Support-oriented itemsProvide help links, about tutorials or global settings. SettingsIf the plugin handles default preferences then consider having “plugin settings” as part of the submenu. (ex: export options, spacing rules) AboutUsers can refer back to onboarding materials such as tutorials and guides on how to use the plugin. HelpProvide the user with an external link to help documentation or an email through the submenu. Don'tDon’t add multiple actions for one plugin as top-level items. Top Menu Use CaseIf your plugin has one action or workflow shortcut then the action will be the top menu item. Plugin LabelA. Long label names will truncate B. The top menu label is the plugin name C. Limit the use of emoji’s as part of the label Submenu items Use Casesif your plugin needs to handle multiple actions or workflow shortcuts then they will render as a submenu. Plugin LabelA. If the plugin has a single submenu item then it will be shown as a Top Menu item B. Long label names will truncate C. Top menu label is the plugin name D. Submenu labels - action labels should have a descriptive name (i.e: Copy CSS) E. When a plugin needs further user action in order to continue, then at the end of the submenu label should use “…” F. Limit the use of emoji’s as part of the label Keyboard shortcuts If you are considering having a shortcut for your plugin, make sure to keep these guidelines in mind. Best practices If the user has another plugin with the same shortcut already installed, the new installed plugins shouldn’t expect to have that same shortcut. Can use a combination of “Shift” “Alt/Option” and “Control” Keyboard shortcuts are used by power users A keyboard shortcut can be used as an entry point but account for possible shortcut collisions "},"design/ux-patterns/messaging.html":{"url":"design/ux-patterns/messaging.html","title":"Messaging","keywords":"","body":"Messaging These are the guidelines and best practices on when and how to provide users with feedback as they interact with your plugin. Alerts Success Output Permission dialogs Loaders and Progress bars Examples Provide users with feedback as they interact with your plugin, this can be alert and success messaging, permission dialogs or loaders and progress bars to let them know something is running in the background. Below is a guide to help determine where to render plugin messages. Alerts Use caseUse alert messaging whenever the plugin cannot perform the intended task, dialogs are persistent until dismissed UX Requirements HeaderHave a clear header that describes the error MessageExplain what error was encountered and give a clear actionable solution. Also, avoid blaming the user or XD. Dialog buttonsInclude at least one modal dismissal button to allow the user to dismiss/close the modal Best practices Warning iconTo help communicate critical information for an error you can include a warning icon next to the header HelpIf a plugin has a help page, consider adding it to the error modal dialog. Visual/tutorialsProvide image/GIF example as part of the dialog, to help users understand the actionable solution MessagingIn the alert messages use language that is easy to understand for the user. Success Use caseUse success messaging whenever the plugin successfully completes a task and has no visual output on the canvas. UX Requirements HeaderHave a clear header for the dialog. MessageExplain what the plugin successfully completed, if it is not visually apparent to the user. Dialog buttonsInclude at least one modal dismissal button to allow the user to dismiss/close the modal. Output Use caseIf a plugin generates output that the user needs to complete a workflow, then the plugin needs to provide that information to the user. UX Requirements Plugin outputIn use cases like these, the plugin output can be shown in the UI, copied onto the clipboard, populated on the document or generate a file. Example:Copied onto the clipboard - the plugin can add copy to the clipboard and provides the user with instructions through the UI. Don’tRequire users to go into the developer console to complete an action. Permission dialogs Use caseUse permission dialogs when being destructive or making modifications. UX Requirements HeaderHave a clear header for the dialog. MessageExplain the destructive action or modification and ask for the user’s permission Dialog buttonsInclude a modal dismissal button to allow the user to cancel/close the modal and a negative button (red) to highlight that action. Key CommandsEsc key or Enter key Dismisses the dialog when the “Cancel” button is in focus Loaders and Progress bars Let the user know when something is happening in the background in the plugin UI. Best practices Determinate use caseUse case If the progress can be reflected on a loader. Indeterminate use caseIf the progress can’t be determined then provide a loader to let the user know something is loading. Examples Operation failed to completeError dialog - when a plugin can’t complete an operation, render an error dialog to let the user know the operation failed and why it failed. Network connectivity issueInformation dialog - if the plugin is unable to connect to the internet to complete an action, then use an information modal dialog to communicate that to the user. Unable to share“An error occurred while sharing your project. Please verify the email. address and try again”. Network connectivity“Please connect to WiFi to sync your tasks to your product management tool”. Panel UI messaging "},"design/ux-patterns/branding.html":{"url":"design/ux-patterns/branding.html","title":"Branding","keywords":"","body":"Branding To ensure users know they are interacting with your plugin, include branding throughout the plugin experience. Below are some examples. Onboarding and branding Customized plugin UI Onboarding and branding When the user is interacting with the plugin for the first time for example in the onboarding or login screen, including the plugin logo will help the user identify the plugin in the future. Customized plugin UI Customizing the UI to include brand colors, will help users distinguish your plugin from native UI in XD. "},"design/user-interface/":{"url":"design/user-interface/","title":"User Interface","keywords":"","body":"User Interface The user interface section will provide guidance around the different elements you can use to build a plugin UI. It covers everything from styles to building a layout. For guidance around the UX of a plugin and best practices refer to UX patterns. XD plugins can display UI in the form of modal dialogs, built with JavaScript and a supported subset of HTML and CSS. The tutorials contained in this section will give you an in-depth look at UI features available to your plugin through the API. Documentation In this section you can see what styles you can use in the UI, how to build a modal layout and the UI elements you can use. Styles - in this section you can learn more about rich styling options in your user interface through a combination of CSS and various classes that are defined for you. Layout - learn about the layout modes supported by the XD user interface APIs Elements - see what elements are fundamental to your user interface. Building a modal - a modal dialog is used to display important information and ask for user input. XD Plugins can display user interface in the form of modal dialogs. Design GitHub Repo - Use the sticker sheet to design your plugin in XD. "},"reference/ui/styles/":{"url":"reference/ui/styles/","title":"Styles","keywords":"","body":"Styles XD supports rich styling options in your user interface through a combination of CSS and various classes that are defined for you. Color Typography Using CSS Advanced information For specifics on what is and isn't supported, please refer to: Supported HTML Elements Supported Styles "},"reference/ui/styles/color.html":{"url":"reference/ui/styles/color.html","title":"Color","keywords":"","body":"Color Color is a very important part of your user interface. It can highlight important information or warn users about destructive actions. SemanticsExample (macOS)Example (Windows)HTMLThere are four classes of semantic colors beyond the normal standard text color.elements and text with informative semantics are colored blue. elements and text with positive semantics are colored green. elements and text intended to provide cautionary notice are colored orange. elements and text that provide warnings (negative semantics) are colored red. .bright { color: white; } .row div { flex: 1 1 auto; } .row div p { border-width: 2px; border-style: none; border-radius: 4px;} .row div p.border { border-style: solid; } Color SUFFIX red orange green blue color-* Negative Notice Positive Informative background-* Negative Notice Positive Informative border-* Negative Notice Positive Informative Usage By default, text is rendered using a dark gray color on a light background. The specific values differ by platform. You can attach classes to your content in order to use one of the semantic color classes, however. Color Text Color Background Color Border Color blue color-blue background-blue border-blue green color-green background-green border-green orange color-orange background-orange border-orange red color-red background-red border-red For example, if you want to render text with negative semantic, you could use the following HTML: This action is not reversible! When using the background-% classes, be sure to set the text color to white in order to ensure that the text is readable. Guidelines Communicating with Color Don't use color alone to convey intent. Instead add additional context in the form of icons or text. "},"reference/ui/styles/typography.html":{"url":"reference/ui/styles/typography.html","title":"Typography","keywords":"","body":"Typography Typography is an important aspect of user interface design. XD offers several tags and classes to make it easy to render typographically consistent designs. Fonts In general you should avoid specifying specific font families. Instead, allow your text to use the font provided by Adobe XD (which is typically the system font). If you do need to use a different font, ensure that: the font is available on the user's system by picking a safe, commonly installed font. avoid using more than two different fonts within a single dialog. The default font size is dependent upon the platform. macOS tends to render slightly smaller than Windows. Headings Headings are used to provide a very distinct, visual statement. These are most often used at the top of dialogs, but can be used within a dialog as well in order to help define areas using a visual hierarchy. Example (macOS)Example (Windows)HTMLheadings Heading Level One Heading Level Two HEADING LEVEL THREE In general, the following heading levels are used as follows: is used at the top of a dialog, and is typically immediately followed by a horizontal rule (). is used within a dialog to separate content. is used within a dialog to group content, and is typically capitalized. Text Size Typically you'll not need to override the basic text size. However, when rendering paragraph content, you may need additional options. There are three different sizes of paragraph text. Example (macOS)Example (Windows)HTMLBody Text Large text Go from concept to prototype with Adobe XD, the all-in-one UX/UI solution for designing websites, mobile apps, and more. Regular text Go from concept to prototype with Adobe XD, the all-in-one UX/UI solution for designing websites, mobile apps, and more. Small text Go from concept to prototype with Adobe XD, the all-in-one UX/UI solution for designing websites, mobile apps, and more. Each size class is for tags only. If you want to render large body text, you can do so using . For small text, use . Guidelines Italics Use italics for emphasis or for image captions. Underlines Use underlines for linkable content (that is, links that would open a web browser). Don't use underlines for emphasis. Paragraph Width Readability can be drastically reduced when paragraphs are too narrow or too wide. Avoid paragraphs that are narrower than 50 characters (on average) and wider than 120 characters. Paragraph Length Keep your content short and to the point to ensure that users don't have difficulty reading and understanding the text. Indentation Don't indent paragraphs. "},"reference/ui/styles/using-css.html":{"url":"reference/ui/styles/using-css.html","title":"Using CSS","keywords":"","body":"Supported Styles In order to customize the style of your user interface, you can use CSS style rules. For example, you can indicate that a DIV should have a red border with single pixel thickness by applying the style border: 1px solid red;. Styles can be applied in numerous ways. Styles can be applied by using JavaScript by changing properties on the style dictionary. someElement.style.backgroundColor=\"red\"; Styles can be applied using stylesheets. Stylesheets apply rules based on selectors — these are used to control which elements receive which styles. Styles can be imported using various methods (such as webpack), but they can also be added using a STYLE tag. When using innerHTML, you can define styles using the STYLE tag: #button { border: 1px solid red; } Hello There are several categories of styles, and each HTML element supports only certain styles. Some styles can be applied to just about every element, while other elements only have limited styling support. See the available styles for more information on what is supported. Not every element supports every style — especially interactive elements. Supported Selectors XD understands the following CSS selectors: id #anId { /* style */ } class .aClass { /* style */ } tag div { /* style */ } asterisk (universal selector) * { /* style */ } Descendant selector div > p { /* style */ } Group of selectors .aClass, #anID { /* style */ } Child selector div p { /* style */ } Sibling selector div + p { /* style */ } Attribute selector input[type=text] { /* style */ } Pseudo classes div:hover { /* style */ } Only hover, focus, and lang pseudo-classes are supported. Supported Functions Following CSS functions can be used: var() :root { –main-bg-color: pink; } body { background-color: var(–main-bg-color); } calc() input { padding: 2px; display: block; width: calc(100% - 1em); } #formbox { width: calc(100% / 6); border: 1px solid black; padding: 4px; } "},"reference/ui/layout/":{"url":"reference/ui/layout/","title":"Layout","keywords":"","body":"Supported Layout The XD user interface APIs support three layout modes: Block layout is the default layout mode. Each element is given the entire width of its container, and elements in sequence are stacked vertically — like blocks! Flexbox layout is the most flexible layout mode. Elements can be positioned within containers using a wide variety of rules, including rules that specify how elements can grow and shrink, and how elements should be aligned with respect to each other. Relative and absolute positioning provides the most pixel-perfect control over where elements are positioned. When the other modes don't suffice, you can use relative and absolute positioning, but you'll be in full control over where the element is positioned (for better or worse). "},"reference/ui/layout/block.html":{"url":"reference/ui/layout/block.html","title":"Block layout","keywords":"","body":"Block Layout The default layout system used by the XD User Interface API is block layout. This just means that elements are stacked vertically on top of each other, just like a stack of blocks. Each element will also stretch to fill up the available width in its container. Where the layout may surprise you is when dealing with elements that would typically receive inline layout semantics. This layout is essentially textual layout; that is, inline elements are laid out as if they were text on a page, flowing and wrapping along. In XD, all elements use block layout by default. This includes text-based elements like span, a, button, and all others. This can be a little surprising at first, but if the inline element is desired, one can use the Flexbox layout system to simulate some inline aspects. Let's consider the following HTML: .border { border: 1px solid red; padding: 4px; width: 300px; } .border * { border: 1px solid blue; padding: 4px; text-align: center; } Block, DIVs ABC Block, SPANs ABC Block, Ps ABC If you were thinking like a web browser, the first and third div containers would render their contents vertically, but the middle div would render its contents horizontally, essentially treating each span as a letter. XD, however, will render as follows: The middle block is rendered vertically as well, even though span elements are inline elements. This is definitely not how a typical web browser would work, but then again, XD isn't a web browser! "},"reference/ui/layout/flex.html":{"url":"reference/ui/layout/flex.html","title":"Flexbox layout","keywords":"","body":"Flexbox Layout The flexible box layout module is a layout system provided in CSS, which is significantly more flexible than using block layout. The layout module provides the ability for elements to shrink and grow based on available space, and also provides methods for specifying how much space to provide around elements. The flexible box module specification is quite large, and covering the entire specification is out-of-scope for this reference. If you want all the details, please refer to the following documentation: A Complete Guide to Flexbox Basic concepts of flexbox CSS Flexible Box Layout CSS Flexible Box Layout Module Level 1 (W3C Specification) Enabling flexible layout There are two types of elements when using flexible layout. First, there is the containing element — this is called the \"flex container\". Then there is the element that is being positioned within the flex container which are called \"flex items\". To turn an element into a flex container, one applies display: flex to the element. The orientation of the element defaults to the horizontal or row orientation, but can be overridden by specifying flex-direction: row | column | row-reverse | column-reverse. Whether or not wrapping should be allowed is controlled with flex-wrap (which defaults to nowrap, but can be set to wrap and wrap-reverse). All direct descendants within a flex container are flex items automatically. The spacing and positioning of these elements is controlled using the following styles: justify-content: indicates the rules to apply to spacing on the main axis; defaults to flex-start align-content: indicates the rules to apply to spacing on the cross axis; defaults to stretch align-items: defaults to stretch align-self: defaults to auto How items stretch and position themselves is determined by the item's flex properties: flex-basis: indicates the size of the flex item (defaults to auto) flex-grow: indicates the growth factor of the flex item (in comparison to other flex items; defaults to 0) flex-shrink: indicates the shrink factor of the flex item (in comparison to other flex items; defaults to 1) It might help to visualize the above with some diagrams. First, let's look at the flex properties. In the following image, each box is being given a flex: 1 1 auto (or flex: 2 2 auto, depending on the number). As you can see, the items that received flex: 2 2 auto are larger than the flex: 1 1 auto counterparts. And the last item has a fixed flex-basis supplied, which override the default size calculation. Now, consider the following HTML and styles: .border { border: 1px solid red; padding: 4px; width: 300px; } .flex { display: flex; flex-direction: row; } .between { justify-content: space-between; } .around { justify-content: space-around; } .start { justify-content: flex-start; } .end { justify-content: flex-end; } .center { justify-content: center; } .border * { border: 1px solid blue; padding: 4px; margin: 0 4px; } FLEX, SPACE-BETWEEN ABC FLEX, SPACE-AROUND ABC FLEX, FLEX-START ABC FLEX, FLEX-END ABC FLEX, CENTER ABC Given the above, XD will generate the following rendition: As you can see, the spacing between flex items can also be controlled. Combined, the flexible size and spacing of items can enable very complex layout with only a little CSS. That said, it's important not to overuse flexbox layout. The calculations are significantly more complex than both block layout and relative or absolute positioning, and if you have a lot of elements rendered, performance may suffer. If you know the size of the flex item, you can speed up the calculations by using a non-auto value for flex-basis Unsupported styles and values The following values are unsupported for each style: Style Rule Unsupported Values justify-content start end left right space-evenly safe unsafe normal stretch align-content start end space-evenly safe unsafe normal baseline first last align-items start end self-start self-end safe unsafe normal baseline first last align-self start end self-start self-end safe unsafe normal baseline first last place-content No support gap No support column-gap No support row-gap No support flex-flow shorthand No support; use flex-direction and flex-wrap "},"reference/ui/layout/positioning.html":{"url":"reference/ui/layout/positioning.html","title":"Positioning","keywords":"","body":" Please refrain from using position: fixed if you are building a panel plugin. Currently, there is a bug that allows panels to put elements outside the panel boundaries. This will break your panel plugin in a future release when the bug is fixed. Relative and Absolute Positioning You can use relative and absolute positioning to indicate exactly where elements are to be positioned. Relative positioning allows you to shift an element from its originally calculated position whereas absolute positioning takes the element out of the layout flow entirely, and allows you to position the element anywhere. Relative Positioning Relative positioning is enabled by specifying the position: relative style on an element. On its own, nothing much will happen (although it does have impacts on other positioned elements as we'll see). When combined with top, right, bottom and left styles, you can shift an element around. For example: .border { border: 1px solid red; padding: 4px; width: 300px; } .border * { border: 1px solid blue; padding: 4px; text-align: center; } .relative { position: relative; } .move { top: -12px; left: 12px; } A B C The following will be rendered: Element A is positioned normally. By default this is static positioning, meaning that it follows the regular layout rules. Element B is positioned relatively, but notice that it's in the same place you'd expect it to be in. This is because no offset has been applied. Element C, on the other hand, is positioned relatively and shifted up and left by twelve pixels. As you can see, C is free to overlap B. Also of import is the fact that the layout flow is otherwise undisturbed — the same amount of space will be reserved for C regardless of how much it is shifted out of its original position. Absolute Positioning Positioning an element absolutely with position: absolute immediately takes the element out of the regular layout flow. The layout will act as if the element simply doesn't exist. Instead, the element will be positioned relatively to its nearest positioned ancestor, and can be moved around using top, right, bottom, and left. If \"nearest positioned ancestor\" doesn't immediately make sense, that's OK. All it means it that an absolutely positioned element's (0, 0) coordinate is based on whichever element in its ancestry (parent, grandparent, etc.) is also positioned. If no elements are positioned, then (0, 0) is the upper left corner of the viewport. Absolute positioning is one of the fastest positioning methods, but is also the least flexible. Let's take a look at absolute positioning in action: .border { border: 1px solid red; padding: 4px; width: 300px; } .border * { border: 1px solid blue; padding: 4px; text-align: center; } .relative { position: relative; } .absolute { position: absolute; top: 0; left: 0; } .pos { top: 10px; left: 10px; } A B C D EF This will render as so: Notice that both A and B are still where we'd expect. But look at C and D — they're off in the upper left corner! That's because they have no positioned ancestors and so (0,0) refers to the top left corner. E is another relatively positioned element, so it makes sense that it would be below B, but notice: there's no extra space between B and E to account for C and D. As mentioned above, this is because absolutely positioned elements are taken out of the normal layout flow. Lastly, let's look at F – it's sitting at (10,10), but relative to E. This is what is meant by an element being positioned relative to its nearest positioned ancestor. In this case E is positioned (relatively), and so F's (0, 0) point is the top left corner of E. "},"reference/ui/layout/utility-classes.html":{"url":"reference/ui/layout/utility-classes.html","title":"Utility classes","keywords":"","body":"Utility Classes To assist with layout, there are two utility classes that are provided to you. row The row class will render the elements within in a row using the flexbox layout module. When building input fields with labels to the left (instead of above), consider adding align-items: center to the styles. .field { align-items: center; } Label column The column class will render the elements within in a column using the flexbox layout module. "},"reference/ui/elements/":{"url":"reference/ui/elements/","title":"Elements","keywords":"","body":"Elements Elements (or elements) are fundamental to your user interface. Buttons are used to invoke actions or dismiss dialogs. Buttons come in many different semantic styles, so it's easy to use the right button for the right occasion. Checkboxes provide the user with the ability to mark certain interface elements as selected. Dropdowns allow the user to select a single item from a list of items. Links will open the user's default web browser with the specified web address. Rules are used to visually segment your user interface. Sliders allow the user to pick a value from a finite range of values. Text fields enable the user to enter custom data. Tooltips are used to assist the user when an element's purpose may not be obvious. "},"reference/ui/elements/buttons.html":{"url":"reference/ui/elements/buttons.html","title":"Buttons","keywords":"","body":"Buttons Buttons can be clicked or tapped in order to initiate an action, trigger a command, or disclose previously hidden parts of the user interface. Buttons come in two flavors: pill buttons and action buttons. The pill buttons contain text, whereas the action buttons are typically used for icons and cases where you need to indicate the selected state of an icon. Buttons have multiple degrees of loudness (depending on your button's need for attention in the context of your user interface) and several variants for various uses (such as warnings or calls to action). Anatomy StandardQuietVariations (macOS)Variations (Windows) Usage You can render a button using the following: HTMLJSReactClick Me const button = document.createElement(\"button\"); button.textContent = \"Click Me\"; function render() { return ( Click Me ); } Variants There are several variants that you can specify by setting the uxp-variant attribute. Call To ActionPrimarySecondaryWarningAction ButtonThe \"call to action\" variant is intended to call out the action in the dialog that the user is encouraged to take. There should only ever be one of these in a dialog.There is no quiet variant of this button, since the intent of a call-to-action is to be obvious and draw the user's attention.Yes A primary button is used in place of a call-to-action button when the action itself is less prominent, or if there are multiple buttons with the same level of importance within the dialog. This variant supports a quieter (borderless) version.Create Create A secondary button is used in conjunction with other button variants to make other less prominent actions visible to the user. This variant supports a quieter (borderless) version.Cancel Cancel Warning buttons are used when the action is considered destructive. This variant supports a quiet (borderless) version.Warning buttons should never be the default buttons on a form (that is, the action that is invoked when the user presses ENTER to dismiss a dialog).Delete Delete Action buttons can be used to trigger actions within the dialog. These come in different variations and can include icons. Quiet (borderless) options are also available. Action buttons can also be \"selected\" when clicked. When used as a group, this ability to be selected can be used to indicate grid and list views, for example.Action buttons are often used to render icons. You should ideally have your icon as a 28x28 PNG file (for high DPI displays; use 14x14 for lower density displays). If you use a different size, Action buttons will resize, but the results may not be desirable. Note that XD will attempt to automatically use any available high DPI variants of an icon (i.e., it will automatically use @2x and @3x files automatically).Repeat Grid Repeat Grid Repeat Grid Layout How buttons are rendered will depend upon the layout of their container. Consider the following HTML and resulting rendering. HTMLmacOSWindows .wrap { flex-wrap: wrap; } BLOCK LAYOUT BUTTONS (Avoid) Hello BUTTONS IN FLEX HelloThere BUTTONS VARIANT IN FLEX Click me Click me Click me Click me QUIET BUTTONS VARIANT IN FLEX Click me Click me Click me BUTTONS VARIABLE WIDTHS, WRAPPING OK Short Medium Text Really long click button As you can see, buttons are, by default rendered in block layout. This results in very wide buttons, which aren't ideal. The remainder of the buttons are rendered in flex containers (see Flexbox layout). When rendered within flex containers, buttons will respect the stretching and positioning, but by default buttons will shrink to fit their textual content. If you need a specific width, you can assign a width style, but it is important to be aware that elements render with different metrics on macOS and Windows. Guidelines When using buttons, you should consider your user's experience and utilize the variants and loudness options to ensure your user knows what to expect when they click or tap on a button. Pill Button Guidelines Which Button Variant Should I Use? Avoid combining more than two different variants within a single dialog. The primary button should be a \"call to action\" button (uxp-variant=\"cta\"), a primary button (uxp-variant=\"primary\"), or a warning button (uxp-variant=\"warning\"). Other, lower promiment actions should use buttons of a similar lower variation (so, \"secondary\" or a quiet version). If there are multiple buttons within a dialog, there should be only one \"call to action\" button. This button is intended to attract the user's attention, and as such, it should be used for the primary action. Don't choose button types randomly; apply some thought to the user's experience when they use your dialog. Do give prominence to the main action by using a \"call to action\" button. Don't use more than two button variations in a group. Button Order You should prefer the button order that the platform your plugin is running on utilizes. macOS and Windows utilize different button orders. macOS, for example, will place the primary action in the lower right corner of a dialog, whereas on Windows, the same location is typically reserved for a cancel button. On XD, button order is determined automatically when placed within a element. The element assumes that your button order is in the macOS order, and will reverse the order when the plugin is running on Windows. This works well when there are only one or two buttons in a dialog footer, but doesn't work for all situations. In that case, you'll need to override the button order. Show me how to override the button order.import React from \"react\"; const platform = require(\"os\").platform(); const isWindows = platform.toLowerCase().substr(0,3) === \"win\"; function render() { return ( { isWindows ? ( Save Don't Save Cancel ) : ( Don't Save Cancel Save ) } ); } Follow Capitalization Rules Button text should be in title case. Don't use all capital letters to call attention to a button. (e.g., \"EXPORT ARTBOARD\") Don't use all lowercase letters. (e.g., \"export artboard\") Don't use sentence case. (e.g., \"Export artboard\") Do use title case. (e.g., \"Export Artboard\") Be Concise Your users should be able to infer the button's intent quickly. Button text should usually be one or two words long, and no more than four words. Don't use punctuation. Don't use punctuation in your buttons. (e.g., \"Export Artboard Now!\") Don't use long text. (e.g., \"Export Artboard To Your Storage Device\") Do keep the text short. (e.g., \"Export Artboard\") Use Clear Text Don't make your user guess as to what the button will do when they tap or click it. Avoid ambiguous phrasing like \"Yes\", \"Ok\", etc. Don't use ambiguous wording such as \"Yes\", \"No\", \"Ok\", etc. Do use clear, concise wording such as \"Save\", \"Don't Save\", \"Create\", etc. Button Width Buttons should be only slightly wider than the text within them (unless the text is extremely short). Don't fill a dialog with a button that stretches across the dialog. Don't stretch or apply width to a button. Button Icons Pill buttons don't support icons. In-Dialog Button Alignment Buttons should be aligned to the lower right corner of dialogs. Don't center or left-align your buttons in a dialog. Do align your buttons to the lower right corner in a dialog. Buttons with Context Menus (Popovers) Buttons that display a popover (context) menu should be the beginning of an action phrase. For example, if a button can create multiple types of shapes, the button itself could be named \"Create\" and the items in the popover could be \"Rectangle\", \"Circle\", etc. Action Button Guidelines Icon-only Action Buttons When only icons are used in an action button, the user can be left guessing as to what the button actually does. Consider using a tooltip to allow the user some insight into what the button will do before the user commits to clicking it. Show me how to add a tooltip to an icon-only action button. Isolated Action Buttons If you have an icon-only or text-only action button that is isolated from other buttons in your dialog, consider using the standard (non-quiet) version so that it's obvious that the control is indeed a button. Keyboard Interaction Key Action SPACE Clicks the button. ENTER Clicks the button. TAB Moves to the next focusable element. SHIFT+TAB Moves to the previous focusable element. Event Handling When clicked, buttons will fire the click event. You can listen to this in a couple of ways: Assign a handler to the onclick property. Call HTMLButtonElement#addEventListener to register a handler for the click event. JSReactconst button = document.createElement(\"button\"); button.textContent = \"Click Me\"; button.addEventListener(\"click\", evt => { // handle the button click here console.log(\"Clicked!\"); // if you need to cancel the default action, call evt.preventDefault() }); const React = require(\"react\"); function clickHandler(evt) { // handle the button click console.log(\"Clicked!\"); // if you need to cancel the default action, call evt.preventDefault() } render() { return ( Click Me ); } When a button of type=\"submit\" or uxp-variant=\"cta\" is present in a form, its click handler will be called if the user presses ENTER when not already focused on a button. Styling Buttons accept a limited amount of styling. You cannot change the following styles: Height Font family, weight, or text color Padding of text Color of the border around the button, or the color of the icon inside Attributes Supported Attributes disabled type: submit, reset, button uxp-variant: action, cta, primary, secondary, warning uxp-quiet: true uxp-selected: true autofocus: autofocus Unsupported Attributes autocomplete form formaction formenctype formmethod formnovalidate formtarget name value Known Issues At this point, XD does not support rendering buttons as input tags. All of the following are unsupported, and will render as regular text input fields: Buttons do not receive keyboard or pointer events. "},"reference/ui/elements/checkboxes.html":{"url":"reference/ui/elements/checkboxes.html","title":"Checkboxes","keywords":"","body":"Checkboxes Checkboxes allow a user to select one or more items from a group (or toggle an individual item on and off). Unlike some other controls, checkboxes only come in a standard variety. Anatomy StandardExample (macOS)Example (Windows) Usage You can render a checkbox using the following: HTMLJSReact .row { align-items: center; } Preserve aspect ratio Preserve aspect ratio const labelWrapper = document.createElement(\"label\"); labelWrapper.className = \"row\"; labelWrapper.style.alignItems = \"center\"; const checkbox = document.createElement(\"input\"); checkbox.setAttribute(\"type\", \"checkbox\"); checkbox.checked = true; const label = document.createElement(\"span\"); labelWrapper.appendChild(checkbox); labelWrapper.appendChild(label); function render() { return ( Preserve aspect ratio Preserve aspect ratio ); } Indeterminacy Checkboxes can be in an indeterminate state. This can be set only via the indeterminate property (not an attribute). If set to true, the checkbox will display with a dash instead of a checkmark (or lack thereof). Indeterminacy is orthogonal to the checkbox's checked state. Changing the checkbox's state will not change the controls indeterminate state. Keyboard Key Action SPACE Toggles the checkbox ENTER Toggles the checkbox TAB Navigates to the next focusable control SHIFT+TAB Navigates to the previous focusable control Styling Checkboxes accept a limited amount of styling. You cannot change the following styles: Height Color of the checkmark or checkbox Attributes Supported Attributes disabled type: checkbox checked: true autofocus: autofocus Unsupported Attributes autocomplete form formaction formenctype formmethod formnovalidate formtarget name value Supported Events change click Known Issues Checkboxes do not receive keyboard or pointer events. Checkboxes may fail to render correctly if in a scrollable container. To work around this issue, make sure the containing element has a background color. (transparent does not count; macOS only.) "},"reference/ui/elements/dropdowns.html":{"url":"reference/ui/elements/dropdowns.html","title":"Dropdowns","keywords":"","body":"Dropdowns Dropdowns (or select lists) allow the user to select an item from a dropdown list. There are various loudness options available. Anatomy Standard and QuietExample (macOS)Example (Windows)HTML .row { align-items: center; } Select First value Second value Last value Select First value Second value Last value Select First value Second value Last value Select First value Second value Last value Usage You can render a typical dropdown using the following: HTMLJSReact Target Artboard Icon Thumbnail Preview Target Artboard Icon Thumbnail Preview const labelWrapper = document.createElement(\"label\"); const label = document.createElement(\"span\"); label.textContent = \"Target Artboard\"; const select = document.createElement(\"select\"); select.uxpQuiet = true; // if you want a quiet dropdown const options = [ [\"artboard-1\", \"Icon\"], [\"artboard-2\", \"Thumbnail\"], [\"artboard-3\", \"Preview\"] ].map(([val, text]) => { const el = document.createElement(\"option\"); el.setAttribute(\"value\", val); el.textContent = text; return el; }); options.forEach(opt => select.appendChild(opt)); labelWrapper.appendChild(label); labelWrapper.appendChild(select); function render() { return ( Target Artboard Icon Thumbnail Preview Target Artboard Icon Thumbnail Preview ); } Guidelines Include a Label Dropdowns should always have a label — otherwise the dropdown can be ambiguous. There are occasions where context may make what the dropdown does obvious (for example, a sort-by dropdown). Label Position Ensure that the label is rendered above or to the left of the dropdown. When rendering labels to the left, you can use code like the following: .row { align-items: center; } Order ... Truncation Avoid truncating items by ensuring that the dropdown is wide enough for the longest item. Capitalization The dropdown's label should use title case, while the items themselves should use sentence case. Keyboard Key Action SPACE Displays the dropdown (if closed) or selects the highlighted item UP ARROW Displays the dropdown (if closed) or selects the previous item in the select list DOWN ARROW Displays the dropdown (if closed) or selects the next item in the select list ENTER Submits the active form (if dropdown is closed) or selects the highlighted item TAB Navigates to the next focusable control SHIFT+TAB Navigates to the previous focusable control Styling Dropdowns accept a limited amount of styling. You cannot change the following styles: Minimum width Font family, color, or weight Height Position of the chevron Color of the dropdown's border or chevron Background color Attributes Supported Attributes disabled value autofocus: autofocus uxp-quiet: true Unsupported Attributes autocomplete form formaction formenctype formmethod formnovalidate formtarget name Supported Events change Known Issues Dropdowns do not receive keyboard or pointer events. does not show the value as selected. Instead, get a reference to the element and call setAttribute(\"value\", …). tags must have a value attribute, or referencing the select's value property will return undefined. tags do not support the disabled attribute. "},"reference/ui/elements/links.html":{"url":"reference/ui/elements/links.html","title":"Links","keywords":"","body":"Links Links are used to open the user's default web browser to the specified web address. Links should be short and concise while also avoiding ambiguity. Example (macOS)Example (Windows)HTMLGo from concept to prototype with Adobe XD, the all-in-one UX/UI solution for designing websites, mobile apps, and more. Learn more about Adobe XD. Guidelines Where to Use Links Don't put links inside of headers. Note that because XD doesn't support inline layout, it isn't possible to put links inline with other content. If you do so, the link will render as a block element. Provide Context Don't just use link text like \"click here\". Give the user some context as to what your link will do. "},"reference/ui/elements/rules.html":{"url":"reference/ui/elements/rules.html","title":"Rules","keywords":"","body":"Rules Rules are used to visually segment your user interface. There are three variations of rules. Example (macOS)Example (Windows)HTMLLarge Rule Normal Rule Small Rule Usage The standard sized rule is created whenever you use the tag: You can control the size of a rule by using the small and large classes. Guidelines Using Rules with Titles Place rules below titles, not above them. A large rule should always be accompanied with text, although the other rule sizes can be on their own. Don't Overuse Rules Too many rules can be visually confusing. Keep it simple by restricting the number of rules you use. "},"reference/ui/elements/sliders.html":{"url":"reference/ui/elements/sliders.html","title":"Sliders","keywords":"","body":"Sliders Sliders allow the user to pick from a continuum of values between a minimum and maximum value. Slider values are continuous by default, but may be discrete if desired (using the step attribute). Consider using text areas when the range of values is very wide, or when typing a value will be more precise than dragging a handle. Anatomy StandardExample (macOS)Example (Windows)HTML .colorrow { display: flex; flex-direction: row; align-items: center; } .colorrow span { flex: 0 0 32px; } .colorrow input[type=text] { flex: 0 0 64px; } .colorrow input[type=range] { flex: 1 1 auto; } .spread { justify-content: space-between; } Opacity 50% Heading Level 3 PICK A COLOR R G B Usage You can render a typical slider using the following: HTMLJSReact .spread { justify-content: space-between; } Opacity 50% const labelWrapper = document.createElement(\"label\"); const label = document.createElement(\"span\"); label.textContent = \"Opacity\"; const displayValue = document.createElement(\"span\"); displayValue.textContent = \"50%\"; const labelAndDisplay = document.createElement(\"div\"); labelAndDisplay.className = \"row\"; labelAndDisplay.style.justifyContent = \"space-between\"; labelAndDisplay.appendChild(label); labelAndDisplay.appendChild(displayValue); const slider = document.createElement(\"input\"); slider.setAttribute(\"type\", \"range\"); slider.setAttribute(\"min\", \"0\"); slider.setAttribute(\"max\", \"100\"); slider.setAttribute(\"value\", \"50\"); labelWrapper.appendChild(labelAndDisplay); labelWrapper.appendChild(slider); function render() { return ( Opacity 50% ); } Guidelines Include a Label and a Value Sliders should always have a label and value. The value may be simple text, or it may be an editable text field (such as in a color picker). Label and Value Position Ensure that the label is rendered above or to the left of the dropdown. When rendering labels to the left, render the value to the right. Value Units Be sure to include the appropriate unit (such as a percent sign or \"px\", \"in\", etc.), unless rendering the value in a text field. Positive and Negative Values Be sure to include the sign on all values. When using a text-only display, add a space between the sign and the value for readability (e.g., \"- 32%\" or \"+ 64%\"). When using a text field, display the sign, but there's no need for an intervening space. Capitalization The slider's label should use title case. Keyboard Key Action UP ARROW Increases the slider's value (the amount is platform-dependent) RIGHT ARROW Increases the slider's value (the amount is platform-dependent) LEFT ARROW Decreases the slider's value (the amount is platform-dependent) DOWN ARROW Decreases the slider's value (the amount is platform-dependent) ENTER Submits the active form TAB Navigates to the next focusable control SHIFT+TAB Navigates to the previous focusable control Styling Sliders accept a limited amount of styling. You cannot change the following styles: Height Color of the slider's track, fill, or handle Attributes Supported Attributes disabled value min: the minimum value max: the maximum value step: if specified, the slider will return discrete values snapped to this value autofocus: autofocus Unsupported Attributes autocomplete form formaction formenctype formmethod formnovalidate formtarget name Supported Events change Known Issues Sliders do not receive keyboard or pointer events. "},"reference/ui/elements/textfields.html":{"url":"reference/ui/elements/textfields.html","title":"Text fields","keywords":"","body":"Text Fields Text fields allow user input for custom values. Text fields can be single or multi-line input fields, and come in various degrees of loudness. Anatomy StandardExample (macOS)Example (Windows)HTML Usage You can render a typical single-line textfield using the following: HTMLJSReact Layer Name const labelWrapper = document.createElement(\"label\"); const label = document.createElement(\"span\"); label.textContent = \"Layer Name\"; const textfield = document.createElement(\"input\"); textfield.setAttribute(\"type\", \"text\"); textfield.setAttribute(\"placeholder\", \"Enter a layer name\"); labelWrapper.appendChild(label); labelWrapper.appendChild(textfield); function render() { return ( Layer Name ); } Variations and Loudness Text fields have a standard rendition (with borders) and a quiet rendition (with a border at the bottom of the control). This is controlled with the uxp-quiet attribute. If uxp-quiet is omitted, the text field will draw with a border around the entire control. If uxp-quiet is true, the text field will draw with only a border at the bottom of the control. Single line text fields are created using the input type=\"text\" tag. Multiline text fields are created using the textarea tag, like so: Default text value here HTML5 allows you to specify the width and height of a textarea element using the rows and cols attributes. XD only uses the width and height styles. .top { align-items: flex-start; } textarea { height: 64px; } Text Hello Text Hello Text Hello Text Hello --> Behavior In panel UI When the user presses Escape or Enter in a text field, keyboard focus is sent back to the design canvas. You can prevent this by calling preventDefault() on the keydown event. To return keyboard focus to the design canvas programmatically, call blur() on whichever text field in your panel UI is currently focused. In dialog boxes Pressing Escape in any text field closes the dialog, resolving showModal()'s Promise with the string \"reasonCanceled\". This cannot be prevented. Guidelines Include a Label Text fields should always have labels, otherwise it is difficult for the user to discern what the field expects. Label Position Typically, labels should be above the text field and positioned to the left. You can also position labels directly to the left if you need. Left-positioned label example .field { align-items: center; } Layer Name Minimum Width Text fields should not be sized so much smaller than the typically expected value. Narrow text fields require a lot of user scrolling, and can lead to user confusion because the entire value may not be visible. Capitalization The text field labels should be in title case. Placeholder text should be in sentence case. Keyboard Key Action ENTER Submits the active form TAB Navigates to the next focusable control SHIFT+TAB Navigates to the previous focusable control Styling Text fields accept a limited amount of styling. You cannot change the following styles: Color of the border or the background color The font family, weight, or size The padding within the text area Attributes Supported Attributes autofocus: autofocus disabled: disabled readonly: readonly value min, max, step (Number fields) Unsupported Attributes autocomplete form formaction formenctype formmethod formnovalidate formtarget name defaultValue minlength maxlength capture inputmode list multiple pattern required size spellcheck tabindex usemap Supported Events change Known Issues Text fields do not receive pointer events. Validation is not currently supported. The following input type values are not supported, and will render as a regular text field: button, color, date*, email, file, hidden, month, radio, reset, submit, tel, time, url, week "},"reference/ui/elements/tooltips.html":{"url":"reference/ui/elements/tooltips.html","title":"Tooltips","keywords":"","body":"Tooltips Tooltips are used to provide additional context or help about an element. They appear when the user hovers over the item with their mouse for a short period o time. Tooltips are automatically enabled when you use the title attribute with an element. For example: Guidelines When to Use Tooltips Don't use tooltips when the context or intent is already clear. For example, a \"Print\" button doesn't need a tooltip. Use tooltips when iconography is present without corresponding visual text. For example, a warning icon could have a tooltip that indicates that a field is invalid. Maximum Size Tooltips should be as short and concise as possible. Keep tooltips to a few words. "},"reference/ui/dialogs/":{"url":"reference/ui/dialogs/","title":"Building a modal","keywords":"","body":"Dialogs A modal dialog is used to display important information and ask for user input. XD Plugins can display user interface in the form of modal dialogs. Dialogs appear over the XD document, and prevent further interaction with the underlying document. Dialogs are dismissed in any one of the following manners: The user presses the ESC key The user presses ENTER (assuming the plugin supplies an onsubmit handler) The user clicks or touches a button designed to dismiss the dialog. Dialogs are highly intrusive, and should only be used when absolutely necessary. Anatomy DialogmacOSWindows Usage When it comes to building the user interface, XD exposes an API surface that looks and feels a lot like what you would get in a web browser, namely: HTML5 DOM (Document Object Model) API CSS JavaScript These APIs and standards can be used to create compelling user interfaces, even inside modal dialogs. The above example is a typical modal dialog. Modal dialogs consist of: A dialog element () that is added to the DOM and contains everything that follows A form element () that wraps around the content of the dialog A heading (), which may also display the plugin's icon A horizontal rule () Some body content A footer () with one or more buttons () The margins and padding that surround the structure are provided automatically. There is generally no need to specify or override these margins in your own user interface, unless you want to do so. Building Modal Dialogs You can build modal dialogs using any method that creates an HTML5 DOM structure. This means you can use document.createElement, innerHTML, jQuery, React, and other frameworks. Let's examine a simple dialog and how we might create it. SampleHTMLJSReact #dialog form { width: 360px; } .h1 { align-items: center; justify-content: space-between; display: flex; flex-direction: row; } .icon { border-radius: 4px; width: 24px; height: 24px; overflow: hidden; } Create Shape Please enter the kind of shape you'd like to create. You can also include additional options by separating them with spaces. Shape Cancel Create let ourDialog; function showOurDialog() { if (!ourDialog) { ourDialog = document.createElement(\"dialog\"); ourDialog.innerHTML = ` form { width: 360px; } .h1 { align-items: center; justify-content: space-between; display: flex; flex-direction: row; } .icon { border-radius: 4px; width: 24px; height: 24px; overflow: hidden; } Create Shape Please enter the kind of shape you'd like to create. You can also include additional options by separating them with spaces. Shape Cancel Create `; } return ourDialog.showModal(); } const React = require(\"react\"); const ReactDOM = require(\"react-dom\"); function Form() { const styles = { form: { width: 360; }, h1: { alignItems: \"center\"; justifyContent: \"space-between\"; display: \"flex\"; flexDirection: \"row\"; }, icon: { borderRadius: 4; width: 24; height: 24; overflow: \"hidden\"; } }; return ( Create Shape Please enter the kind of shape you'd like to create. You can also include additional options by separating them with spaces. Shape Cancel Create ); } let ourDialog; function showOurDialog() { if (!ourDialog) { ourDialog = document.createElement(\"dialog\"); } ReactDOM.render(, ourDialog); return ourDialog.showModal(); } function render() { return ( Click Me ); } Once a dialog is built, you will need to manage its lifecycle: Showing a Modal Dialog Dismissing a Modal Dialog Variations Alert A simple \"alert\" can be used to display a message along with a Close button. You can customize the content of the title and message, but you cannot customize the button itself. Error An error \"alert\" (with a red heading). These are useful for rendering error messages. Just like regular alerts, you cannot customize the button itself. Confirmation Confirmation dialogs display a message and two buttons. The user is free to pick which of the buttons they wish to invoke. Do not use confirmation dialogs for destructive actions. Warning Warning dialogs display a message and two buttons, one of which is destructive. Pressing ENTER in this case should not invoke the destructive action. Otherwise it is the same as a confirmation dialog. Prompt Prompts display a single line text field in addition to a message and two buttons. Guidelines You should always strive to provide a good user experience with a modal dialog. That means providing easy access to dismissive buttons, avoiding dark patterns, and ensuring that your dialog doesn't block the user from forward progress in their work. You should definitely read up on our UX patterns for modals to learn more about what to do and what not to do. When to Use Dialogs Dialogs are very intrusive to the user's workflow. As such, you should consider their use very carefully. Don't display a \"success\" dialog when the result of the plugin is obvious to the user. Do display a \"success\" dialog when the result of the plugin is not obvious to the user (such as data being sent to a remote endpoint.) Don't fail silently — let the user know what went wrong and how they can fix it by showing a modal dialog. No Nested Dialogs You should avoid nesting dialogs within other dialogs. The only exception to this guideline is when displaying file or folder pickers. Three Buttons In general, try to strive to avoid dialogs with lots of buttons in the footer. You should try to use up to three buttons in the footer. Dismissive Buttons Dismissive dialog buttons live within a footer element. Within the footer, you can have any number of buttons, but you should follow these guidelines when defining variants (which you can use to indicate if a button is the default or is destructive): uxp-variant=\"cta\" indicates that the button is a \"call to action\". This is typically used for the default action. You should only have one of these buttons in a dialog. uxp-variant=\"primary\" indicates the button is a \"primary\" button. This is the default if uxp-variant is not specified. uxp-variant=\"secondary\" indicates the button is a \"secondary\" button. It receives a lighter color than primary buttons. uxp-variant=\"warning\" indicates that the button will trigger a destructive action. This button should not be the default action. Dismissive buttons should always be visible on screen without scrolling. If a dismissive button isn't visible, the user may think they are trapped in the dialog. Dismissal by other means You should avoid dismissing a dialog using other means, including action buttons, checkboxes, etc. Keyboard Interaction Key Action ENTER Submits the dialog's form ESC Cancels the dialog TAB Moves to the next focusable element. SHIFT+TAB Moves to the previous focusable element. Known Issues Large dialogs on small screens (or in small windows) do not scroll automatically and will clip. You should apply a fixed height to your dialogs. Dialogs are neither movable nor resizable. It is not possible to show multiple dialogs at once, except for file and folder pickers. It is not possible to intercept the ESC gesture when dismissing a dialog. Dialogs are always dismissible using ESC. When TABing in Windows 10, the focus border may appear incorrectly on some elements. On Windows 10, the tab order in a dialog's footer may be reversed. The background color is different on Windows and macOS. On macOS, it is #F5F5F5, and on Windows it is #FFFFFF. "},"reference/ui/dialogs/showing.html":{"url":"reference/ui/dialogs/showing.html","title":"Showing dialogs","keywords":"","body":"Showing a Modal Dialog Dialogs are shown using the HTMLDialogElement#showModal method. This method will render the dialog. The method will return a Promise, which you can use to easily wait for the dialog to be dismissed. dialog.showModal() .then(result => { // handle dialog result // if canceled by ESC, will be \"reasonCanceled\" }); The dialog element must be present in the DOM before showing it. If it isn't, the method will throw an exception. It's important to note that you can only show one dialog at once. You should always close or dismiss a dialog first and then wait for the dialog's promise to resolve before showing another one. "},"reference/ui/dialogs/dismissal.html":{"url":"reference/ui/dialogs/dismissal.html","title":"Dismissing dialogs","keywords":"","body":"Dialog Dismissal Dialogs can be dismissed in the following ways: Manually, by the user pressing the ESC key Programmatically, by calling HTMLDialogElement#close with an optional return value. You can listen for the default gesture (typically [ENTER]) by registering for the submit event on the form: function onsubmit(e) { dialog.close(\"ok\"); e.preventDefault(); } form.onsubmit = onsubmit; You should also register a click handler for your \"OK\" and \"Cancel\" buttons: const cancelButton = document.querySelector(\"#cancel\"); cancelButton.addEventListener(\"click\", () => dialog.close(\"reasonCanceled\")); const okButton = document.querySelector(\"#ok\"); okButton.addEventListener(\"click\", e => { onsubmit(); e.preventDefault(); }); You can listen for the dialog's dismissal using the close event on the dialog: dialog.addEventListener(\"close\", () => { // dialog is closed at this point }); Preventing Dialog Dismissal You can, in some cases, prevent a dialog dismissal. If the form calls preventDefault on the submit event, the dialog will fail to dismiss. It is not possible to cancel a dismissal triggered by the ESC gesture. "},"reference/ui/panels/":{"url":"reference/ui/panels/","title":"Building a panel","keywords":"","body":"Panel A panel is used to display information and options that are persistent and can be shown without blocking user interactions with the active document. Panels appear on the left-hand side of the app when user clicks on the Plugins icon at the bottom-left side. Panels do not prevent user interaction with the underlying document and can listen for the user's selection changes. Panels are dismissed in any one of the following manners: The user clicks on the \"back arrow\" button at the top of XD's Plugins panel The user clicks on one of the other options for the left hand side of the app, such as the Layers panel or Assets panel The user runs a different plugin from the Plugins menu Usage Building the user interface for panels is very similar to modals. Refer to Modal dialog usage. Building Panels You can build panels using any method that creates an HTML5 DOM structure. This means you can use document.createElement, innerHTML, jQuery, React, and other frameworks. Let's examine a simple panel and how we might create it: SampleHTMLJS .break { flex-wrap: wrap; } label.row > * { margin: 3px 0; } label.row > span { color: #8e8e8e; width: 20px; text-align: right; font-size: 9px; } label.row input { flex: 1 1 auto; } label.row input[type=\"number\"] { flex-basis: 32px; } div input[type=\"checkbox\"] { flex: 0 0 20px; } form footer > * { position: relative; left: 8px; } Aa ↕︎ ↔︎ &#x1F3A8; Apply let panel; function create() { const HTML = ` .break { flex-wrap: wrap; } label.row > * { margin: 3px 0; } label.row > span { color: #8E8E8E; width: 20px; text-align: right; font-size: 9px; } label.row input { flex: 1 1 auto; } label.row input[type=number] { flex-basis: 32px; } div input[type=checkbox] { flex: 0 0 20px; } form footer > * { position: relative; left: 8px; } Aa ↕︎ ↔︎ &#x1F3A8; Apply `; panel = document.createElement(\"div\"); panel.innerHTML = HTML; return panel; } function show(event) { // create panel the first time it's shown if (!panel) { panel = create(); event.node.appendChild(panel); } } function hide(event) { // in this example, we don't need to do anything when XD hides our panel } function update(selection, root) { console.log(selection.items); } module.exports = { panels: { example: { show, hide, update } } }; Note: you can either reuse your panel's UI nodes, or destroy and recreate the panel each time it's closed. For examples of both approaches, see the detailed documentation on the show() method. Handling Selection Change As you can see in the example above, every time the user's selection changes, your (optional) lifecycle method update will trigger. You will have access to both selection and root as parameters in the function. This means that your panel can display dynamic content based on what user has selected in the document. SampleHTMLJS .break { flex-wrap: wrap; } label.row > * { margin: 3px 0; } label.row > span { color: #8e8e8e; width: 20px; text-align: right; font-size: 9px; } label.row input { flex: 1 1 auto; } label.row input[type=\"number\"] { flex-basis: 32px; } div input[type=\"checkbox\"] { flex: 0 0 20px; } form footer > * { position: relative; left: 8px; } Aa ↕︎ ↔︎ &#x1F3A8; Apply let panel; function create() { const HTML = ` .break { flex-wrap: wrap; } label.row > * { margin: 3px 0; } label.row > span { color: #8E8E8E; width: 20px; text-align: right; font-size: 9px; } label.row input { flex: 1 1 auto; } label.row input[type=number] { flex-basis: 32px; } div input[type=checkbox] { flex: 0 0 20px; } form footer > * { position: relative; left: 8px; } Aa ↕︎ ↔︎ &#x1F3A8; Apply `; panel = document.createElement(\"div\"); panel.innerHTML = HTML; return panel; } function show(event) { // create panel the first time it's shown if (!panel) { panel = create(); event.node.appendChild(panel); } } function hide(event) { // in this example, we don't need to do anything when XD hides our panel } function update(selection, root) { const { Text } = require(\"scenegraph\"); if (!(selection.items[0] instanceof Text)) { panel.innerHTML = `Please select a text object.`; } } module.exports = { panels: { example: { show, hide, update } } }; Further Reading Refer to the panel lifecycle method documentation to learn more about these methods: Show Hide Update "},"reference/ui/panels/show.html":{"url":"reference/ui/panels/show.html","title":"show() callback","keywords":"","body":"Panel show() callback The show() function is the one lifecycle method in panel objects that is required. XD calls show() each time the user opens your panel. To populate the panel with UI elements, add DOM nodes to the event.node root node that is provided. There are two ways you can use show() to create your panel UI: Recreate panel on each show() For simple panels, you can create the panel UI each time it's shown and throw it away each time it's hidden: Here is a simple example: function show(event) { const content = \"Hello, World\"; const panel = document.createElement(\"div\"); panel.innerHTML = content; event.node.appendChild(panel); } function hide(event) { event.node.firstChild.remove(); } Create panel on first show(), then reuse For panels with more complex state, it may be simpler to continue reusing the same panel DOM nodes: let panel; function show(event) { if (panel) { return; } const content = \"Hello, World\"; panel = document.createElement(\"div\"); panel.innerHTML = content; event.node.appendChild(panel); } function hide(event) { // nothing to do here } Note: once the panel has been created you don't need to touch the DOM at all for hide & show to work correctly – XD takes care of closing and reopening the panel UI's container automatically. Panel content updating Whichever method you use, you'll typically also need to implement the update() callback in order to update your panel UI if the selection or XD document content changes while the panel is already open. "},"reference/ui/panels/hide.html":{"url":"reference/ui/panels/hide.html","title":"hide() callback","keywords":"","body":"Panel hide() callback The hide() function is an optional lifecycle method in panel objects. XD calls hide() each time your plugin panel is hidden – if the user navigates back to the overall plugin list view, toggles to show a different plugin's panel UI, or closes the left-land sidebar altogether. (hide() is not called when the window is closed or XD is quitting, however). The event argument provides the same event.node object as was passed to your show() callback earlier. You can choose to remove your UI at the time hide is called, or if you prefer to reuse your UI, you can leave it attached. See the show() documentation page for examples of both approaches. "},"reference/ui/panels/update.html":{"url":"reference/ui/panels/update.html","title":"update() callback","keywords":"","body":"Panel update() callback The update() function is an optional lifecycle method in panel objects. XD calls update() whenever your panel UI content should be refreshed: When the user changes the selection When the user modifies a node within the current selection. This can include actions such as move, resize, changing fill color, etc. When your panel is reopened after having been closed The update function receives selection and root arguments: function update(selection, root) { const { Text } = require(\"scenegraph\"); if (!(selection.items[0] instanceof Text)) { panelContainer.innerHTML = `Please select a text object in the document.`; } } Note that the example code above assumes you created a reference to the panel markup panelContainer at the global level when the panel was created. Whenever the update function is called, it is important to get in and out as quickly as possible since it's triggered for essentially every user action in XD while your panel is open. "},"design/user-interface/sticker-sheet.html":{"url":"design/user-interface/sticker-sheet.html","title":"Plugin sticker sheet","keywords":"","body":"Plugin sticker sheet This sticker sheet will cover the different UI surfaces available to plugins. It also includes UI kits (MacOS and Windows) you can use to build your own plugin. Download the latest version from the Plugin Design Assets Github repository. Download from GitHub UI kits "},"distribution/":{"url":"distribution/","title":"Share","keywords":"","body":"Sharing Your Plugin Congratulations on finishing building your plugin! It's totally fine if you built a plugin for yourself, but wouldn't you want other people to use your awesome plugin as well? If so, read some of the following pages depending on your need: Packaging your plugin Distribution options Publishing your plugin Marketing your plugin Deep-linking to your plugin listing Here are some of the recommended next steps for you: Join the community. See our Community page to learn about how to connect. Open-source your plugin on XD Awesome Contribute to any of our open-source projects "},"distribution/packaging.html":{"url":"distribution/packaging.html","title":"Packaging your plugin","keywords":"","body":"Packaging your plugin Before you share your plugin, you'll need to package it up. This tutorial describes how to package the files of an XD plugin. It's a simple process that can be summarized in three words: compress, rename, and verify. Prerequisite A code-complete plugin (if you don't have one yet, try our Quick Start Tutorial) Workflow 1. Compress your files as a .ZIP file Select all files within your plugin's parent folder. On both macOS and Windows you can right-click to compress: Platform Menu item macOS Right-click > Compress # items Windows Right-click > Send to > Compressed (zipped) folder If you plan to distribute via the XD plugin manager, your .ZIP file must be less than 25MB in size and contain fewer than 3,000 files. You'll only be able to submit for review if your file is under these limits. You should not compress the plugin's parent folder. Instead, compress the contents of the parent folder. Failure to do so will likely cause a rejection when submitting to the Adobe Developer Console. 2. Rename the .ZIP extension to .XDX Adobe XD recognizes the .XDX file extension as an XD plugin. By using this file extension, your plugin automatically gets the \"double-click to install\" feature, meaning that if you share your plugin directly to users, all they have to do is double-click to install the plugin to Adobe XD. If you plan to submit your plugin for distribution via the XD plugin manager, renaming your .ZIP to .XDX is required. 3. Verify the packaging worked Try double-clicking your .XDX file. It should prompt you to install the plugin: Click install: You'll get a success message upon installation, after which the plugin will show up in XD. Next steps You've packaged your plugin! Now you're ready to distribute your plugin. Learn about your options for distributing XD plugins to users. "},"distribution/options.html":{"url":"distribution/options.html","title":"Distribution options","keywords":"","body":"Distribution options Once you have a packaged plugin, you're ready to distribute. You can make your plugin available to users through the XD in-app plugin manager or via direct distribution. Prerequisite A packaged plugin The XD plugin manager The XD plugin manager lets users discover and install XD plugin right from within the app. Installation is as easy as a single click. To learn how to publish your plugin on the XD plugin manager, see our publishing tutorial. Direct distribution Direct distribution lets you choose how to provide users with access to your plugin. Your website? Email? Cloud file share? It's up to you! If you distribute a .XDX file, installation is as simple as one double-click. Note that attaching a .XDX file directly to an email might cause the email to get blocked. Outlook fails silently; the message disappears into the void, without being delivered to the recipient. Gmail notifies the sender that the message will be blocked. If you also have the same listing in the Plugin Manager, make sure the name field in the manifest matches the same field in the Plugin Manager listing. If there is a discrepancy, the name in the Plugin Manager will be used. Next steps If you plan to publish on the XD plugin manager, see our publishing tutorial No matter how you plan to distribute, be sure to see our plugin marketing tutorial "},"distribution/submission-checklist.html":{"url":"distribution/submission-checklist.html","title":"Submission checklist","keywords":"","body":"Submission Checklist Adobe XD users can discover plugins directly within the app via the XD Plugin Manager. All XD plugins listed in the Plugin Manager must first go through a review process before being published. By reviewing every plugin submission, Adobe aims to help developers get ready for primetime and ensure that users have great experiences with the plugins they install. This document will give you an idea of what we’re checking for during the review process. While lengthy, working through the points below will help you make sure you’ve accounted for all of the requirements and avoid having to fix things and resubmit before getting published. Plugin listing information Plugin listing information is the content that users will see in the XD Plugin Manager when browsing your listing. Unless otherwise noted, this is information that you will input and maintain on the Adobe Developer Console. In this section, we’ll go over what we’re checking for to ensure that your plugin listing is complete, correct, and in line with Adobe’s standards. Plugin description A plugin name can only include “XD” or “Adobe XD” if it fits the pattern “${Plugin Name} for XD”. Refer to the Adobe Branding Guidelines for further information. OK: “Rectanglator”, or “Rectanglator for XD” Not OK: “XD Rectanglator”, or “Rectanglator XD”. The plugin description must be relevant and self-explanatory. Regardless of supported languages, an English description must be provided. All listing content, including author name, email address, and website must comply with Adobe Branding Guidelines . Any plugin website must provide an email address or contact form so that users can contact the plugin developer easily. The listing may not link to websites that are in development (i.e. “under construction”, “coming soon”, etc). Manifest For panel plugins, the manifest minVersion must be set to 21.0 or above. For modal or headless plugins, the manifest minVersion must be set to 13.0 or above. Icons Placeholder icons will not be accepted. Icons must be unique and must be property of the plugin author. Submissions that contain icons from sample projects (or variations thereof) will be rejected. Plugin icons may not contain Adobe product assets or icons. Plugin icons must be clear and free of distortion. All required plugin icons must be provided at the appropriate dimensions and file sizes. See the manifest documentation and \"Publishing your plugin\" guide to learn more about which icons to include in your plugin package versus which to upload via the Adobe Developer Console. Adobe Branding Make sure to review and adhere to the Adobe Branding Guidelines. Avoid using publisher names, domain names, email addresses, and other such property names that are confusingly similar to existing Adobe brand, product, or service names. Using Adobe assets and icons in your plugin or your plugin marketing material requires explicit permission from Adobe (login required). Note that getting permission to use Adobe branding assets can add to the time it takes to get your plugin approved and published. External Services If your plugin requires paid credentials, when you submit your plugin to Adobe, you must provide test account login credentials, license number, or anything else that would be required to ensure that we can fully review your plugin. All plugin functionality must be accessible, either openly or through the credentials that you provide Adobe, for Adobe's reviewers. Third Party Companion Apps When a companion app is required, your plugin's description must indicate where the user can download the companion app. The companion app must successfully install on platforms it claims to support. The companion app must be able to successfully communicate with the plugin. The companion app must not cause abnormal resource usage (e.g., CPU, RAM, storage). Inappropriate Content The plugin and associated marketing surfaces must not include any intense violence, blood, gore, sexual content, nudity, or strong language. The plugin must not promote or conduct phishing, spamming, hacking, password trafficking, or spyware, nor contain malware, trojans, or viruses. Plugin functionality and UI Once users install your plugin, we want to make sure they have a great experience with their newfound addition to Adobe XD’s core product. In this section, we’ll go over what we’re reviewing in terms of your plugin’s functionality, UI, and more. Functionality The plugin must install without error. The plugin must launch via all insertion points that the plugin claims to support (e.g. Plugins Menu, Plugins Panel). The plugin must support any keyboard shortcuts provided by the developer. The plugin must show a loading indicator or spinner during longer operations like loading large content or accessing resources via a network connection. Modal dialogs must provide an affordance in the UI for closing the modal (e.g. a cancel/close button). The plugin must perform the desired actions when the user interacts with components in the plugin’s UI. The plugin must support all user selection types. Alternatively, if the plugin doesn’t support some selection types, the plugin must communicate this to the user when an unsupported selection is selected. The plugin must indicate to the user if an internet connection is not available but is required. The plugin must provide feedback to the user if it is unable to perform an action triggered by the user. The plugin must never show a completely blank UI. The plugin may not link to websites that are in development (i.e. “under construction”, “coming soon”, etc). If the plugin supports login functionality, it must also provide logout. User Interface For modal plugins, the plugin must be functional when the XD application window is at the minimum size that XD itself supports. For panel plugins, no content should be clipped when XD’s plugins panel is at minimum width. For panel plugins, the plugin's UI content must adapt appropriately when the panel width is increased. For panel plugins, the plugin's UI content must adapt appropriately when the panel width is decreased. The plugin must be functional when the XD application window is at maximum size. The plugin UI must scroll when all content is not visible on the screen. UI elements in the plugin must not overlap or truncate. UI content must wrap or adapt as necessary to accommodate the available width of the UI. Plugin content must be in compliance with Adobe Branding Guidelines. Internationalization and Localization The plugin UI must not break when the user enters valid characters for all languages the plugin supports. The plugin must support input from local keyboards for all languages the plugin supports. The plugin must provide localized strings for all languages indicated as supported by the developer and successfully display them when the system is set to each supported locale. The plugin UI must not break due to localized strings for supported locales. Performance The plugin must not degrade the performance of Adobe XD. The plugin must load in a timely manner. The plugin must not cause abnormal resource usage (e.g., CPU, RAM, storage). The plugin must not cause crashes, system errors, or any major failures. "},"distribution/how-to-submit-to-plugin-manager.html":{"url":"distribution/how-to-submit-to-plugin-manager.html","title":"Publishing your plugin","keywords":"","body":"Publishing your plugin The simplest way for Adobe XD users to discover and install plugins is through XD's in-app Plugin Manager. The XD Plugin Manager is accessed through: the Plugins menu in the app's menu bar: go to Plugins > Discover Plugins... the plus button (+) in the plugins panel on the left-hand side of the app In order to make your plugin available in the XD Plugin Manager, you'll need to go through our submission checklist and review process. Prerequisites Pre-submission checklist A packaged plugin Note: Edge is not currently supported for the plugin submission workflow. Please use another browser to submit your XD plugin. Submit your plugin You can submit your plugin for review through the Adobe Developer Console, the same place you got your unique plugin ID for your manifest. On the Adobe Developer Console, you can provide your packaged plugin. The Adobe Developer Console will automatically validate your package and its manifest file. Then, you will be asked to provide more information about your plugin on the Console. If everything looks good, you can then submit your plugin and our CC Integrations Review team will review it. We'll walk you through the workflow below. 1. Read the submission checklist All plugins are reviewed by our CC Integrations Review team. Make sure to thoroughly read the submission checklist before submitting to ensure a smooth path to publishing your plugin. Plugins violating these checklist items will be rejected, requiring you to address the issues and resubmit. 2. Begin your submission To begin the submission for your plugin, visit the Developer Console and select your plugin from your list of plugin projects. This will take you to your plugin's \"Project Overview\" page, which shows your plugin ID, a download link for your starter project, and more. In the left-hand navbar, you'll see a \"Distribute\" page. You can begin creating your listing from this page. 3. Submit plugin for review - Listing Information The \"Submit plugin for review\" page has two tabs: \"Listing information\" and \"Plugin file\". As the first step, you are asked to provide some facts about you, the publisher, and your plugin. Make sure that the plugin name in your manifest file and the plugin name you provide here match. Next, indicate whether your plugin requires installations of another application or use of a third party service. Also, include release notes for this version. This information will be displayed in the plugin manager to help users onboard your plugin. Next, you are asked to provide three plugin icons (48 x 48 px, 96 x 96 px, and 192 x 192 px). These icons will be used for display in the Plugin Manager listing. Note that, separately, you are required to include additional icons in your plugin package and include them in the manifest. These icons can be different from the ones that you use in Console and they will be used to show icons in the plugins panel within the application. You must also provide at least one screenshot of your plugin, which will be included in your Plugin Manager listing when published. Finally, if you have a message for our reviewers, write it here. Note that if your plugin requires a paid account, license number, or other such credentials to use all features of the plugin, you must provide test credentials in the \"Note to Adobe reviewers\" field so Adobe can review the plugin. If we need credentials from you and they have not been shared in this field, your plugin submission will be rejected. 4. Submit plugin for review - Plugin File Once you have provided all required information about your plugin, including icons and screenshots, you will be asked to attach your plugin package. Make sure to properly package your plugin into an .xdx file. When your plugin passes all validation checks by the Adobe Developer Console, the \"Submit\" button will be activated for you to click. Congratulations on your submission! We can't wait to have a look at what you've created! CC Integrations Review After you submit, the CC Integrations Review team will review your plugin. Depending on current submission volume, it can take up to 10 business days before you hear a response. Thank you for being patient with us. Many of the items our reviewers check for when reviewing a plugin are noted in the submission checklist. Once your submission has been reviewed, we’ll reach out letting you know if it has been approved or rejected, and provide any next steps. Marketing your plugin No matter how you plan to distribute, be sure to see our plugin marketing guide to learn about the ins-and-outs of marketing an Adobe XD plugin. "},"distribution/marketing.html":{"url":"distribution/marketing.html","title":"Marketing your plugin","keywords":"","body":"Marketing your plugin No matter how you plan to distribute your XD plugin, your marketing must follow Adobe's branding guidelines. We want you to be able to promote your plugin while protecting Adobe's corporate and product brands and trademarks. For details, make sure to read the Adobe Creative Cloud Developer Brand Guide. The brand tutorial includes best practices for brand assets in marketing, press releases, and social media, and is the best spot to get our most up to date assets. You’ll also find information for how to publicize and promote your plugin once it’s approved. Plugin deep links You can create a deep link from web sites, social media, etc. directly to your plugin listing in XD's UI so users can easily install the plugin. "},"distribution/how-to-create-deep-links.html":{"url":"distribution/how-to-create-deep-links.html","title":"Deep-linking to your plugin listing","keywords":"","body":"How to create a deep link for a plugin listing This tutorial walks through the process of deep-linking to an XD plugin listing. Deep-linking is a method by which you can get users into a specific part of an application using a custom URL. Prerequisites Plugin listing deep-linking only works with users on Adobe XD 14+ (released in December 2018) Your plugin should have a plugin ID and be listed on the Plugin Manager URL & Parameters In this section, we'll look at how to create the unique URL for your plugin listing. Base URL All plugin listing deep links start with this base URL: https://xd.adobelanding.com/en/xd-plugin-download/? Parameters These parameters are appended to the base URL: name- This parameter refers to your unique plugin ID which can be retrieved from the Adobe Developer Console Complete example https://xd.adobelanding.com/en/xd-plugin-download/?name=036869b3 Successful user workflow This section describes what the user will experience when they click a plugin listing deep link. User confirmation The browser will ask user for confirmation: Browser confirmation message and XD launch Once the user clicks on \"Open Adobe XD CC\", the browser will display a confirmation messsage and take the user to the Adobe XD application with the Plugin Manager open to the plugin listing: Fallback This section describes what the user will experience when there is an issue encountered in the above workflow. No parameter provided If no parameter is included in the URL or an inaccurate parameter is provided, the browser will show an error message and show the user how to manually download plugins Inaccurate parameter examples: https://xd.adobelanding.com/en/xd-plugin-download/? https://xd.adobelanding.com/en/xd-plugin-download/?wrongparameter=036869b3 These inaccurate URLs will result in showing the following error message in the browser: Inaccurate plugin ID provided If an inaccurate plugin ID is provided, the browser will succesfully launch XD and the Plugin Manager, but it will show a \"Plugin not found\" error: Example: https://xd.adobelanding.com/en/xd-plugin-download/?name=wrongpluginid XD not installed If XD is not found on user's system, the browser will show an error message with the option to download XD Next Steps Ready to explore further? Take a look at our other resources: Tutorials Sample code repos "}}